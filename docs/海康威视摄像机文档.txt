首页

发版说明

编程引导

API参考

示例程序

法律声明

发版说明

V4.4.1

【功能新增】

新增 IInterface.EnumDevices() 接口，支持枚举采集卡上的相机。

新增 IInterface.EventNotificationOn() 、 IInterface.EventNotificationOff() 、 IDevice.EventNotificationOn() 、 IDevice.EventNotificationOff() 接口，支持开启和关闭相机和采集卡的指定事件。

新增 ImageStitchingMethod() 枚举类型，代表图像拼接方式。

新增如下示例程序：

ParameterCamera_LineScanIOSettings.cs 示例程序，演示如何配置线阵相机帧触发和行触发相关节点IO。

Image_Save.cs 示例程序，演示如何保存图像数据。

InterfaceAndDeivce.cs 示例程序，演示如何实现先枚举采集卡，打开采集，然后通过采集卡实例枚举相机、从相机取流。

MultiLightCtrl_ImageStitching.cs 示例程序，演示如何设置线阵相机分时曝光并将图像拆分后再拼图。

【功能更新】

修改 IImageProcess.ReconstructImage() 接口，支持拆分图像后再拼接图像。

修改 RenderMode() 枚举类型，添加OpenGL选项。

更新示例程序，包括 Grab_GetImageBuffer.cs 、 Image_Contrast.cs 等。

【功能废弃】

删除配置相机I/O（ParameterCamera_SetIO.cs）和配置采集卡I/O（ParameterInterface_SetIO.cs） 示例程序。

V4.4.0

【功能新增】

新增 IParameters.FeatureLoadEx() 接口，支持导入设备属性文件，并保存错误列表信息。

新增 INodeError 结构体，为参数导入导出时的节点错误信息。

新增 NodeErrorType() 枚举类型，代表节点错误信息。

【文档调整】

优化章节顺序。

V4.3.2

【功能新增】

整体优化重构各类及接口。

.Net示例程序与C接口示例程序对齐，UI示例提供Winform和WPF两个版本。具体的示例程序文件路径以及示例代码请参见 示例程序概览 。

对.NET Framework 版本要求提高至V4.0.0及以上版本。

重构SDK开发指南的编程引导章节，并补充核心接口的调用示例。

状态码及异常调整至API参考章节下。

注解

该版本与之前的旧版接口使用同一个dll（MvCameraControl.Net.dll），并兼容旧版接口。

注意

MvCameraControl.Net.dll中包含两个命名空间， MvCameraControl 和 MvCamCtrl.NET 。其中的 MvCamCtrl.NET 为兼容旧版本接口而保留，开发时无需关注该命名空间。本文档仅针对 MvCameraControl 说明引用该命名空间后的开发方法。

【文档调整】

全新重构版本。

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

引用SDK的.Net程序集

开发前必读

初始化

控制相机

控制采集卡

配置设备参数

采集图像

处理图像

获取事件

编程引导

引用SDK的.Net程序集

开发前必读

初始化

控制相机

控制采集卡

配置设备参数

采集图像

处理图像

获取事件

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

引入SDK的.Net程序集

开始前，请参照本文配置开发环境，然后将SDK的.Net程序集引入至您的项目并引用该库的命名空间。

开发环境要求

请确保开发环境符合如下要求：

已安装Visual Studio 2010或更高版本。

已安装 .NET Framework 4.0及以上框架。

操作步骤

将SDK的.Net程序集（MvCameraControl.Net.dll）引入至您的项目。

SDK提供了适配不同Windows系统的.Net程序集。这些.Net程序集位于客户端安装路径下的Development文件中，具体路径如下。

适用系统 .Net程序集路径

Win32和Win64均适用 ..\Development\DotNet\AnyCpu\MvCameraControl.NET.dll

仅Win32适用 ..\Development\DotNet\win32\MvCameraControl.NET.dll

仅win64适用 ..\Development\DotNet\win64\MvCameraControl.NET.dll

注意

MvCameraControl.NET.dll 不在环境变量中，引入该库需勾选复制到本地，或自行将该库复制到生成目录。

若勾选了复制到本地，更换库后，编译前需要删除生成目录下的库文件。

下图以“通过Visual Studio引用.Net程序集”为例，单击图中所示的【添加引用】即可选择上述路径引入.Net程序集。

引用MvCameraControl.Net.dll的命名空间 MvCameraControl 。

using MvCameraControl;

注意

MvCameraControl.Net.dll中包含两个命名空间， MvCameraControl 和 MvCamCtrl.NET 。其中的 MvCamCtrl.NET 为兼容旧版本接口而保留，开发时无需关注该命名空间。本文档仅针对 MvCameraControl 说明引用该命名空间后的开发方法。

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

开发前必读

开始开发您的程序之前，建议您先了解SDK的.Net程序集的全局概况，包括该库核心类、各核心类的调用流程，以及该库接口的通用调用方式。

.Net程序集核心类

基础调用流程

通用调用方式 非托管内存释放

设备控制

事件注册与处理

错误与异常处理

.Net程序集核心类

下图展示了.Net程序集的核心类。

上图中各类的简介如下：

SDKSystem ：获取和配置SDK全局信息。

相机模块

IDeviceInfo ：相机基本信息类，包含相机级接口类型、型号、序列号等属性。

DeviceEnumerator ：相机枚举类，用于获取相机信息 IDeviceInfo 。

DeviceFactory ：相机工厂类，用于创建相机实例 IDevice 。

IDevice ：相机控制类，用于控制相机，如打开和关闭相机。

GenTLManager ：GenTL设备控制类，用于加载第三方GenTL库，控制第三方采集卡上的相机。

采集卡模块

IInterfaceInfo ：采集卡基本信息类，包含采集卡接口类型、采集卡ID、序列号等属性。

InterfaceEnumerator ：采集卡枚举类，用于获取采集卡信息 IInterfaceInfo 。

InterfaceFactory ：采集卡工厂类，用于创建采集卡实例。

IInterface ：采集卡控制类，用于控制采集卡，如打开和关闭采集卡。

参数和事件模块

IParameters ：参数类，获取/设置相机和采集卡的参数。

IEventGrabber ：事件类，用于获取相机和采集卡的事件信息。

图像模块

IStreamGrabber ：取流类，用于取流、获取一帧图像、停止取流等。

IImageProcess ：图像处理类。

IImageDecoder ：图像解码类。

IImageRender ：图像渲染类。

IPixelTypeConverter ：格式转换类。

IImageSaver ：图像保存类。

IVideoRecorder ：录像类。

基础调用流程

SDK实例生命周期内，相机模块和采集卡模块的基础调用流程如下图所示。

注解

上图涉及的具体接口调用流程，请参见 控制采集卡 和 控制相机 。

上图中的 Dispose() 为.NET接口。

通用调用方式

开始接口调用之前，请先了解.Net程序集的通用调用方式，包括非托管内存释放的调用方式、设备控制功能的调用方式、SDK事件调用方式，以及错误与异常处理的调用方式。

非托管内存释放

.Net程序集的很多类，例如相机类 IDevice 和采集卡类 IInterface ，会向系统申请非托管内存。为了安全释放非托管内存，这些类都实现了System.IDispose，可让.NET框架的垃圾回收机制自动回收SDK所占用的资源。由于该垃圾回收机制存在滞后性，建议您主动释放资源，以保证资源及时被释放。

可通过如下两种方式主动释放资源。

方式1：调用.NET的 Dispose() 以下示例代码演示了如何通过调用该接口，实现将相机实例占用的非托管内存及时释放。

try {

// ch:创建设备 | en:Create device device = DeviceFactory.CreateDevice(deviceInfo); }

catch (Exception e) {

Console.WriteLine(e.Message); }

finally {

if (device != null) {

// ch:释放设备资源 | en:Dispose resource device.Dispose(); }

}

方式2：使用using命令释放资源

若使用了该命令，该命令执行结束后，.NET框架将自动调用方式1中提及的 dispose()，实现资源及时释放。

// ch:创建设备 | en:Create device using (IDevice device = DeviceFactory.CreateDevice(deviceInfo)) {

// ch:打开设备 | en:Open device device.Open();

// ch:关闭设备 | en:Close device device.Close(); }

设备控制

若要实现相机实例 IDevice 和采集卡实例 IInterface 与实际设备通信，必须先与实际设备建立连接，获取实际设备的访问权限。

以相机实例 IDevice 为例，调用 DeviceFactory.CreateDevice() 创建该实例后，该实例尚未与实际设备建立连接。若需建立连接，需调用 IDevice.Open() 。调用成功后， IDevice 实例才可访问相机的参数并采集图像。不再需要与实际设备通信时，调用 IDevice.Close() 断开与设备的连接。采集卡实例 IInterface 也是同样的逻辑。

// ch:创建设备 | en:Create device device = DeviceFactory.CreateDevice(devInfoList[devIndex]);

// ch:打开设备，获取设备访问权限 | en:Open device device.Open();

// ch:获取相机参数 || en:Get parameter of the device device.Parameters.GetIntValue("Width", out intValue); device.Parameters.GetIntValue("Height", out intValue);

// ch:关闭设备 | en:Close device device.Close();

事件注册与处理

SDK提供的事件（例如 IEventGrabber.DeviceEvent ）通过.NET的标准event实现，您可使用标准event的方式处理SDK事件。

假设您自定义的事件处理函数如下：

// ch:事件处理函数 | en:Event handling function void DeviceEventGrabedHandler(object sender, DeviceEventArgs e) {

Console.WriteLine("EventName[{0}], EventID[{1}]", e.EventInfo.EventName, e.EventInfo.EventID); }

以下示例代码演示了如下逻辑：

注册SDK的设备事件（+=表示注册），并通过上述事件处理函数处理设备事件。

// ch:注册event | en:Register event device.EventGrabber.DeviceEvent += DeviceEventGrabedHandler;

错误与异常处理

SDK部分接口在调用后返回错误码，另一部分接口不返回错误码，而是抛出异常信息。

错误码

SDK大部分接口在被调用后都会返回代表错误码的int值。可通过该返回值判断是否调用成功。错误码定义请参见 MvError 类。

// ch:获取相机宽度信息 || en:Get 'Width' info of device int ret = device.Parameters.GetIntValue("Width", out intValue); if (ret != MvError.MV_OK) {

Console.WriteLine("Get Width failed:{0:x8}", ret); return; }

异常处理

一些特殊接口无法返回错误码，如创建设备和注册事件等接口。这些接口被调用后，SDK会抛出异常信息，您需通过 try...catch 捕获对应的异常信息。

try {

// ch:创建设备 | en:Create device device = DeviceFactory.CreateDevice(devInfoList[devIndex]); }

catch (MvException e) {

Console.WriteLine(e.Message); Console.WriteLine("ErrorCode: " + e.ErrorCode.ToString("X")); }

finally {

if (device != null) {

device.Dispose(); }

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

初始化

将.Net程序集的命名空间引用至您的项目后，需先对SDK进行初始化。

前提条件

已配置符合要求的开发环境。并已引用SDK的.Net程序集及该程序集的命名空间。详情参见引入SDK的.Net程序集。

初始化SDK

调用 SDKSystem.Initialize() 初始化该SDK的运行环境，以便于提前申请和分配所必须的系统资源，提升后续接口调用的流畅性。

在程序退出时，可调用 SDKSystem.Finalize() 进行反初始化，释放被该SDK所占用的系统资源。

如下示例代码演示了初始化运行环境的过程。

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize()

// TODO：进行设备控制，图像采集等操作 | en: You can type your own code here.

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize()

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

控制相机

本节介绍如何通过调用SDK接口，在您的程序上实现枚举等基础相机控制功能，并在之后实现相机参数配置、图像采集、图像处理等其他核心功能。

前提条件

已完成SDK初始化。详情参见初始化。

步骤一：枚举相机

按需调用如下接口（三选一），枚举同网段内的相机。

选项1：调用 DeviceEnumerator.EnumDevices() 时需传入设备接口类型 TLayerType ，调用成功后该接口返回对应类型的设备列表 devInfoList 。

设备接口类型为MvGigEDevice时，枚举所有GigE设备，包含虚拟GigE设备和采集卡上的GigE设备，

设备接口类型为MvUsbDevice时，枚举所有USB设备，包含虚拟USB设备。

设备接口类型还包括 MvGenTLCameraLinkDevice 、MvGenTLCXPDevice 、MvGenTLXoFDevice 等，详情参见DeviceTLayerType。

注意

设备列表的内存是在SDK内部分配的，调用该接口时SDK会进行设备列表内存的释放和申请，因此请避免多线程枚举操作。

/*枚举相机*/

List<IDeviceInfo> devInfoList = null; int ret = DeviceEnumerator.EnumDevices(DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLXoFDevice, out devInfoList); if(ret == MvError.MV_OK) {

/*处理相机信息*/

}

选项2：调用 DeviceEnumerator.EnumDevicesEx() 时，与调用普通枚举接口 DeviceEnumerator.EnumDevices() 相比，可传入厂商名称 manufacturerName 对枚举结果进行过滤，只返回与厂商名称匹配的设备列表 devInfoList 。

/*枚举相机*/

List<IDeviceInfo> devInfoList = null; int ret = DeviceEnumerator.EnumDevicesEx(DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLXoFDevice, "XXX", out devInfoList); if(ret == MvError.MV_OK) {

/*处理XXX厂商的相机*/

}

选项3：调用 DeviceEnumerator.EnumDevicesEx2() 时，与调用普通枚举接口 DeviceEnumerator.EnumDevices() 相比，可以：

传入 manufacturerName 过滤厂商名称，只返回与厂商名称匹配的设备列表 devInfoList 。若 manufacturerName 为 null ，返回所有厂商的设备列表。

对返回的设备列表进行排序。支持多种排序方式，如根据序列号排序、根据相机IP地址排序等。

严格按照枚举类型 TLayerType 枚举设备。例如设备接口类型为 MV_GIGE_DEVICE 时，仅枚举同网段内的 GigE 相机，不包含虚拟 GigE 相机和 GigE 采集卡所连接的相机，

/*枚举相机*/

List<IDeviceInfo> devInfoList = null;

/*只枚举网络上的'XXX'厂商的网口相机，且枚举结果按相机序列号排序*/

int ret = DeviceEnumerator.EnumDevicesEx2(DeviceTLayerType.MvGigEDevice, SortMethod.SortBySerialNumber, "XXX", out devInfoList); if(ret == MvError.MV_OK) {

/*处理XXX厂商的网口相机*/

}

步骤二：创建相机实例

可根据如下方式创建相机实例。

选项1：基于设备信息创建相机实例

调用 DeviceFactory.CreateDevice() 创建相机实例。调用时需传入设备信息 deviceInfo 。该接口根据传入的设备信息创建不同的相机实例。

注意

该接口需要通过 try…catch 捕获实例创建失败时SDK抛出的异常。

try {

/*创建相机实例*/

Idevice device = DeviceFactory.CreateDevice(deviceInfo);

/*打开相机*/

device.Open();

/*如果是网口相机*/

if (device is IGigEDevice) {

IGigEDevice gigEDevice = device as IGigEDevice;

/*配置网口相机的最佳包大小*/

int packetSize; gigEDevice.GetOptimalPacketSize(out packetSize); gigEDevice.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); }

else if (device is IUSBDevice) {

/*设置USB同步读写超时时间*/

IUSBDevice usbDevice = device as IUSBDevice; usbDevice.SetSyncTimeOut(1000); }

}

catch(Exception e) {

Console.WriteLine("Create device fail, {0}", e.Message); }

选项2：基于IP地址创建相机实例

调用 DeviceFactory.CreateDeviceByIp() 创建相机实例，调用时需传入设备IP地址 deviceIp 和网口IP地址 netExportIp 。

注意

该接口仅网口相机支持。

该接口需要通过 try…catch 捕获实例创建失败时SDK抛出的异常。

/*创建相机实例*/

try {

Idevice device = DeviceFactory.CreateDeviceByIp(deviceIp, netExportIP); }

catch(Exception e) {

Console.WriteLine("Create device fail, {0}", e.Message); }

//TODO:打开相机、配置相机参数等操作

步骤三：打开相机

“打开相机”指建立相机实例与物理相机的连接，使相机实例获得物理相机的访问权限，实现与物理相机通信。

选项1：调用 IDevice.Open() [1/2] 打开相机。该方式默认相机实例独占物理相机的访问权限。

/*打开相机*/

int ret = device.Open(); if(ret != MvError.MV_OK) {

Console.WriteLine("Open device fail: {0}", ret); }

else {

Console.WriteLine("Open device success!"); //TODO：配置相机参数等操作

}

选项2：调用 IDevice.Open() [2/2] 打开相机。调用时需传入访问权限 AccessMode 和切换访问权限时的密钥 switchoverKey ，以指定访问权限打开设备。

注意

该接口仅 GigE 设备支持。

/*打开相机*/

int ret = device.Open(Accessmode, switchoverKey); if(ret != MvError.MV_OK) {

Console.WriteLine("Open device fail: {0}", ret); }

else {

Console.WriteLine("Open device success!"); //TODO：配置相机参数等操作

}

（可选）步骤四：按需实现图像采集等功能

打开相机后：

可调用SDK接口获取相机事件。详情参见获取事件。

可调用SDK接口实现相机参数配置功能。详情参见配置设备参数。

可调用SDK接口实现图像采集相关功能，详情参见采集图像。

实现图像采集之后，还可进一步实现图像处理，详情参见处理图像。

步骤五：关闭相机

若相机实例不再需要与物理相机通信，调用 IDevice.Close() 关闭相机。

/*关闭相机*/

int ret = device.Close(); if(ret != MvError.MV_OK) {

Console.WriteLine("Close device fail: {0}", ret); }

else {

Console.WriteLine("Close device success!"); }

步骤六：销毁相机实例

调用 Dispose()，销毁相机实例，释放相机实例所占用的非托管资源。

注意

调用该接口后，原先的相机实例将失效，不能再用于其他接口的调用。

/*销毁相机实例*/

device.Dispose(); device = null;

步骤七：销毁SDK资源

调用 SDKSystem.Finalize()，销毁SDK资源。

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

控制采集卡

本节介绍如何调用SDK接口，在您的程序上实现采集卡控制功能。

前提条件

已完成SDK初始化。详情参见初始化。

步骤一：枚举采集卡

通过调用 InterfaceEnumerator.EnumInterfaces ，输入采集卡接口类型TLayerType，获取对应类型采集卡列表。

/*枚举采集卡*/

List<IInterfaceInfo> ifInfoList = null; int ret = InterfaceEnumerator.EnumInterfaces(InterfaceTLayerType.MvGigEInterface | InterfaceTLayerType.MvCXPInterface | InterfaceTLayerType.MvXoFInterface, out ifInfoList); if(ret != MvError.MV_OK) {

Console.WriteLine("Enum interface fail: {0}", ret); }

else {

Console.WriteLine("Enum interface success!"); //TODO: 处理采集卡信息

}

步骤二：创建采集卡实例

通过如下两种方式创建采集卡实例。 选项1：调用 InterfaceFactory.CreateInterface() [1/2]，输入采集卡信息 interfaceInfo ，获取采集卡实例。

注意

调用该接口后，需通过try…catch捕获采集卡实例创建失败时抛出的异常。

/*创建采集卡实例*/

try {

IInterface interface = InterfaceFactory.CreateInterface(interfaceInfo); }

catch(Exception e) {

Console.WriteLine("Create interface fail: {0}",e.Message); }

//TODO: 打开采集卡、配置采集卡等操作

选项2：调用 InterfaceFactory.CreateInterface() [2/2]，输入采集卡ID interfaceID ，获取采集卡实例。

注意

调用该接口后，需通过try…catch捕获采集卡实例创建失败时抛出的异常。

/*创建采集卡实例*/

try {

IInterface interface = InterfaceFactory.CreateInterface(interfaceID); }

catch(Exception e) {

Console.WriteLine("Create interface fail: {0}",e.Message); }

//TODO:打开采集卡、配置采集卡等操作

步骤三：打开采集卡

“打开采集卡”指建立采集卡实例与物理采集卡的连接，使采集卡实例获得物理采集卡的访问权限，实现与物理采集卡通信。

调用 IInterface.Open() ，打开采集卡。返回值为 MvError.MV_OK 表示打开成功，否则打开失败。

/*打开采集卡*/

int ret = interface.Open(); if(ret != MvError.MV_OK) {

Console.WriteLine(“Open interface fail: {0}”, ret); }

else {

Console.WriteLine(“Open interface success!”); //TODO：配置采集卡等操作

}

（可选）步骤四：按需实现事件采集与参数配置

打开采集卡后：

可调用SDK接口获取采集卡事件。详情参见获取事件。

可调用SDK接口实现采集卡参数配置功能。详情参见配置设备参数。

步骤五：关闭采集卡

若采集卡实例不再需要与物理采集卡通信，可调用 IInterface.Close() 关闭采集卡。

/*关闭采集卡*/

int ret = interface.Close(); if(ret != MvError.MV_OK) {

Console.WriteLine(“Close interface fail: {0}”, ret); }

else {

Console.WriteLine(“Close interface success!”); }

步骤六：销毁采集卡实例

当不使用该采集卡时，可以调用 Dispose() 接口，销毁采集卡实例，释放资源。

注意

调用该接口后，原先的采集卡实例将失效，不能再用于其他接口的调用。

/*销毁采集卡实例*/

interface.Dispose(); interface = null;

步骤七：销毁SDK资源

调用 SDKSystem.Finalize()，销毁SDK资源。

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

配置设备参数

SDK通过GenICam标准协议实现对设备参数的读取和设置，并提供了一套相机和采集卡均通用的参数配置接口（ IParameters ），可获取和配置包括整型、枚举型、浮点型、布尔型、字符串型和命令型总共6种类型的参数节点。

查询节点名称和类型

调用“获取/配置节点的接口”时，需传入节点名称和节点类型。因此调用这些接口前，需先通过客户端查询节点的名称和类型。

通过客户端连接设备。

在客户端属性树上选中某个属性的参数，即可在属性数下方查看该参数的节点信息。

下图以Width参数为例。

注解

更多操作详情请参见客户端用户手册。

获取/配置节点

调用 IParameters.GetIntValue() 获取整型节点。

调用 IParameters.SetIntValue() 配置整型节点。

string key = "Width"; IIntValue intValue;

// ch: 获取整型节点 | en: Get Int value device.Parameters.GetIntValue(key, out intValue);

// ch: 设置整型节点 | en: Set Int value device.Parameters.SetIntValue(key, intValue.CurValue);

调用 IParameters.GetEnumValue() 获取枚举型节点。

调用 IParameters.SetEnumValue()设置枚举型节点。

string key = "PixelFormat"; IEnumValue enumValue;

// ch: 获取枚举型节点属性 | en: Get Enum value device.Parameters.GetEnumValue(key, out enumValue);

// ch: 设置枚举型节点属性 | en: Set Enum value device.Parameters.SetEnumValue(key, enumValue.CurEnumEntry.Value);

// ch: 通过字符串设置枚举型节点属性 | en: Set Enum value By string device.Parameters.SetEnumValueByString(key, enumValue.CurEnumEntry.Symbolic);

调用 IParameters.GetBoolValue() 获取布尔型节点。

调用 IParameters.SetBoolValue()设置布尔型节点。

string key = "GammaEnable"; bool boolValue;

device.Parameters.GetBoolValue(key, out boolValue);

// ch: 设置布尔型节点属性 | en: Set Bool value device.Parameters.SetBoolValue(key, boolValue);

调用 IParameters.GetFloatValue() 获取浮点型节点。

调用 IParameters.SetFloatValue()设置浮点型节点。

string key = "ExposureTime"; IFloatValue floatValue;

device.Parameters.GetFloatValue(key, out floatValue);

// ch: 设置浮点型节点属性 | en: Set Float value device.Parameters.SetFloatValue(key, floatValue.CurValue);

调用 IParameters.GetStringValue() 获取字符串型节点。

调用 IParameters.SetStringValue()设置字符串型节点。

string key = "DeviceUserID"; IStringValue stringValue;

device.Parameters.GetStringValue(key, out stringValue);

// ch: 设置字符串型节点属性 | en: Set String value device.Parameters.SetStringValue(key, stringValue.CurValue);

调用 IParameters.SetCommandValue() 设置命令型节点。

string key = "UserSetLoad";

device.Parameters.SetCommandValue(key);

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

采集图像

可通过 IDevice 的 IStreamGrabber 属性实现图像采集。 IStreamGrabber 提供开始采集、停止采集、获取图像信息等方法，也可以通过该属性配置图像采集相关的参数，如设置图像缓存节点个数，获取有效图像个数、设置取图策略等。

SDK支持如下两种图像采集方式，可按需选用。

回调取图：通过回调函数采集图像。

轮询取图：通过轮询调用取图接口采集图像

注意

该两种采集图像的方式无法同时使用，只能使用其中一种。

回调取图

SDK提供“图像到来事件” FrameGrabedEvent ，您可在该事件上绑定自定义的事件处理函数。当SDK接收到图像时，SDK会自动触发该事件上绑定的事件处理函数。

该方式的基本步骤如下：

参考 IStreamGrabber.FrameGrabedEvent ，定义自己的事件处理函数。

调用 IStreamGrabber.SetImageNodeNum() ，设置合适的缓存节点个数。

注解

具体申请多少块图像缓存需要根据实际情况决定，主要影响因素有：相机帧率、图像分辨率和电脑配置（主板性能、内存大小）等。

调用 IStreamGrabber.StartGrabbing() ，开始采集图像。

等待事件触发，在自定义的事件处理函数中处理图像。

如下示例代码演示了该方式取图的过程 ：

自定义事件处理方法

void FrameGrabedEventHandler(object sender, FrameGrabbedEventArgs e) {

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , FrameNum[{2}]", e.FrameOut.Image.Width, e.FrameOut.Image.Height, e.FrameOut.FrameNum); }

绑定事件，并开始采集

//ch: 设置合适的缓存节点数量 | en: Setting the appropriate number of image nodes device.StreamGrabber.SetImageNodeNum(5);

// ch:注册回调函数 | en:Register image callback device.StreamGrabber.FrameGrabedEvent += FrameGrabedEventHandler;

// ch:开启抓图 || en: start grab image ret = device.StreamGrabber.StartGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); return; }

Console.WriteLine("Press enter to exit"); Console.ReadLine();

轮询取图

您可自行创建线程，在线程中循环调用 IStreamGrabber.GetImageBuffer() 获取图像信息。

注解

由于图像缓存是SDK内部申请的，因此完成对图像的处理后，需要调用 IStreamGrabber.FreeImageBuffer() 释放图像信息。

自定义线程函数，接收并处理图像

void FrameGrabThread(object obj) {

IStreamGrabber streamGrabber = (IStreamGrabber)obj;

while(!_grabThreadExit) {

IFrameOut frame;

//ch：获取一帧图像 | en: Get one frame int ret = streamGrabber.GetImageBuffer(1000, out frame); if (ret != MvError.MV_OK) {

Console.WriteLine("Get Image failed:{0:x8}", ret); continue; }

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , FrameNum[{2}]", frame.Image.Width, frame.Image.Height, frame.FrameNum);

//Do some thing

//ch: 释放图像缓存 | en: Release the image buffer streamGrabber.FreeImageBuffer(frame); }

}

开始采集

// ch:开启抓图 | en: start grab image ret = device.StreamGrabber.StartGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); return; }

// ch:开启抓图线程 | en: Start the grabbing thread Thread GrabThread = new Thread(FrameGrabThread); GrabThread.Start(device.StreamGrabber);

Console.WriteLine("Press enter to exit"); Console.ReadLine();

图像拷贝

由于获取到的图像缓存都由SDK内部分配，处理完图像需要及时释放。若需对图像进行一些耗时操作，可复制一帧图像并保存至您的程序的数据队列中。

您可调用 IFrame.Clone() 或 IFrame.Image.Clone() 对图像进行深拷贝。

// ch: 克隆图像数据（深拷贝） | en :Clone frame data using deep copy IFrameOut frameCopy = (IFrameOut)e.FrameOut.Clone();

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

处理图像

SDK提供了丰富的图像处理接口，可用于实现图像显示、图像保存、像素格式转换、图像重组和录像等功能。采集到图像（ IFrameOut.Image ）后，可以直接其传入到这些接口中进行图像处理。

显示图像

IDevice 提供 IImageRender 属性，用于显示图像。

采集到图像后，可调用 IImageRender.DisplayOneFrame() 将图像显示在指定窗口。

// ch:图像信息 | en: Declare image info IFrameOut frameOut;

// ch:获取图像信息 | en: Get image info nRet = device.StreamGrabber.GetImageBuffer(1000, out frameOut); if (MvError.MV_OK == nRet) {

// ch:显示图像 | en: display image device.ImageRender.DisplayOneFrame(pictureBox1.Handle, frameOut.Image);

// ch:释放图像 | en: free image device.StreamGrabber.FreeImageBuffer(frameOut); }

保存图像

IDevice 提供 IImageSaver 属性，用于保存图像。

采集到图像后，可调用 IImageSaver.SaveImageToFile() 方法在将图像保存为本地文件，也可调用 IImageSaver.SaveImageToBuffer() 将文件保存至Byte数组。

如下示例代码演示了如何将图像保存成本地BMP文件。

// ch:要保存的图像文件路径 | en: File path of the image string imagePath = "Image.bmp";

// ch:图像信息 | en: Declare image info IFrameOut frameOut;

// ch:获取图像信息 | en: Get image info nRet = device.ImageSaver.GetImageBuffer(1000, out frameOut); if (MvError.MV_OK == nRet) {

// ch:保存的文件格式信息 | en: Image format info for save ImageFormatInfo imageFormatInfo = new ImageFormatInfo(); imageFormatInfo.FormatType = ImageFormatType.Bmp;

// ch:保存图像 | en: display image device.ImageSaver.SaveImageToFile(imagePath, frameOut.Image, imageFormatInfo, CFAMethod.Optimal);

// ch:释放图像 | en: free image device.StreamGrabber.FreeImageBuffer(frameOut); }

像素格式转换

IDevice 提供 IPixelTypeConverter 属性，用于对图像进行格式转换。

可调用 IPixelTypeConverter.ConvertPixelType() 将图像转换成其他像素格式。

例如，可将Bayer格式转换成RGB/BGR格式。在对Bayer格式图像进行插值时，还支持一些算法功能，如平滑滤波、Gamma矫正和CCM矫正等，具体可参考 IPixelTypeConverter 的其他方法。

如下示例代码演示了如何将图像转换成RGB格式。

IImage outImage;

// ch:目的像素格式 | en:Dest Pixel type MvGvspPixelType dstPixelType = MvGvspPixelType.PixelType_Gvsp_RGB8_Packed;

// ch:像素格式转换 | en:Pixel type convert result = device.PixelTypeConverter.ConvertPixelType(inputImage, out outImage, dstPixelType); if (result != MvError.MV_OK) {

Console.WriteLine("Image Convert failed:{0:x8}", result); return; }

Console.WriteLine("Image Convert success!");

// ch: 图像使用完及时释放，防止内存快速上涨导致频繁GC |en：Release image promptly to prevent rapid memory increase leading to frequent GC.

outImage.Dispose();

解码图像

IDevice 提供 IImageDecoder 属性，用于对图像进行解码。目前主要用来将无损压缩后的图像解码成裸数据。

可调用 IImageDecoder.HBDecode() 将相机发送的“压缩后”图像数据解码为完整的裸数据。

注意

解码前需要判断输入图像是否完整，如果图像丢失了部分数据包，该接口会返回失败。

IFrameOut frameOut;

// ch:获取一帧图像 | en:Get one image result = device.StreamGrabber.GetImageBuffer(1000, out frameOut); if (MvError.MV_OK == result && frameOut.LostPacket == 0) {

Console.WriteLine("Get Image Buffer: Width[{0}] , Height[{1}] , FrameNum[{2}]"

, frameOut.Image.Width, frameOut.Image.Height, frameOut.FrameNum);

IFrameOut frameDecode;

// ch:解码图像 | en:Image Decode Process device.ImageDecoder.HBDecode(frameOut, out frameDecode);

// ch:处理解码后的图像 | en:Process raw image

// ch: 图像使用完及时释放，防止内存快速上涨导致频繁GC | en：Release image promptly to prevent rapid memory increase leading to frequent GC.

frameDecode.Dispose(); }

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

获取事件

SDK的事件分为正常通知事件和异常告警事件两种。

正常通知事件指采集卡/相机处于正常状态下发出的的事件。

异常告警事件是SDK产生的异常，可直接从SDK中获取。此类事件为采集卡/相机或者SDK运行中的异常（例如相机掉线等事件），用于提醒用户及时排查。

正常通知事件

可依次通过订阅、启用、获取、关闭和取消订阅完成正常通知事件的处理流程。

注意

若要获取正常通知事件，需先通过客户端配置采集卡/相机的 EventControl 属性。配置操作详情参见客户端用户手册。

订阅：调用 IEventGrabber.SubscribeEvent() ，调用时输入事件名称 eventName ，订阅该事件。

如下两段示例代码分别演示了如何订阅采集卡帧开始事件和相机曝光结束事件。

/*订阅采集卡帧开始事件*/

interface.EventGrabber.DeviceEvent += DeviceEventGrabedHandler; interface.EventGrabber.SubscribeEvent("ReceiveImageFrameStart0");

/*订阅相机曝光结束事件*/

device.EventGrabber.DeviceEvent += DeviceEventGrabedHandler; device.EventGrabber.SubscribeEvent("ExposureEnd");

启用：调用 IDevice.EventNotificationOn() 和 IInterface.EventNotificationOn() ，调用时传入事件名称（eventName），可以启用对应的事件。

注解

采集卡事件可以通过采集卡事件配置工具进行配置。

如下两段示例代码分别演示了启用采集卡帧开始事件和相机曝光结束事件的流程。

注解

您可以从MVS客户端获取对应的事件名称。

/*启用采集卡的Channel0的帧开始事件*/

interface.EventNotificationOn("ReceiveImageFrameStart0");

/*启用相机的曝光结束事件*/

device.EventNotificationOn("ExposureEnd");

获取：当采集卡/相机生成一个事件时，SDK会触发对应的事件回调函数，将该事件信息推送给用户。一般情况下，推送给用户的事件信息中包含事件名称、事件ID和时间戳等关键信息。其他信息，如帧号和事件数据等，则不一定包含。不同事件所包含的信息会存在差异。

注意

不建议在事件回调函数中进行耗时操作。如进行耗时操作，后续事件信息的推送将被阻塞。

/*采集卡/设备事件回调函数*/

void DeviceEventGrabedHandler(object sender, DeviceEventArgs e) {

Console.WriteLine("EventName[{0}], EventID[{1}]", e.EventInfo.EventName, e.EventInfo.EventID); if (e.EventInfo.EventData != null) {

//TODO：数据拷贝等操作

}

}

关闭：当需要关闭事件时，调用 IInterface.EventNotificationOn() 和 IDevice.EventNotificationOn() ，调用时传入事件名称（eventName），可以关闭对应的事件。

/*关闭采集卡的Channel0的帧开始事件*/

interface.EventNotificationOff("ReceiveImageFrameStart0");

/*关闭相机的曝光结束事件*/

device.EventNotificationOff("ExposureEnd");

取消订阅：调用 IEventGrabber.UnSubscribeEvent() 。调用时需输入事件名称 eventName 。调用成功则取消订阅该事件。

/*取消订阅采集卡帧开始事件*/

interface.EventGrabber.UnSubscribeEvent("ReceiveImageFrameStart0");

/*取消订阅相机曝光结束事件*/

device.EventGrabber.UnSubscribeEvent("ExposureEnd");

异常告警事件

异常告警事件可直接从SDK中获取。该类型事件的处理流程包括注册、获取和注销。

注册：通过向指定实例的异常事件 DeviceExceptionEvent 添加事件委托来完成该事件的注册。

/*注册异常事件*/

device.DeviceExceptionEvent += DeviceExceptionHandler;

获取：当SDK出现异常时，会触发异常事件回调函数，将该异常事件的类型推送给用户。

注意

不建议在异常事件回调函数中进行耗时操作。如进行耗时操作，后续事件信息的推送将被阻塞。

/*异常事件回调函数*/

void DeviceExceptionHandler(object sender, DeviceExceptionArgs e) {

Console.WriteLine("Exception[{0}]", e.MsgType); //TODO: 处理异常事件

}

注销：调用采集卡/相机实例的设备异常事件 DeviceExceptionEvent ，移除事件委托。

/*注销异常事件*/

device.DeviceExceptionEvent -= DeviceExceptionHandler;

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

API参考

这里列出了所有模块:

SDK初始化 SDK初始化和反初始化等接口

相机 相机控制相关接口和数据结构，用于实现打开相机和关闭相机等相机的基本控制功能

采集卡 采集卡控制相关接口和数据结构，用于实现打开采集卡和关闭采集卡等采集卡基本控制功能

参数设置 设备参数配置相关接口和数据结构，用于实现相机和采集卡的参数配置功能

图像采集 图像采集相关接口和数据结构，用于实现图像采集功能

图像渲染 图像渲染相关接口和数据结构，用于实现将获取到的图像显示在您的程序上

图像处理 图像处理相关接口和数据结构，用于实现图像解码、图像旋转、对比度调整等图像处理功能

事件功能 设备事件相关数据结构和事件订阅相关接口，用于实现设备事件接收功能

GenTL GenTL标准相关数据结构和接口，用于实现通过GenTL接口枚举第三方设备

状态码及异常 接口调用的状态码及SDK抛出异常信息

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

类

SDK初始化

SDK初始化和反初始化等接口 更多...

类

class SDKSystem

SDk全局信息及操作接口 更多...

详细描述

SDK初始化和反初始化等接口

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

静态 Public 成员函数 | 所有成员列表

SDKSystem类 参考 SDK初始化

SDk全局信息及操作接口 更多...

静态 Public 成员函数

static String GetSDKVersion ()

获取SDK版本信息 更多...

static Int32 Initialize ()

初始化SDK 更多...

static Int32 Finalize ()

反初始化SDK，释放资源 更多...

详细描述

SDk全局信息及操作接口

成员函数说明

◆ GetSDKVersion()

static String SDKSystem.GetSDKVersion ( )

static

获取SDK版本信息

返回

SDK版本号，格式x.y.z.a

◆ Initialize()

static Int32 SDKSystem.Initialize ( )

static

初始化SDK

返回

成功，返回MV_OK；失败，返回错误码

◆ Finalize()

static Int32 SDKSystem.Finalize ( )

static

反初始化SDK，释放资源

返回

成功，返回MV_OK；失败，返回错误码

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

类 | 枚举

相机

相机控制相关接口和数据结构，用于实现打开相机和关闭相机等相机的基本控制功能 更多...

类

struct NetTransInfo

GigE设备网络传输的相关信息 更多...

struct USBTransInfo

USB传输信息 更多...

class DeviceExceptionArgs

设备异常消息 更多...

interface IDevice

提供设备通用的属性和接口 更多...

interface IGigEDevice

GigE设备专用接口 更多...

interface IUSBDevice

USB设备专用接口 更多...

interface ICamlDevice

Camera Link串口设备专用接口 更多...

struct ActionCmdInfo

动作命令信息 更多...

struct ActionCmdResult

动作命令返回信息 更多...

class DeviceEnumerator

设备枚举类，支持枚举GigE Vision、USB3 Vision相机，及采集卡上的相机（GigE Vision、CameraLink、CoaXPress、XoFlink） 更多...

class DeviceFactory

相机工厂类，用于创建相机实例 更多...

interface IDeviceInfo

设备基本信息 更多...

interface IGigEDeviceInfo

GigE相机信息 更多...

interface IUSBDeviceInfo

USB相机信息 更多...

interface ICamlDeviceInfo

Camera Link串口设备信息 更多...

interface ICXPDeviceInfo

CoaXPress设备信息 更多...

interface ICameraLinkDeviceInfo

Camera Link设备信息 更多...

interface IXoFDeviceInfo

XoFLink设备信息 更多...

枚举

enum DeviceAccessMode {

DeviceAccessMode.AccessExclusive = 1,

DeviceAccessMode.AccessExclusiveWithSwitch = 2,

DeviceAccessMode.AccessControl = 3,

DeviceAccessMode.AccessControlWithSwitch = 4,

DeviceAccessMode.AccessControlSwitchEnable = 5,

DeviceAccessMode.AccessControlSwitchEnableWithKey = 6,

DeviceAccessMode.AccessMonitor = 7

}

当前进程访问设备的模式，仅GigE设备支持 更多...

enum IpConfigType {

IpConfigType.Static = 0x05000000,

IpConfigType.DHCP = 0x06000000,

IpConfigType.LLA = 0x04000000

}

IP配置类型 更多...

enum NetTransMode {

NetTransMode.Driver = 0x00000001,

NetTransMode.Socket = 0x00000002

}

GigE设备传输模式 更多...

enum TransmissionType {

TransmissionType.Unicast = 0,

TransmissionType.Multicast = 1,

TransmissionType.LimitedBroadcast = 2,

TransmissionType.SubnetBroadcast = 3,

TransmissionType.CameraDefined = 4,

TransmissionType.UnicastDefinedPort = 5,

TransmissionType.UnicastWithoutRecv = 0x00010000,

TransmissionType.MulticastWithoutRecv = 0x00010001

}

GigE传输类型 更多...

enum DeviceExceptionType { DeviceExceptionType.DisConnect = 0x00008001 }

设备异常类型 更多...

enum CameraLinkBaudrate {

CameraLinkBaudrate.B9600 = 0x00000001,

CameraLinkBaudrate.B19200 = 0x00000002,

CameraLinkBaudrate.B38400 = 0x00000004,

CameraLinkBaudrate.B57600 = 0x00000008,

CameraLinkBaudrate.B115200 = 0x00000010,

CameraLinkBaudrate.B230400 = 0x00000020,

CameraLinkBaudrate.B460800 = 0x00000040,

CameraLinkBaudrate.B921600 = 0x00000080,

CameraLinkBaudrate.AutoMax = 0x40000000

}

Camera Link波特率 更多...

enum SortMethod {

SortMethod.SortBySerialNumber = 0,

SortMethod.SortByUserDefinedName = 1,

SortMethod.SortByAscIpAddress = 2,

SortMethod.SortByDescIpAddress = 3

}

排序方式 更多...

enum DeviceTLayerType {

DeviceTLayerType.MvGigEDevice = 0x00000001,

DeviceTLayerType.MvUsbDevice = 0x00000004,

DeviceTLayerType.MvCameraLinkDevice = 0x00000008,

DeviceTLayerType.MvVirGigEDevice = 0x00000010,

DeviceTLayerType.MvVirUsbDevice = 0x00000020,

DeviceTLayerType.MvGenTLGigEDevice = 0x00000040,

DeviceTLayerType.MvGenTLCameraLinkDevice = 0x00000080,

DeviceTLayerType.MvGenTLCXPDevice = 0x00000100,

DeviceTLayerType.MvGenTLXoFDevice = 0x00000200

}

设备接口类型 更多...

详细描述

相机控制相关接口和数据结构，用于实现打开相机和关闭相机等相机的基本控制功能

枚举类型说明

◆ DeviceAccessMode

enum DeviceAccessMode

strong

当前进程访问设备的模式，仅GigE设备支持

注意

目前设备暂不支持MV_ACCESS_ExclusiveWithSwitch、MV_ACCESS_ControlWithSwitch、MV_ACCESS_ControlSwitchEnable、MV_ACCESS_ControlSwitchEnableWithKey这四种模式。

枚举值

AccessExclusive “独占”模式。“独占”具体指当前进程独占设备的访问权限。该模式下，其他进程只允许读CCP寄存器

AccessExclusiveWithSwitch 该模式下，当前进程可以从“设置为5模式（即 AccessControlSwitchEnable ）的其他进程”抢占设备访问权限。抢占后，当前进程以“独占”模式打开设备

AccessControl “访问控制”模式。当前进程以该模式访问设备后，其他进程允许读所有寄存器

AccessControlWithSwitch 该模式下，当前进程可以从“设置为5模式（即 AccessControlSwitchEnable ）的其他进程”抢占设备访问权限。抢占后，当前进程以“访问控制”模式打开设备

AccessControlSwitchEnable 该模式下，当前进程的设备访问权限可被其他进程抢占

AccessControlSwitchEnableWithKey 该模式下，当前进程可以从“设置为5模式（即 AccessControlSwitchEnable ）的其他进程”抢占设备访问权限。抢占后，当前进程的设备访问权限可被其他进程继续抢占

AccessMonitor 该模式下，当前进程仅在其他进程以3模式（即AccessControl）占用设备后，才可以monitor模式访问设备。如果设备已被其他进程以“独占”模式占用，那么该模式下当前设备也无法访问设备

◆ IpConfigType

enum IpConfigType

strong

IP配置类型

枚举值

Static 静态IP

DHCP DHCP自动获取IP

LLA LLA(Link-local address)，链路本地地址

◆ NetTransMode

enum NetTransMode

strong

GigE设备传输模式

枚举值

Driver 驱动模式

Socket Socket模式

◆ TransmissionType

enum TransmissionType

strong

GigE传输类型

注意

目前设备暂不支持LIMITEDBROADCAST、SUBNETBROADCAST、CAMERADEFINED这三种模式。

枚举值

Unicast 单播

Multicast 组播

LimitedBroadcast 局域网内广播

SubnetBroadcast 子网内广播

CameraDefined 从相机获取

UnicastDefinedPort 用户自定义应用端接收图像数据Port号

UnicastWithoutRecv 设置了单播，但本实例不接收图像数据

MulticastWithoutRecv 组播模式，但本实例不接收图像数据

◆ DeviceExceptionType

enum DeviceExceptionType

strong

设备异常类型

枚举值

DisConnect 设备断开连接

◆ CameraLinkBaudrate

enum CameraLinkBaudrate

strong

Camera Link波特率

枚举值

B9600 9600

B19200 19200

B38400 38400

B57600 57600

B115200 115200

B230400 230400

B460800 460800

B921600 921600

AutoMax 最大值

◆ SortMethod

enum SortMethod

strong

排序方式

枚举值

SortBySerialNumber 按序列号排序

SortByUserDefinedName 按用户自定义名字排序

SortByAscIpAddress 按当前IP地址排序（升序）

SortByDescIpAddress 按当前IP地址排序（降序）

◆ DeviceTLayerType

enum DeviceTLayerType

strong

设备接口类型

枚举值

MvGigEDevice GigE Vision 设备

MvUsbDevice USB3 Vision 设备

MvCameraLinkDevice Camera Link 设备（串口）

MvVirGigEDevice 虚拟 GigE Vision 设备

MvVirUsbDevice Virtual USB3 Vision 设备

MvGenTLGigEDevice 网口采集卡下GigE Vision设备

MvGenTLCameraLinkDevice Camera Link 设备

MvGenTLCXPDevice CoaXPress设备

MvGenTLXoFDevice XoFLink设备

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 属性 | 所有成员列表

NetTransInfo结构体 参考 相机

GigE设备网络传输的相关信息 更多...

Public 属性

Int64 ReceiveDataSize

已接收数据大小，具体指“从调用 IStreamGrabber.StartGrabbing() 开始，一直到调用 IStreamGrabber.StopGrabbing() 结束”这个过程中接收到的数据量。 更多...

Int64 LostPacketCount

丢失的包数量 更多...

Int32 LostFrameCount

丢帧数量 更多...

UInt32 NetRecvFrameCount

已接收的帧数 更多...

UInt64 RequestResendPacketCount

请求重发包数 更多...

UInt64 ResendPacketCount

重发包数 更多...

详细描述

GigE设备网络传输的相关信息

类成员变量说明

◆ ReceiveDataSize

Int64 NetTransInfo.ReceiveDataSize

已接收数据大小，具体指“从调用 IStreamGrabber.StartGrabbing() 开始，一直到调用 IStreamGrabber.StopGrabbing() 结束”这个过程中接收到的数据量。

◆ LostPacketCount

Int64 NetTransInfo.LostPacketCount

丢失的包数量

◆ LostFrameCount

Int32 NetTransInfo.LostFrameCount

丢帧数量

◆ NetRecvFrameCount

UInt32 NetTransInfo.NetRecvFrameCount

已接收的帧数

◆ RequestResendPacketCount

UInt64 NetTransInfo.RequestResendPacketCount

请求重发包数

◆ ResendPacketCount

UInt64 NetTransInfo.ResendPacketCount

重发包数

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 属性 | 所有成员列表

USBTransInfo结构体 参考 相机

USB传输信息 更多...

Public 属性

Int64 ReceiveDataSize

已接收数据大小，具体指“从调用 IDevice.Open() 开始，一直到调用 IDevice.Close() 结束”这个过程中接受到的数据大小 更多...

UInt32 ReceivedFrameCount

已收到的帧数 更多...

UInt32 ErrorFrameCount

错误帧数 更多...

详细描述

USB传输信息

类成员变量说明

◆ ReceiveDataSize

Int64 USBTransInfo.ReceiveDataSize

已接收数据大小，具体指“从调用 IDevice.Open() 开始，一直到调用 IDevice.Close() 结束”这个过程中接受到的数据大小

◆ ReceivedFrameCount

UInt32 USBTransInfo.ReceivedFrameCount

已收到的帧数

◆ ErrorFrameCount

UInt32 USBTransInfo.ErrorFrameCount

错误帧数

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

DeviceExceptionArgs类 参考 相机

设备异常消息 更多...

继承自 EventArgs .

属性

DeviceExceptionType MsgType [get, set]

消息类型 更多...

详细描述

设备异常消息

属性说明

◆ MsgType

DeviceExceptionType DeviceExceptionArgs.MsgType

getset

消息类型

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | 属性 | 事件 | 所有成员列表

IDevice接口 参考 相机

提供设备通用的属性和接口 更多...

继承自 IDisposable .

被 ICamlDevice, IGigEDevice , 以及 IUSBDevice 继承.

Public 成员函数

Int32 Open ()

打开设备，默认以“独占”模式访问设备。设备访问模式相关详情，请参见DeviceAccessMode 更多...

Int32 Open (DeviceAccessMode AccessMode, UInt32 switchoverKey)

以指定的设备访问模式打开设备，只支持GigE设备。设备访问模式相关详情，请参见DeviceAccessMode 更多...

Int32 Close ()

关闭设备 更多...

Int32 LocalUpgrade (String filePath)

设备本地升级 更多...

Int32 GetUpgradeProcess (out UInt32 process)

获取升级进度 更多...

Int32 EventNotificationOn (String eventName)

开启设备指定事件 更多...

Int32 EventNotificationOff (String eventName)

关闭设备指定事件 更多...

属性

bool IsConnected [get]

判断设备是否处于连接状态 更多...

IStreamGrabber StreamGrabber [get]

获取设备对应的图像采集对象 更多...

IEventGrabber EventGrabber [get]

获取设备对应的事件采集对象 更多...

IDeviceInfo DeviceInfo [get]

获取设备信息 更多...

IParameters Parameters [get]

获取设备对应的参数配置对象 更多...

IPixelTypeConverter PixelTypeConverter [get]

获取格式转换对象 更多...

IImageProcess ImageProcess [get]

获取用于图像处理的对象 更多...

IImageSaver ImageSaver [get]

获取用于图像保存的对象 更多...

IImageDecoder ImageDecoder [get]

获取用于解码图像的的对象 更多...

IVideoRecorder VideoRecorder [get]

获取录像对象 更多...

IImageRender ImageRender [get]

获取图像和图形渲染对象 更多...

事件

EventHandler< DeviceExceptionArgs > DeviceExceptionEvent

设备异常事件 更多...

详细描述

提供设备通用的属性和接口

成员函数说明

◆ Open() [1/2]

Int32 IDevice.Open ( )

打开设备，默认以“独占”模式访问设备。设备访问模式相关详情，请参见DeviceAccessMode

返回

成功，返回MV_OK；失败，返回错误码

◆ Open() [2/2]

Int32 IDevice.Open ( DeviceAccessMode AccessMode,

UInt32 switchoverKey

)

以指定的设备访问模式打开设备，只支持GigE设备。设备访问模式相关详情，请参见DeviceAccessMode

参数

AccessMode 设备访问模式，即当前进程访问设备的模式，不同模式下当前进程对设备的占用权限不同

switchoverKey 切换访问权限时的密钥

返回

成功，返回MV_OK；失败，返回错误码

注意

目前设备暂不支持MV_ACCESS_ExclusiveWithSwitch、MV_ACCESS_ControlWithSwitch、MV_ACCESS_ControlSwitchEnable、MV_ACCESS_ControlSwitchEnableWithKey这四种抢占模式。

◆ Close()

Int32 IDevice.Close ( )

关闭设备

返回

成功，返回MV_OK；失败，返回错误码

◆ LocalUpgrade()

Int32 IDevice.LocalUpgrade ( String filePath )

设备本地升级

参数

filePath 升级文件路径

返回

成功，返回MV_OK；失败，返回错误码

注解

通过该接口可以将升级固件文件发送给设备进行升级。该接口需要等待升级固件文件成功传给设备端之后再返回，响应时间可能较长。

◆ GetUpgradeProcess()

Int32 IDevice.GetUpgradeProcess ( out UInt32 process )

获取升级进度

参数

process 升级进度

返回

成功，返回MV_OK；失败，返回错误码

◆ EventNotificationOn()

Int32 IDevice.EventNotificationOn ( String eventName )

开启设备指定事件

参数

eventName 事件名称

返回

成功，返回MV_OK；失败，返回错误码

注解

您可从MVS客户端查询所需的事件名称。

◆ EventNotificationOff()

Int32 IDevice.EventNotificationOff ( String eventName )

关闭设备指定事件

参数

eventName 事件名称

返回

成功，返回MV_OK；失败，返回错误码

注解

您可从MVS客户端查询所需的事件名称。

属性说明

◆ IsConnected

bool IDevice.IsConnected

get

判断设备是否处于连接状态

◆ StreamGrabber

IStreamGrabber IDevice.StreamGrabber

get

获取设备对应的图像采集对象

◆ EventGrabber

IEventGrabber IDevice.EventGrabber

get

获取设备对应的事件采集对象

◆ DeviceInfo

IDeviceInfo IDevice.DeviceInfo

get

获取设备信息

◆ Parameters

IParameters IDevice.Parameters

get

获取设备对应的参数配置对象

◆ PixelTypeConverter

IPixelTypeConverter IDevice.PixelTypeConverter

get

获取格式转换对象

◆ ImageProcess

IImageProcess IDevice.ImageProcess

get

获取用于图像处理的对象

◆ ImageSaver

IImageSaver IDevice.ImageSaver

get

获取用于图像保存的对象

◆ ImageDecoder

IImageDecoder IDevice.ImageDecoder

get

获取用于解码图像的的对象

◆ VideoRecorder

IVideoRecorder IDevice.VideoRecorder

get

获取录像对象

◆ ImageRender

IImageRender IDevice.ImageRender

get

获取图像和图形渲染对象

事件说明

◆ DeviceExceptionEvent

EventHandler<DeviceExceptionArgs> IDevice.DeviceExceptionEvent

设备异常事件

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | 所有成员列表

IGigEDevice接口 参考 相机

GigE设备专用接口 更多...

继承自 IDevice .

Public 成员函数

Int32 GetOptimalPacketSize (out Int32 optimalPacketSize)

获取最佳包大小 更多...

Int32 ForceIp (UInt32 ip, UInt32 subnetMask, UInt32 defaultGateway)

强制设置设备网络参数（包括IP、子网掩码和默认网关） 更多...

Int32 SetIpConfig (IpConfigType type)

配置IP方式 更多...

Int32 SetNetTransMode (NetTransMode mode)

设置传输模式，默认为Driver模式 更多...

Int32 GetNetTransInfo (out NetTransInfo info)

获取网络传输信息 更多...

Int32 SetGvspTimeout (UInt32 timeoutInMS)

设置GVSP取流超时时间 更多...

Int32 GetGvspTimeout (out UInt32 timeoutInMS)

获取GVSP取流超时时间 更多...

Int32 SetGvcpTimeout (UInt32 timeoutInMS)

设置GVCP命令超时时间 更多...

Int32 GetGvcpTimeout (out UInt32 timeoutInMS)

获取GVCP命令超时时间 更多...

Int32 SetRetryGvcpTimes (UInt32 retryGvcpTimes)

设置重传GVCP命令次数 更多...

Int32 GetRetryGvcpTimes (out UInt32 retryGvcpTimes)

获取重传GVCP命令次数 更多...

Int32 SetResend (bool enable, UInt32 maxResendPercent, UInt32 resendTimeout)

设置是否打开重发包，及重发包参数 更多...

Int32 SetResendMaxRetryTimes (UInt32 retryTimes)

设置重传命令最大尝试次数 更多...

Int32 GetResendMaxRetryTimes (out UInt32 retryTimes)

获取重传命令最大尝试次数 更多...

Int32 SetResendTimeInterval (UInt32 timeInMS)

设置同一重传包多次请求之间的时间间隔 更多...

Int32 GetResendTimeInterval (out UInt32 timeInMS)

获取同一重传包多次请求之间的时间间隔 更多...

Int32 SetTransmissionType (TransmissionType type, UInt32 multicastIP, UInt32 multicastPort)

设置传输模式，可以为单播模式、组播模式等 更多...

Public 成员函数 继承自 IDevice

Int32 Open ()

打开设备，默认以“独占”模式访问设备。设备访问模式相关详情，请参见DeviceAccessMode 更多...

Int32 Open (DeviceAccessMode AccessMode, UInt32 switchoverKey)

以指定的设备访问模式打开设备，只支持GigE设备。设备访问模式相关详情，请参见DeviceAccessMode 更多...

Int32 Close ()

关闭设备 更多...

Int32 LocalUpgrade (String filePath)

设备本地升级 更多...

Int32 GetUpgradeProcess (out UInt32 process)

获取升级进度 更多...

Int32 EventNotificationOn (String eventName)

开启设备指定事件 更多...

Int32 EventNotificationOff (String eventName)

关闭设备指定事件 更多...

额外继承的成员函数

属性 继承自 IDevice

bool IsConnected [get]

判断设备是否处于连接状态 更多...

IStreamGrabber StreamGrabber [get]

获取设备对应的图像采集对象 更多...

IEventGrabber EventGrabber [get]

获取设备对应的事件采集对象 更多...

IDeviceInfo DeviceInfo [get]

获取设备信息 更多...

IParameters Parameters [get]

获取设备对应的参数配置对象 更多...

IPixelTypeConverter PixelTypeConverter [get]

获取格式转换对象 更多...

IImageProcess ImageProcess [get]

获取用于图像处理的对象 更多...

IImageSaver ImageSaver [get]

获取用于图像保存的对象 更多...

IImageDecoder ImageDecoder [get]

获取用于解码图像的的对象 更多...

IVideoRecorder VideoRecorder [get]

获取录像对象 更多...

IImageRender ImageRender [get]

获取图像和图形渲染对象 更多...

事件 继承自 IDevice

EventHandler< DeviceExceptionArgs > DeviceExceptionEvent

设备异常事件 更多...

详细描述

GigE设备专用接口

成员函数说明

◆ GetOptimalPacketSize()

Int32 IGigEDevice.GetOptimalPacketSize ( out Int32 optimalPacketSize )

获取最佳包大小

参数

optimalPacketSize 最佳包大小

返回

成功，返回MV_OK；失败，返回错误码

◆ ForceIp()

Int32 IGigEDevice.ForceIp ( UInt32 ip,

UInt32 subnetMask,

UInt32 defaultGateway

)

强制设置设备网络参数（包括IP、子网掩码和默认网关）

参数

ip IP地址

subnetMask 子网掩码

defaultGateway 默认网关

返回

成功，返回MV_OK；失败，返回错误码

注意

强制设置之后将需要重新创建设备句柄，仅GigE设备支持。

如果设备的IP分配设置采用DHCP，那么调用该接口强制设置设备网络参数之后设备将会重启。

◆ SetIpConfig()

Int32 IGigEDevice.SetIpConfig ( IpConfigType type )

配置IP方式

参数

type IP配置类型 IpConfigType

返回

成功，返回MV_OK；失败，返回错误码

◆ SetNetTransMode()

Int32 IGigEDevice.SetNetTransMode ( NetTransMode mode )

设置传输模式，默认为Driver模式

参数

mode 网络传输模式

返回

成功，返回MV_OK；失败，返回错误码

◆ GetNetTransInfo()

Int32 IGigEDevice.GetNetTransInfo ( out NetTransInfo info )

获取网络传输信息

参数

info 网络传输信息

返回

成功，返回MV_OK；失败，返回错误码

◆ SetGvspTimeout()

Int32 IGigEDevice.SetGvspTimeout ( UInt32 timeoutInMS )

设置GVSP取流超时时间

参数

timeoutInMS 超时时间(MS)，默认300ms，范围：>10ms

返回

成功，返回MV_OK；失败，返回错误码

◆ GetGvspTimeout()

Int32 IGigEDevice.GetGvspTimeout ( out UInt32 timeoutInMS )

获取GVSP取流超时时间

参数

timeoutInMS 超时时间(MS)

返回

成功，返回MV_OK；失败，返回错误码

◆ SetGvcpTimeout()

Int32 IGigEDevice.SetGvcpTimeout ( UInt32 timeoutInMS )

设置GVCP命令超时时间

参数

timeoutInMS 超时时间(MS)，默认500ms，范围：0-10000ms

返回

成功，返回MV_OK；失败，返回错误码

◆ GetGvcpTimeout()

Int32 IGigEDevice.GetGvcpTimeout ( out UInt32 timeoutInMS )

获取GVCP命令超时时间

参数

timeoutInMS 超时时间(MS)

返回

成功，返回MV_OK；失败，返回错误码

◆ SetRetryGvcpTimes()

Int32 IGigEDevice.SetRetryGvcpTimes ( UInt32 retryGvcpTimes )

设置重传GVCP命令次数

参数

retryGvcpTimes 重传次数，范围：0-100

返回

成功，返回MV_OK；失败，返回错误码

◆ GetRetryGvcpTimes()

Int32 IGigEDevice.GetRetryGvcpTimes ( out UInt32 retryGvcpTimes )

获取重传GVCP命令次数

参数

retryGvcpTimes 重传次数

返回

成功，返回MV_OK；失败，返回错误码

◆ SetResend()

Int32 IGigEDevice.SetResend ( bool enable,

UInt32 maxResendPercent,

UInt32 resendTimeout

)

设置是否打开重发包，及重发包参数

参数

enable 是否支持重发包

maxResendPercent 最大重发比

resendTimeout 重发超时时间

返回

成功，返回MV_OK；失败，返回错误码

◆ SetResendMaxRetryTimes()

Int32 IGigEDevice.SetResendMaxRetryTimes ( UInt32 retryTimes )

设置重传命令最大尝试次数

参数

retryTimes 重传命令最大尝试次数，默认值20

返回

成功，返回MV_OK；失败，返回错误码

注意

该接口必须在调用SetResend开启重传包功能之后调用，否则失败且返回 MV_E_CALLORDER 。

◆ GetResendMaxRetryTimes()

Int32 IGigEDevice.GetResendMaxRetryTimes ( out UInt32 retryTimes )

获取重传命令最大尝试次数

参数

retryTimes 传命令最大尝试次数

返回

成功，返回MV_OK；失败，返回错误码

注意

该接口必须在调用SetResend开启重传包功能之后调用，否则失败且返回 MV_E_CALLORDER 。

◆ SetResendTimeInterval()

Int32 IGigEDevice.SetResendTimeInterval ( UInt32 timeInMS )

设置同一重传包多次请求之间的时间间隔

参数

timeInMS 同一重传包多次请求之间的时间间隔，默认10ms

返回

成功，返回MV_OK；失败，返回错误码

◆ GetResendTimeInterval()

Int32 IGigEDevice.GetResendTimeInterval ( out UInt32 timeInMS )

获取同一重传包多次请求之间的时间间隔

参数

timeInMS

返回

成功，返回MV_OK；失败，返回错误码

◆ SetTransmissionType()

Int32 IGigEDevice.SetTransmissionType ( TransmissionType type,

UInt32 multicastIP,

UInt32 multicastPort

)

设置传输模式，可以为单播模式、组播模式等

参数

type

multicastIP 组播地址，组播模式下有意义

multicastPort 组播端口，组播模式下有意义

返回

成功，返回MV_OK；失败，返回错误码

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | 所有成员列表

IUSBDevice接口 参考 相机

USB设备专用接口 更多...

继承自 IDevice .

Public 成员函数

Int32 SetTransferSize (UInt32 transferSize)

设置U3V的传输包大小 更多...

Int32 GetTransferSize (out UInt32 transferSize)

获取U3V的传输包大小 更多...

Int32 SetTransferWays (UInt32 transferWays)

设置U3V的传输通道个数 更多...

Int32 GetTransferWays (out UInt32 transferWays)

获取U3V的传输通道个数 更多...

Int32 SetEventNodeNum (UInt32 eventNodeNum)

设置U3V的事件缓存节点个数 更多...

Int32 SetSyncTimeOut (UInt32 timeoutInMS)

设置U3V相机同步读写超时时间，范围为1000~UINT，默认1000 ms 更多...

Int32 GetSyncTimeOut (out UInt32 timeoutInMS)

获取U3V相机同步读写超时时间 更多...

Int32 GetUSBTransInfo (out USBTransInfo usbTransInfo)

获取主机从USB设备接收的数据统计信息，如已接收字节数、帧数 更多...

Public 成员函数 继承自 IDevice

Int32 Open ()

打开设备，默认以“独占”模式访问设备。设备访问模式相关详情，请参见DeviceAccessMode 更多...

Int32 Open (DeviceAccessMode AccessMode, UInt32 switchoverKey)

以指定的设备访问模式打开设备，只支持GigE设备。设备访问模式相关详情，请参见DeviceAccessMode 更多...

Int32 Close ()

关闭设备 更多...

Int32 LocalUpgrade (String filePath)

设备本地升级 更多...

Int32 GetUpgradeProcess (out UInt32 process)

获取升级进度 更多...

Int32 EventNotificationOn (String eventName)

开启设备指定事件 更多...

Int32 EventNotificationOff (String eventName)

关闭设备指定事件 更多...

额外继承的成员函数

属性 继承自 IDevice

bool IsConnected [get]

判断设备是否处于连接状态 更多...

IStreamGrabber StreamGrabber [get]

获取设备对应的图像采集对象 更多...

IEventGrabber EventGrabber [get]

获取设备对应的事件采集对象 更多...

IDeviceInfo DeviceInfo [get]

获取设备信息 更多...

IParameters Parameters [get]

获取设备对应的参数配置对象 更多...

IPixelTypeConverter PixelTypeConverter [get]

获取格式转换对象 更多...

IImageProcess ImageProcess [get]

获取用于图像处理的对象 更多...

IImageSaver ImageSaver [get]

获取用于图像保存的对象 更多...

IImageDecoder ImageDecoder [get]

获取用于解码图像的的对象 更多...

IVideoRecorder VideoRecorder [get]

获取录像对象 更多...

IImageRender ImageRender [get]

获取图像和图形渲染对象 更多...

事件 继承自 IDevice

EventHandler< DeviceExceptionArgs > DeviceExceptionEvent

设备异常事件 更多...

详细描述

USB设备专用接口

成员函数说明

◆ SetTransferSize()

Int32 IUSBDevice.SetTransferSize ( UInt32 transferSize )

设置U3V的传输包大小

参数

transferSize 传输的包大小,单位：Byte，默认为1M，范围：Windows[0x400, 0x400000], Linux[0x400, 0x200000]

返回

成功，返回MV_OK；失败，返回错误码

注意

增加传输包大小可以适当降低取流时的CPU占用率。但不同的PC和不同USB扩展卡存在不同的兼容性，如果该参数设置过大可能会出现取不到图像的风险。

◆ GetTransferSize()

Int32 IUSBDevice.GetTransferSize ( out UInt32 transferSize )

获取U3V的传输包大小

参数

transferSize 传输的包大小， 单位：Byte

返回

成功，返回MV_OK；失败，返回错误码

◆ SetTransferWays()

Int32 IUSBDevice.SetTransferWays ( UInt32 transferWays )

设置U3V的传输通道个数

参数

transferWays 传输通道个数，范围：1-10

返回

成功，返回MV_OK；失败，返回错误码

注解

可根据PC的性能、设备出图帧率、图像大小和内存使用率等因素对该参数进行调节。但不同的PC和不同的USB扩展卡存在不同的兼容性。

◆ GetTransferWays()

Int32 IUSBDevice.GetTransferWays ( out UInt32 transferWays )

获取U3V的传输通道个数

参数

transferWays 传输通道个数

返回

成功，返回MV_OK；失败，返回错误码

注解

该接口用于获取当前的U3V异步取流节点个数，2000W设备的MONO8默认为3个，YUV为默认2个，RGB为默认1个，其它情况默认8个节点。

◆ SetEventNodeNum()

Int32 IUSBDevice.SetEventNodeNum ( UInt32 eventNodeNum )

设置U3V的事件缓存节点个数

参数

eventNodeNum 事件缓存节点个数，范围：1-64

返回

成功，返回MV_OK；失败，返回错误码

注解

该接口用于设置当前的U3V事件缓存节点个数，默认情况下为5个。

◆ SetSyncTimeOut()

Int32 IUSBDevice.SetSyncTimeOut ( UInt32 timeoutInMS )

设置U3V相机同步读写超时时间，范围为1000~UINT，默认1000 ms

参数

timeoutInMS 同步读写超时时间

返回

成功，返回MV_OK；失败，返回错误码

◆ GetSyncTimeOut()

Int32 IUSBDevice.GetSyncTimeOut ( out UInt32 timeoutInMS )

获取U3V相机同步读写超时时间

参数

timeoutInMS 同步读写超时时间

返回

成功，返回MV_OK；失败，返回错误码

◆ GetUSBTransInfo()

Int32 IUSBDevice.GetUSBTransInfo ( out USBTransInfo usbTransInfo )

获取主机从USB设备接收的数据统计信息，如已接收字节数、帧数

参数

usbTransInfo USB传输信息

返回

成功，返回MV_OK；失败，返回错误码

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | 所有成员列表

ICamlDevice接口 参考 相机

Camera Link串口设备专用接口 更多...

继承自 IDevice .

Public 成员函数

Int32 SetDeviceBaudrate (CameraLinkBaudrate baudrate)

设置设备波特率 更多...

Int32 GetDeviceBaudrate (out CameraLinkBaudrate baudrate)

获取设备波特率 更多...

Int32 GetSupportBaudrates (out UInt32 baudrateAbility)

获取设备与主机间连接支持的波特率 更多...

Int32 SetGenCPTimeOut (UInt32 timeoutInMS)

设置串口操作等待时长 更多...

Public 成员函数 继承自 IDevice

Int32 Open ()

打开设备，默认以“独占”模式访问设备。设备访问模式相关详情，请参见DeviceAccessMode 更多...

Int32 Open (DeviceAccessMode AccessMode, UInt32 switchoverKey)

以指定的设备访问模式打开设备，只支持GigE设备。设备访问模式相关详情，请参见DeviceAccessMode 更多...

Int32 Close ()

关闭设备 更多...

Int32 LocalUpgrade (String filePath)

设备本地升级 更多...

Int32 GetUpgradeProcess (out UInt32 process)

获取升级进度 更多...

Int32 EventNotificationOn (String eventName)

开启设备指定事件 更多...

Int32 EventNotificationOff (String eventName)

关闭设备指定事件 更多...

额外继承的成员函数

属性 继承自 IDevice

bool IsConnected [get]

判断设备是否处于连接状态 更多...

IStreamGrabber StreamGrabber [get]

获取设备对应的图像采集对象 更多...

IEventGrabber EventGrabber [get]

获取设备对应的事件采集对象 更多...

IDeviceInfo DeviceInfo [get]

获取设备信息 更多...

IParameters Parameters [get]

获取设备对应的参数配置对象 更多...

IPixelTypeConverter PixelTypeConverter [get]

获取格式转换对象 更多...

IImageProcess ImageProcess [get]

获取用于图像处理的对象 更多...

IImageSaver ImageSaver [get]

获取用于图像保存的对象 更多...

IImageDecoder ImageDecoder [get]

获取用于解码图像的的对象 更多...

IVideoRecorder VideoRecorder [get]

获取录像对象 更多...

IImageRender ImageRender [get]

获取图像和图形渲染对象 更多...

事件 继承自 IDevice

EventHandler< DeviceExceptionArgs > DeviceExceptionEvent

设备异常事件 更多...

详细描述

Camera Link串口设备专用接口

成员函数说明

◆ SetDeviceBaudrate()

Int32 ICamlDevice.SetDeviceBaudrate ( CameraLinkBaudrate baudrate )

设置设备波特率

参数

baudrate 波特率

返回

成功，返回MV_OK；失败，返回错误码

注意

因硬件配置、系统配置、外部干扰等因素，配置高波特率可能导致通信异常，建议配置波特率最大小于115200

◆ GetDeviceBaudrate()

Int32 ICamlDevice.GetDeviceBaudrate ( out CameraLinkBaudrate baudrate )

获取设备波特率

参数

baudrate 波特率

返回

成功，返回MV_OK；失败，返回错误码

◆ GetSupportBaudrates()

Int32 ICamlDevice.GetSupportBaudrates ( out UInt32 baudrateAbility )

获取设备与主机间连接支持的波特率

参数

baudrateAbility 所支持波特率的或运算结果，单个波特率参考 CameraLinkBaudrate

返回

成功，返回MV_OK；失败，返回错误码

◆ SetGenCPTimeOut()

Int32 ICamlDevice.SetGenCPTimeOut ( UInt32 timeoutInMS )

设置串口操作等待时长

参数

timeoutInMS 串口操作的等待时长，单位为ms

返回

成功，返回MV_OK；失败，返回错误码

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 属性 | 所有成员列表

ActionCmdInfo结构体 参考 相机

动作命令信息 更多...

Public 属性

UInt32 DeviceKey

设备密钥 更多...

UInt32 GroupKey

组键 更多...

UInt32 GroupMask

组掩码 更多...

UInt32 ActionTimeEnable

只有设置成1时Action Time才有效，非1时无效 更多...

Int64 ActionTime

预定的时间，和主频有关 更多...

String BroadcastAddress

广播包地址 更多...

UInt32 TimeOut

等待ACK的超时时间，如果为0表示不需要ACK 更多...

UInt32 SpecialNetEnable

只有设置成1时指定的网卡IP才有效，非1时无效 更多...

String SpecialNetIP

指定的网卡IP 更多...

详细描述

动作命令信息

类成员变量说明

◆ DeviceKey

UInt32 ActionCmdInfo.DeviceKey

设备密钥

◆ GroupKey

UInt32 ActionCmdInfo.GroupKey

组键

◆ GroupMask

UInt32 ActionCmdInfo.GroupMask

组掩码

◆ ActionTimeEnable

UInt32 ActionCmdInfo.ActionTimeEnable

只有设置成1时Action Time才有效，非1时无效

◆ ActionTime

Int64 ActionCmdInfo.ActionTime

预定的时间，和主频有关

◆ BroadcastAddress

String ActionCmdInfo.BroadcastAddress

广播包地址

◆ TimeOut

UInt32 ActionCmdInfo.TimeOut

等待ACK的超时时间，如果为0表示不需要ACK

◆ SpecialNetEnable

UInt32 ActionCmdInfo.SpecialNetEnable

只有设置成1时指定的网卡IP才有效，非1时无效

◆ SpecialNetIP

String ActionCmdInfo.SpecialNetIP

指定的网卡IP

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 属性 | 所有成员列表

ActionCmdResult结构体 参考 相机

动作命令返回信息 更多...

Public 属性

String DeviceAddress

设备IP 更多...

Int32 Status

状态码 更多...

详细描述

动作命令返回信息

类成员变量说明

◆ DeviceAddress

String ActionCmdResult.DeviceAddress

设备IP

◆ Status

Int32 ActionCmdResult.Status

状态码

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

静态 Public 成员函数 | 所有成员列表

DeviceEnumerator类 参考 相机

设备枚举类，支持枚举GigE Vision、USB3 Vision相机，及采集卡上的相机（GigE Vision、CameraLink、CoaXPress、XoFlink） 更多...

静态 Public 成员函数

static Int32 EnumDevices (DeviceTLayerType TLayerType, out List< IDeviceInfo > devInfoList)

枚举设备 更多...

static Int32 EnumDevicesEx (DeviceTLayerType TLayerType, String manufacturerName, out List< IDeviceInfo > devInfoList)

枚举设备，支持枚举指定厂商的设备 更多...

static Int32 EnumDevicesEx2 (DeviceTLayerType TLayerType, SortMethod sortMethod, String manufacturerName, out List< IDeviceInfo > devInfoList)

枚举设备, 可指定排序方式枚举、根据厂商名字过滤 更多...

static bool IsDeviceAccessible (IDeviceInfo deviceInfo, DeviceAccessMode accessMode)

判断设备是否可达 更多...

static Int32 SetGigEDeviceEnumTimeout (UInt32 timeoutInMS)

设置GigE设备枚举超时时间，范围 1-UINT_MAX（包括1，不包括UINT_MAX） 更多...

static Int32 SetGigEDeviceDiscoryMode (UInt32 mode)

设置枚举命令的回复包类型 更多...

static Int32 GetSerialPortList (out List< String > serialPortList)

获取主机串口列表 更多...

static Int32 SetEnumSerialPorts (List< String > serialPortList)

设置在指定的串口上枚举设备 更多...

static Int32 GigEIssueActionCommand (ActionCmdInfo actionCmdInfo, out List< ActionCmdResult > actionCmdResults)

发出动作命令 更多...

static Int32 GetGigEMulticastStatus (IDeviceInfo deviceInfo, out Boolean status)

获取GigE设备组播状态 更多...

详细描述

设备枚举类，支持枚举GigE Vision、USB3 Vision相机，及采集卡上的相机（GigE Vision、CameraLink、CoaXPress、XoFlink）

成员函数说明

◆ EnumDevices()

static Int32 DeviceEnumerator.EnumDevices ( DeviceTLayerType TLayerType,

out List< IDeviceInfo > devInfoList

)

static

枚举设备

参数

TLayerType 设备接口类型

devInfoList 设备列表

返回

成功，返回MV_OK；失败，返回错误码

注解

设备接口类型为 MvGigEDevice 时，枚举所有GigE设备，包含虚拟GigE设备和采集卡上的GigE设备。

设备接口类型为 MvUsbDevice 时，枚举所有USB设备，包含虚拟USB设备。

注意

设备列表的内存是在SDK内部分配的，调用该接口时会进行设备列表内存的释放和申请，请避免多线程枚举操作。

后续调用

枚举到设备后，通过DeviceFactory创建设备实例。

◆ EnumDevicesEx()

static Int32 DeviceEnumerator.EnumDevicesEx ( DeviceTLayerType TLayerType,

String manufacturerName,

out List< IDeviceInfo > devInfoList

)

static

枚举设备，支持枚举指定厂商的设备

参数

TLayerType 设备接口类型

manufacturerName 厂商名称

devInfoList 设备列表

返回

成功，返回MV_OK；失败，返回错误码

注解

设备接口类型为 MvGigEDevice 时，枚举所有GigE设备，包含虚拟GigE设备和采集卡上的GigE设备。

设备接口类型为 MvUsbDevice 时，枚举所有USB设备，包含虚拟USB设备。

注意

设备列表的内存是在SDK内部分配的，调用该接口时会进行设备列表内存的释放和申请，避免多线程枚举操作。

后续调用

枚举到设备后，通过DeviceFactory创建设备实例。

◆ EnumDevicesEx2()

static Int32 DeviceEnumerator.EnumDevicesEx2 ( DeviceTLayerType TLayerType,

SortMethod sortMethod,

String manufacturerName,

out List< IDeviceInfo > devInfoList

)

static

枚举设备, 可指定排序方式枚举、根据厂商名字过滤

参数

TLayerType 设备接口类型

sortMethod 排序方式

manufacturerName 厂商名称

devInfoList 设备列表

返回

成功，返回MV_OK；失败，返回错误码

注解

设备接口类型为 MvGigEDevice 时，仅枚举网络上的网口相机，不包含虚拟GigE相机和采集卡上的相机

设备接口类型为 MvUsbDevice 时，枚举普通USB设备，不包含虚拟USB设备。

注意

设备列表的内存是在SDK内部分配的，调用该接口时会进行设备列表内存的释放和申请，避免多线程枚举操作。

后续调用

枚举到设备后，通过DeviceFactory创建设备实例。

◆ IsDeviceAccessible()

static bool DeviceEnumerator.IsDeviceAccessible ( IDeviceInfo deviceInfo,

DeviceAccessMode accessMode

)

static

判断设备是否可达

参数

deviceInfo 设备信息

accessMode 访问权限

返回

可达，返回true；不可达，返回false

◆ SetGigEDeviceEnumTimeout()

static Int32 DeviceEnumerator.SetGigEDeviceEnumTimeout ( UInt32 timeoutInMS )

static

设置GigE设备枚举超时时间，范围 1-UINT_MAX（包括1，不包括UINT_MAX）

参数

timeoutInMS 超时时间

返回

成功，返回MV_OK；失败，返回错误码

◆ SetGigEDeviceDiscoryMode()

static Int32 DeviceEnumerator.SetGigEDeviceDiscoryMode ( UInt32 mode )

static

设置枚举命令的回复包类型

参数

mode 回复包类型（默认广播），0-单播，1-广播

返回

成功，返回MV_OK；失败，返回错误码

◆ GetSerialPortList()

static Int32 DeviceEnumerator.GetSerialPortList ( out List< String > serialPortList )

static

获取主机串口列表

参数

serialPortList 串口列表

返回

成功，返回MV_OK；失败，返回错误码

◆ SetEnumSerialPorts()

static Int32 DeviceEnumerator.SetEnumSerialPorts ( List< String > serialPortList )

static

设置在指定的串口上枚举设备

参数

serialPortList 串口列表

返回

成功，返回MV_OK；失败，返回错误码

◆ GigEIssueActionCommand()

static Int32 DeviceEnumerator.GigEIssueActionCommand ( ActionCmdInfo actionCmdInfo,

out List< ActionCmdResult > actionCmdResults

)

static

发出动作命令

参数

actionCmdInfo 动作命令信息

actionCmdResults 动作命令返回信息列表

返回

成功，返回MV_OK；失败，返回错误码

注意

仅GigEVision相机支持

◆ GetGigEMulticastStatus()

static Int32 DeviceEnumerator.GetGigEMulticastStatus ( IDeviceInfo deviceInfo,

out Boolean status

)

static

获取GigE设备组播状态

参数

deviceInfo 设备信息

status 组播状态（true：组播状态；false：非组播）

返回

成功，返回MV_OK；失败，返回错误码

注意

仅GigEVision相机支持

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

静态 Public 成员函数 | 所有成员列表

DeviceFactory类 参考 相机

相机工厂类，用于创建相机实例 更多...

静态 Public 成员函数

static IDevice CreateDevice (IDeviceInfo deviceInfo)

创建相机对象 更多...

static IDevice CreateDeviceByIp (String deviceIp, String netExportIp)

通过相机IP地址创建相机，适用于GigE相机 更多...

static IDevice CreateDeviceByGenTL (IGenTLDevInfo devInfo)

通过GenTL相机信息创建相机句柄 更多...

详细描述

相机工厂类，用于创建相机实例

成员函数说明

◆ CreateDevice()

static IDevice DeviceFactory.CreateDevice ( IDeviceInfo deviceInfo )

static

创建相机对象

参数

deviceInfo 相机信息

返回

成功-返回相机实例，失败-抛出异常 MvException

◆ CreateDeviceByIp()

static IDevice DeviceFactory.CreateDeviceByIp ( String deviceIp,

String netExportIp

)

static

通过相机IP地址创建相机，适用于GigE相机

参数

deviceIp 相机IP地址

netExportIp 网口IP地址

返回

成功-返回相机实例，失败-抛出异常 MvException

◆ CreateDeviceByGenTL()

static IDevice DeviceFactory.CreateDeviceByGenTL ( IGenTLDevInfo devInfo )

static

通过GenTL相机信息创建相机句柄

参数

devInfo 相机信息

返回

成功-返回相机实例，失败-抛出异常 MvException

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IDeviceInfo接口 参考 相机

设备基本信息 更多...

被 ICameraLinkDeviceInfo, ICamlDeviceInfo, ICXPDeviceInfo, IGigEDeviceInfo, IUSBDeviceInfo , 以及 IXoFDeviceInfo 继承.

属性

DeviceTLayerType TLayerType [get]

设备接口类型 更多...

String ManufacturerName [get]

制造商信息 更多...

String ModelName [get]

设备型号 更多...

String DeviceVersion [get]

设备版本 更多...

String SerialNumber [get]

设备序列号 更多...

String UserDefinedName [get]

用户自定义名称 更多...

UInt32 DevTypeInfo [get]

设备类型信息，7 - 0 bit: 预留，15 - 8 bit：产品子类别，23 - 16 bit：产品类型，31 - 24bit：产品线（如: 0x01 标准产品；0x02 3D产品；0x03 智能ID产品） 更多...

详细描述

设备基本信息

属性说明

◆ TLayerType

DeviceTLayerType IDeviceInfo.TLayerType

get

设备接口类型

◆ ManufacturerName

String IDeviceInfo.ManufacturerName

get

制造商信息

◆ ModelName

String IDeviceInfo.ModelName

get

设备型号

◆ DeviceVersion

String IDeviceInfo.DeviceVersion

get

设备版本

◆ SerialNumber

String IDeviceInfo.SerialNumber

get

设备序列号

◆ UserDefinedName

String IDeviceInfo.UserDefinedName

get

用户自定义名称

◆ DevTypeInfo

UInt32 IDeviceInfo.DevTypeInfo

get

设备类型信息，7 - 0 bit: 预留，15 - 8 bit：产品子类别，23 - 16 bit：产品类型，31 - 24bit：产品线（如: 0x01 标准产品；0x02 3D产品；0x03 智能ID产品）

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IGigEDeviceInfo接口 参考 相机

GigE相机信息 更多...

继承自 IDeviceInfo .

属性

UInt16 MajorVer [get]

GigE Vision协议主要版本 更多...

UInt16 MinorVer [get]

GigE Vision协议次要版本 更多...

UInt32 MacAddrHigh [get]

高MAC地址 更多...

UInt32 MacAddrLow [get]

低MAC地址 更多...

UInt32 IpCfgOption [get]

IP配置选项 更多...

UInt32 IpCfgCurrent [get]

当前IP配置 更多...

UInt32 CurrentIp [get]

当前IP地址 更多...

UInt32 CurrentSubNetMask [get]

当前子网掩码 更多...

UInt32 DefultGateWay [get]

当前网关 更多...

UInt32 NetExport [get]

网口IP地址 更多...

bool VirtualDevice [get]

是否虚拟相机 更多...

bool GenTLDevice [get]

是否采集卡上的相机 更多...

属性 继承自 IDeviceInfo

DeviceTLayerType TLayerType [get]

设备接口类型 更多...

String ManufacturerName [get]

制造商信息 更多...

String ModelName [get]

设备型号 更多...

String DeviceVersion [get]

设备版本 更多...

String SerialNumber [get]

设备序列号 更多...

String UserDefinedName [get]

用户自定义名称 更多...

UInt32 DevTypeInfo [get]

设备类型信息，7 - 0 bit: 预留，15 - 8 bit：产品子类别，23 - 16 bit：产品类型，31 - 24bit：产品线（如: 0x01 标准产品；0x02 3D产品；0x03 智能ID产品） 更多...

详细描述

GigE相机信息

属性说明

◆ MajorVer

UInt16 IGigEDeviceInfo.MajorVer

get

GigE Vision协议主要版本

◆ MinorVer

UInt16 IGigEDeviceInfo.MinorVer

get

GigE Vision协议次要版本

◆ MacAddrHigh

UInt32 IGigEDeviceInfo.MacAddrHigh

get

高MAC地址

◆ MacAddrLow

UInt32 IGigEDeviceInfo.MacAddrLow

get

低MAC地址

◆ IpCfgOption

UInt32 IGigEDeviceInfo.IpCfgOption

get

IP配置选项

◆ IpCfgCurrent

UInt32 IGigEDeviceInfo.IpCfgCurrent

get

当前IP配置

◆ CurrentIp

UInt32 IGigEDeviceInfo.CurrentIp

get

当前IP地址

◆ CurrentSubNetMask

UInt32 IGigEDeviceInfo.CurrentSubNetMask

get

当前子网掩码

◆ DefultGateWay

UInt32 IGigEDeviceInfo.DefultGateWay

get

当前网关

◆ NetExport

UInt32 IGigEDeviceInfo.NetExport

get

网口IP地址

◆ VirtualDevice

bool IGigEDeviceInfo.VirtualDevice

get

是否虚拟相机

◆ GenTLDevice

bool IGigEDeviceInfo.GenTLDevice

get

是否采集卡上的相机

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IUSBDeviceInfo接口 参考 相机

USB相机信息 更多...

继承自 IDeviceInfo .

属性

Byte CrtlInEndPoint [get]

控制输入端点 更多...

Byte CrtlOutEndPoint [get]

控制输出端点 更多...

Byte StreamEndPoint [get]

流端点 更多...

Byte EventEndPoint [get]

事件端点 更多...

UInt16 VendorID [get]

供应商ID号 更多...

UInt16 ProductID [get]

产品ID号 更多...

UInt32 DeviceNumber [get]

设备索引号 更多...

String DeviceGUID [get]

设备GUID号 更多...

String FamilyName [get]

家族名字 更多...

UInt32 nbcdUSB [get]

支持的USB协议 更多...

UInt32 DeviceAddress [get]

设备地址 更多...

bool VirtualDevice [get]

是否虚拟相机 更多...

属性 继承自 IDeviceInfo

DeviceTLayerType TLayerType [get]

设备接口类型 更多...

String ManufacturerName [get]

制造商信息 更多...

String ModelName [get]

设备型号 更多...

String DeviceVersion [get]

设备版本 更多...

String SerialNumber [get]

设备序列号 更多...

String UserDefinedName [get]

用户自定义名称 更多...

UInt32 DevTypeInfo [get]

设备类型信息，7 - 0 bit: 预留，15 - 8 bit：产品子类别，23 - 16 bit：产品类型，31 - 24bit：产品线（如: 0x01 标准产品；0x02 3D产品；0x03 智能ID产品） 更多...

详细描述

USB相机信息

属性说明

◆ CrtlInEndPoint

Byte IUSBDeviceInfo.CrtlInEndPoint

get

控制输入端点

◆ CrtlOutEndPoint

Byte IUSBDeviceInfo.CrtlOutEndPoint

get

控制输出端点

◆ StreamEndPoint

Byte IUSBDeviceInfo.StreamEndPoint

get

流端点

◆ EventEndPoint

Byte IUSBDeviceInfo.EventEndPoint

get

事件端点

◆ VendorID

UInt16 IUSBDeviceInfo.VendorID

get

供应商ID号

◆ ProductID

UInt16 IUSBDeviceInfo.ProductID

get

产品ID号

◆ DeviceNumber

UInt32 IUSBDeviceInfo.DeviceNumber

get

设备索引号

◆ DeviceGUID

String IUSBDeviceInfo.DeviceGUID

get

设备GUID号

◆ FamilyName

String IUSBDeviceInfo.FamilyName

get

家族名字

◆ nbcdUSB

UInt32 IUSBDeviceInfo.nbcdUSB

get

支持的USB协议

◆ DeviceAddress

UInt32 IUSBDeviceInfo.DeviceAddress

get

设备地址

◆ VirtualDevice

bool IUSBDeviceInfo.VirtualDevice

get

是否虚拟相机

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

ICamlDeviceInfo接口 参考 相机

Camera Link串口设备信息 更多...

继承自 IDeviceInfo .

属性

String PortID [get]

端口号 更多...

String FamilyName [get]

名称 更多...

属性 继承自 IDeviceInfo

DeviceTLayerType TLayerType [get]

设备接口类型 更多...

String ManufacturerName [get]

制造商信息 更多...

String ModelName [get]

设备型号 更多...

String DeviceVersion [get]

设备版本 更多...

String SerialNumber [get]

设备序列号 更多...

String UserDefinedName [get]

用户自定义名称 更多...

UInt32 DevTypeInfo [get]

设备类型信息，7 - 0 bit: 预留，15 - 8 bit：产品子类别，23 - 16 bit：产品类型，31 - 24bit：产品线（如: 0x01 标准产品；0x02 3D产品；0x03 智能ID产品） 更多...

详细描述

Camera Link串口设备信息

属性说明

◆ PortID

String ICamlDeviceInfo.PortID

get

端口号

◆ FamilyName

String ICamlDeviceInfo.FamilyName

get

名称

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

ICXPDeviceInfo接口 参考 相机

CoaXPress设备信息 更多...

继承自 IDeviceInfo .

属性

String DeviceID [get]

相机ID 更多...

String InterfaceID [get]

采集卡ID 更多...

属性 继承自 IDeviceInfo

DeviceTLayerType TLayerType [get]

设备接口类型 更多...

String ManufacturerName [get]

制造商信息 更多...

String ModelName [get]

设备型号 更多...

String DeviceVersion [get]

设备版本 更多...

String SerialNumber [get]

设备序列号 更多...

String UserDefinedName [get]

用户自定义名称 更多...

UInt32 DevTypeInfo [get]

设备类型信息，7 - 0 bit: 预留，15 - 8 bit：产品子类别，23 - 16 bit：产品类型，31 - 24bit：产品线（如: 0x01 标准产品；0x02 3D产品；0x03 智能ID产品） 更多...

详细描述

CoaXPress设备信息

属性说明

◆ DeviceID

String ICXPDeviceInfo.DeviceID

get

相机ID

◆ InterfaceID

String ICXPDeviceInfo.InterfaceID

get

采集卡ID

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

ICameraLinkDeviceInfo接口 参考 相机

Camera Link设备信息 更多...

继承自 IDeviceInfo .

属性

String DeviceID [get]

相机ID 更多...

String InterfaceID [get]

采集卡ID 更多...

属性 继承自 IDeviceInfo

DeviceTLayerType TLayerType [get]

设备接口类型 更多...

String ManufacturerName [get]

制造商信息 更多...

String ModelName [get]

设备型号 更多...

String DeviceVersion [get]

设备版本 更多...

String SerialNumber [get]

设备序列号 更多...

String UserDefinedName [get]

用户自定义名称 更多...

UInt32 DevTypeInfo [get]

设备类型信息，7 - 0 bit: 预留，15 - 8 bit：产品子类别，23 - 16 bit：产品类型，31 - 24bit：产品线（如: 0x01 标准产品；0x02 3D产品；0x03 智能ID产品） 更多...

详细描述

Camera Link设备信息

属性说明

◆ DeviceID

String ICameraLinkDeviceInfo.DeviceID

get

相机ID

◆ InterfaceID

String ICameraLinkDeviceInfo.InterfaceID

get

采集卡ID

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IXoFDeviceInfo接口 参考 相机

XoFLink设备信息 更多...

继承自 IDeviceInfo .

属性

String DeviceID [get]

相机ID 更多...

String InterfaceID [get]

采集卡ID 更多...

属性 继承自 IDeviceInfo

DeviceTLayerType TLayerType [get]

设备接口类型 更多...

String ManufacturerName [get]

制造商信息 更多...

String ModelName [get]

设备型号 更多...

String DeviceVersion [get]

设备版本 更多...

String SerialNumber [get]

设备序列号 更多...

String UserDefinedName [get]

用户自定义名称 更多...

UInt32 DevTypeInfo [get]

设备类型信息，7 - 0 bit: 预留，15 - 8 bit：产品子类别，23 - 16 bit：产品类型，31 - 24bit：产品线（如: 0x01 标准产品；0x02 3D产品；0x03 智能ID产品） 更多...

详细描述

XoFLink设备信息

属性说明

◆ DeviceID

String IXoFDeviceInfo.DeviceID

get

相机ID

◆ InterfaceID

String IXoFDeviceInfo.InterfaceID

get

采集卡ID

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

类 | 枚举

采集卡

采集卡控制相关接口和数据结构，用于实现打开采集卡和关闭采集卡等采集卡基本控制功能 更多...

类

interface IInterface

提供采集卡属性和接口 更多...

class InterfaceEnumerator

提供枚举采集卡接口 更多...

class InterfaceFactory

采集卡工厂类，创建采集卡实例 更多...

interface IInterfaceInfo

采集卡信息 更多...

枚举

enum InterfaceTLayerType {

InterfaceTLayerType.MvGigEInterface = 0x00000001,

InterfaceTLayerType.MvCameraLinkInterface = 0x00000004,

InterfaceTLayerType.MvCXPInterface = 0x00000008,

InterfaceTLayerType.MvXoFInterface = 0x00000010

}

采集卡接口类型定义 更多...

详细描述

采集卡控制相关接口和数据结构，用于实现打开采集卡和关闭采集卡等采集卡基本控制功能

枚举类型说明

◆ InterfaceTLayerType

enum InterfaceTLayerType

strong

采集卡接口类型定义

枚举值

MvGigEInterface GigE Vision采集卡

MvCameraLinkInterface Camera Link采集卡

MvCXPInterface CoaXPress采集卡

MvXoFInterface XoFLink采集卡

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | 属性 | 所有成员列表

IInterface接口 参考 采集卡

提供采集卡属性和接口 更多...

继承自 IDisposable .

Public 成员函数

Int32 Open ()

打开采集卡 更多...

Int32 Close ()

关闭采集卡 更多...

Int32 LocalUpgrade (String filePath)

设备本地升级 更多...

Int32 GetUpgradeProcess (out UInt32 process)

获取升级进度 更多...

Int32 EnumDevices (out List< IDeviceInfo > devInfoList)

枚举采集卡上的相机 更多...

Int32 EventNotificationOn (String eventName)

开启设备指定事件 更多...

Int32 EventNotificationOff (String eventName)

关闭设备指定事件 更多...

属性

IParameters Parameters [get]

获取采集卡对应的参数配置对象 更多...

IEventGrabber EventGrabber [get]

获取采集卡对应的事件采集对象 更多...

详细描述

提供采集卡属性和接口

成员函数说明

◆ Open()

Int32 IInterface.Open ( )

打开采集卡

返回

成功，返回MV_OK；失败，返回错误码

◆ Close()

Int32 IInterface.Close ( )

关闭采集卡

返回

成功，返回MV_OK；失败，返回错误码

◆ LocalUpgrade()

Int32 IInterface.LocalUpgrade ( String filePath )

设备本地升级

参数

filePath 升级文件路径

返回

成功，返回MV_OK；失败，返回错误码

通过该接口可以将升级固件文件发送给设备进行升级。该接口需要等待升级固件文件成功传给设备端之后再返回，响应时间可能较长。

◆ GetUpgradeProcess()

Int32 IInterface.GetUpgradeProcess ( out UInt32 process )

获取升级进度

参数

process 升级进度

返回

成功，返回MV_OK；失败，返回错误码

◆ EnumDevices()

Int32 IInterface.EnumDevices ( out List< IDeviceInfo > devInfoList )

枚举采集卡上的相机

参数

devInfoList 相机列表

返回

成功，返回MV_OK；失败，返回错误码

◆ EventNotificationOn()

Int32 IInterface.EventNotificationOn ( String eventName )

开启设备指定事件

参数

eventName 事件名称

返回

成功，返回MV_OK；失败，返回错误码

注解

您可从MVS客户端查询所需的事件名称。

◆ EventNotificationOff()

Int32 IInterface.EventNotificationOff ( String eventName )

关闭设备指定事件

参数

eventName 事件名称

返回

成功，返回MV_OK；失败，返回错误码

注解

您可从MVS客户端查询所需的事件名称。

属性说明

◆ Parameters

IParameters IInterface.Parameters

get

获取采集卡对应的参数配置对象

◆ EventGrabber

IEventGrabber IInterface.EventGrabber

get

获取采集卡对应的事件采集对象

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

静态 Public 成员函数 | 所有成员列表

InterfaceEnumerator类 参考 采集卡

提供枚举采集卡接口 更多...

静态 Public 成员函数

static Int32 EnumInterfaces (InterfaceTLayerType TLayerType, out List< IInterfaceInfo > interfaceInfoList)

枚举采集卡 更多...

详细描述

提供枚举采集卡接口

成员函数说明

◆ EnumInterfaces()

static Int32 InterfaceEnumerator.EnumInterfaces ( InterfaceTLayerType TLayerType,

out List< IInterfaceInfo > interfaceInfoList

)

static

枚举采集卡

参数

TLayerType 采集卡接口类型

interfaceInfoList 采集卡列表

返回

成功，返回MV_OK；失败，返回错误码

枚举到采集卡后，通过InterfaceFactory创建采集卡实例。

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

静态 Public 成员函数 | 所有成员列表

InterfaceFactory类 参考 采集卡

采集卡工厂类，创建采集卡实例 更多...

静态 Public 成员函数

static IInterface CreateInterface (IInterfaceInfo interfaceInfo)

根据采集卡信息创建采集卡实例 更多...

static IInterface CreateInterface (String interfaceID)

根据采集卡ID创建采集卡实例 更多...

详细描述

采集卡工厂类，创建采集卡实例

成员函数说明

◆ CreateInterface() [1/2]

static IInterface InterfaceFactory.CreateInterface ( IInterfaceInfo interfaceInfo )

static

根据采集卡信息创建采集卡实例

参数

interfaceInfo 采集卡信息

返回

成功-返回采集卡实例，失败-抛出异常 MvException

◆ CreateInterface() [2/2]

static IInterface InterfaceFactory.CreateInterface ( String interfaceID )

static

根据采集卡ID创建采集卡实例

参数

interfaceID 采集卡ID

返回

成功-返回采集卡实例，失败-抛出异常 MvException

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IInterfaceInfo接口 参考 采集卡

采集卡信息 更多...

属性

InterfaceTLayerType TLayerType [get]

采集卡接口类型，InterfaceTLayerType 更多...

UInt32 PCIEInfo [get]

采集卡的PCIE插槽信息 更多...

String InterfaceID [get]

采集卡ID 更多...

String DisplayName [get]

显示名称 更多...

String SerialNumber [get]

序列号 更多...

String ModelName [get]

型号 更多...

String Manufacturer [get]

厂商 更多...

String DeviceVersion [get]

版本号 更多...

String UserDefinedName [get]

自定义名称 更多...

详细描述

采集卡信息

属性说明

◆ TLayerType

InterfaceTLayerType IInterfaceInfo.TLayerType

get

采集卡接口类型，InterfaceTLayerType

◆ PCIEInfo

UInt32 IInterfaceInfo.PCIEInfo

get

采集卡的PCIE插槽信息

◆ InterfaceID

String IInterfaceInfo.InterfaceID

get

采集卡ID

◆ DisplayName

String IInterfaceInfo.DisplayName

get

显示名称

◆ SerialNumber

String IInterfaceInfo.SerialNumber

get

序列号

◆ ModelName

String IInterfaceInfo.ModelName

get

型号

◆ Manufacturer

String IInterfaceInfo.Manufacturer

get

厂商

◆ DeviceVersion

String IInterfaceInfo.DeviceVersion

get

版本号

◆ UserDefinedName

String IInterfaceInfo.UserDefinedName

get

自定义名称

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

类 | 枚举

参数设置

设备参数配置相关接口和数据结构，用于实现相机和采集卡的参数配置功能 更多...

类

interface IIntValue

整形参数 更多...

interface IFloatValue

浮点型参数 更多...

interface IStringValue

字符串类型参数 更多...

interface IEnumEntry

枚举项参数 更多...

interface IEnumValue

枚举类型参数 更多...

interface INodeError

参数导入导出时的节点错误信息 更多...

interface IParameters

提供设备参数配置相关接口 更多...

枚举

enum XmlAccessMode {

XmlAccessMode.NI = 0,

XmlAccessMode.NA,

XmlAccessMode.WO,

XmlAccessMode.RO,

XmlAccessMode.RW,

XmlAccessMode.Undefined,

XmlAccessMode.CycleDetect

}

Xml节点访问模式 更多...

enum XmlInterfaceType {

XmlInterfaceType.IValue = 0,

XmlInterfaceType.IBase,

XmlInterfaceType.IInteger,

XmlInterfaceType.IBoolean,

XmlInterfaceType.ICommand,

XmlInterfaceType.IFloat,

XmlInterfaceType.IString,

XmlInterfaceType.IRegister,

XmlInterfaceType.ICategory,

XmlInterfaceType.IEnumeration,

XmlInterfaceType.IEnumEntry,

XmlInterfaceType.IPort

}

每个节点对应的接口类型 更多...

enum NodeErrorType {

NodeErrorType.NODE_INVALID = 1,

NodeErrorType.ACCESS_ERROR = 2,

NodeErrorType.OUT_RANGE = 3,

NodeErrorType.VERIFY_FAILD = 4,

NodeErrorType.OTHER = 100

}

节点错误信息的类型 更多...

详细描述

设备参数配置相关接口和数据结构，用于实现相机和采集卡的参数配置功能

枚举类型说明

◆ XmlAccessMode

enum XmlAccessMode

strong

Xml节点访问模式

枚举值

NI 不可实现

NA 不可用

WO 只写

RO 只读

RW 读写

Undefined 未定义

CycleDetect 内部用于AccessMode循环检测

◆ XmlInterfaceType

enum XmlInterfaceType

strong

每个节点对应的接口类型

枚举值

IValue Value

IBase Base

IInteger Integer

IBoolean Boolean

ICommand Command

IFloat Float

IString String

IRegister Register

ICategory Category

IEnumeration Enumeration

IEnumEntry EnumEntry

IPort Port

◆ NodeErrorType

enum NodeErrorType

strong

节点错误信息的类型

枚举值

NODE_INVALID 节点不存在

ACCESS_ERROR 访问条件错误,通常是节点不可读写

OUT_RANGE 写入越界,超出该节点支持的范围

VERIFY_FAILD 校验失败,通常是写入的值与文件中的值不匹配

OTHER 其它错误,可查阅日志

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IIntValue接口 参考 参数设置

整形参数 更多...

属性

Int64 CurValue [get]

当前值 更多...

Int64 Max [get]

最大值 更多...

Int64 Min [get]

最小值 更多...

Int64 Inc [get]

Increment 更多...

详细描述

整形参数

属性说明

◆ CurValue

Int64 IIntValue.CurValue

get

当前值

◆ Max

Int64 IIntValue.Max

get

最大值

◆ Min

Int64 IIntValue.Min

get

最小值

◆ Inc

Int64 IIntValue.Inc

get

Increment

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IFloatValue接口 参考 参数设置

浮点型参数 更多...

属性

float CurValue [get]

当前值 更多...

float Max [get]

最大值 更多...

float Min [get]

最小值 更多...

详细描述

浮点型参数

属性说明

◆ CurValue

float IFloatValue.CurValue

get

当前值

◆ Max

float IFloatValue.Max

get

最大值

◆ Min

float IFloatValue.Min

get

最小值

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IStringValue接口 参考 参数设置

字符串类型参数 更多...

属性

String CurValue [get]

当前值 更多...

UInt64 MaxLength [get]

最大长度 更多...

详细描述

字符串类型参数

属性说明

◆ CurValue

String IStringValue.CurValue

get

当前值

◆ MaxLength

UInt64 IStringValue.MaxLength

get

最大长度

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IEnumEntry接口 参考 参数设置

枚举项参数 更多...

属性

UInt32 Value [get]

枚举值 更多...

String Symbolic [get]

枚举符号 更多...

详细描述

枚举项参数

属性说明

◆ Value

UInt32 IEnumEntry.Value

get

枚举值

◆ Symbolic

String IEnumEntry.Symbolic

get

枚举符号

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IEnumValue接口 参考 参数设置

枚举类型参数 更多...

属性

IEnumEntry CurEnumEntry [get]

当前枚举项 更多...

UInt32 SupportedNum [get]

支持的枚举类型个数 更多...

IEnumEntry [] SupportEnumEntries [get]

支持的枚举项列表 更多...

详细描述

枚举类型参数

属性说明

◆ CurEnumEntry

IEnumEntry IEnumValue.CurEnumEntry

get

当前枚举项

◆ SupportedNum

UInt32 IEnumValue.SupportedNum

get

支持的枚举类型个数

◆ SupportEnumEntries

IEnumEntry [] IEnumValue.SupportEnumEntries

get

支持的枚举项列表

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

INodeError接口 参考 参数设置

参数导入导出时的节点错误信息 更多...

属性

String NodeName [get]

节点名称 更多...

NodeErrorType ErrorType [get]

错误类型 更多...

详细描述

参数导入导出时的节点错误信息

属性说明

◆ NodeName

String INodeError.NodeName

get

节点名称

◆ ErrorType

NodeErrorType INodeError.ErrorType

get

错误类型

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | 所有成员列表

IParameters接口 参考 参数设置

提供设备参数配置相关接口 更多...

Public 成员函数

Int32 InvalidateNodes ()

清除GenICam节点缓存 更多...

Int32 GetIntValue (String key, out IIntValue value)

获取Integer属性值 更多...

Int32 SetIntValue (String key, Int64 value)

设置Integer型属性值 更多...

Int32 GetEnumValue (String key, out IEnumValue value)

获取Enumeration属性值 更多...

Int32 SetEnumValue (String key, UInt32 value)

设置Enumeration属性值 更多...

Int32 SetEnumValueByString (String key, String value)

设置Enumeration属性 更多...

Int32 GetFloatValue (String key, out IFloatValue value)

获取Float属性值 更多...

Int32 SetFloatValue (String key, float value)

设置Float型属性值 更多...

Int32 GetBoolValue (String key, out bool value)

获取Boolean属性值 更多...

Int32 SetBoolValue (String key, bool value)

设置Boolean型属性值 更多...

Int32 GetStringValue (String key, out IStringValue value)

获取String属性值 更多...

Int32 SetStringValue (String key, String value)

设置String型属性值 更多...

Int32 SetCommandValue (String key)

设置Command型属性值 更多...

Int32 FeatureLoad (String filePath)

导入设备属性文件 更多...

Int32 FeatureLoadEx (String filePath, out List< INodeError > nodeErrors)

导入设备属性文件并保存错误信息列表 更多...

Int32 FeatureSave (String filePath)

保存设备属性到文件 更多...

Int32 ReadMemory (Int64 address, Int64 length, out Byte[] buffer)

通过设备寄存器地址读取寄存器 更多...

Int32 WriteMemory (Int64 address, Int64 length, Byte[] buffer)

通过设备寄存器地址写寄存器 更多...

Int32 GetGenICamXML (out String xmlData)

获取设备属性树XML 更多...

Int32 GetNodeAccessMode (String name, out XmlAccessMode mode)

获得当前节点的访问模式 更多...

Int32 GetNodeInterfaceType (String name, out XmlInterfaceType type)

获得当前节点的类型 更多...

Int32 FileAccessRead (String deviceFileName, String localFilePath)

从设备读取文件，保存为本地文件 更多...

Int32 FileAccessRead (String devFileName, out Byte[] buffer)

从设备读取文件，保存在内存 更多...

Int32 FileAccessWrite (String deviceFileName, String localFilePath)

将文件写入设备 更多...

Int32 FileAccessWrite (String devFileName, Byte[] buffer)

将内存中的文件写入设备 更多...

Int32 GetFileAccessProgress (out Int64 completed, out Int64 total)

获取文件存取的进度 更多...

详细描述

提供设备参数配置相关接口

成员函数说明

◆ InvalidateNodes()

Int32 IParameters.InvalidateNodes ( )

清除GenICam节点缓存

返回

成功，返回MV_OK；失败，返回错误码

在加载工业相机节点时需要读取GenICam配置文件，该接口可以起到清除GenICam缓存的功能。

◆ GetIntValue()

Int32 IParameters.GetIntValue ( String key,

out IIntValue value

)

获取Integer属性值

参数

key 属性键值，如获取宽度信息则为"Width"

value 属性值

返回

成功，返回MV_OK；失败，返回错误码

◆ SetIntValue()

Int32 IParameters.SetIntValue ( String key,

Int64 value

)

设置Integer型属性值

参数

key 属性键值，如设置宽度信息则为"Width"

value 属性值

返回

成功，返回MV_OK；失败，返回错误码

◆ GetEnumValue()

Int32 IParameters.GetEnumValue ( String key,

out IEnumValue value

)

获取Enumeration属性值

参数

key 属性键值，如获取像素格式信息则为"PixelFormat"

value 属性值

返回

成功，返回MV_OK；失败，返回错误码

◆ SetEnumValue()

Int32 IParameters.SetEnumValue ( String key,

UInt32 value

)

设置Enumeration属性值

参数

key 属性键值，如设置像素格式信息则为"PixelFormat"

value Enum型节点的值

返回

成功，返回MV_OK；失败，返回错误码

◆ SetEnumValueByString()

Int32 IParameters.SetEnumValueByString ( String key,

String value

)

设置Enumeration属性

参数

key 属性键值，如设置像素格式信息则为"PixelFormat"

value EnumEntry的名称

返回

成功，返回MV_OK；失败，返回错误码

◆ GetFloatValue()

Int32 IParameters.GetFloatValue ( String key,

out IFloatValue value

)

获取Float属性值

参数

key 属性键值

value 属性值

返回

成功，返回MV_OK；失败，返回错误码

◆ SetFloatValue()

Int32 IParameters.SetFloatValue ( String key,

float value

)

设置Float型属性值

参数

key 属性键值

value 属性值

返回

成功，返回MV_OK；失败，返回错误码

◆ GetBoolValue()

Int32 IParameters.GetBoolValue ( String key,

out bool value

)

获取Boolean属性值

参数

key 属性键值

value 属性值

返回

成功，返回MV_OK；失败，返回错误码

◆ SetBoolValue()

Int32 IParameters.SetBoolValue ( String key,

bool value

)

设置Boolean型属性值

参数

key 属性键值

value 属性值

返回

成功，返回MV_OK；失败，返回错误码

◆ GetStringValue()

Int32 IParameters.GetStringValue ( String key,

out IStringValue value

)

获取String属性值

参数

key 属性键值

value 属性值

返回

成功，返回MV_OK；失败，返回错误码

◆ SetStringValue()

Int32 IParameters.SetStringValue ( String key,

String value

)

设置String型属性值

参数

key 属性键值

value 属性值

返回

成功，返回MV_OK；失败，返回错误码

◆ SetCommandValue()

Int32 IParameters.SetCommandValue ( String key )

设置Command型属性值

参数

key 属性键值

返回

成功，返回MV_OK；失败，返回错误码

◆ FeatureLoad()

Int32 IParameters.FeatureLoad ( String filePath )

导入设备属性文件

参数

filePath 文件路径

返回

成功，返回MV_OK；失败，返回错误码

◆ FeatureLoadEx()

Int32 IParameters.FeatureLoadEx ( String filePath,

out List< INodeError > nodeErrors

)

导入设备属性文件并保存错误信息列表

参数

filePath 文件路径

nodeErrors 导入失败的节点信息

返回

成功，返回MV_OK；失败，返回错误码

部分节点导入失败时也会返回MV_OK，通过nodeErrors返回导入失败的节点及错误原因

◆ FeatureSave()

Int32 IParameters.FeatureSave ( String filePath )

保存设备属性到文件

参数

filePath 文件路径

返回

成功，返回MV_OK；失败，返回错误码

◆ ReadMemory()

Int32 IParameters.ReadMemory ( Int64 address,

Int64 length,

out Byte [] buffer

)

通过设备寄存器地址读取寄存器

参数

address 待读取的内存地址，该地址可以从设备的Camera.xml文件中获取，形如xxx_RegAddr的xml节点值

length 待读取的内存长度

buffer 存放读到的内存值（GEV设备内存值是按照大端模式存储的，其它协议设备按照小端存储）

返回

成功，返回MV_OK；失败，返回错误码

访问设备，读取某段寄存器的数据。

◆ WriteMemory()

Int32 IParameters.WriteMemory ( Int64 address,

Int64 length,

Byte [] buffer

)

通过设备寄存器地址写寄存器

参数

address 待写入的内存地址，该地址可以从设备的Camera.xml文件中获取，形如xxx_RegAddr的xml节点值

length 待写入的内存长度

buffer 待写入的内存值（注意GEV设备内存值要按照大端模式存储，其它协议设备按照小端存储）

返回

成功，返回MV_OK；失败，返回错误码

访问设备，把一段数据写入某段寄存器。

◆ GetGenICamXML()

Int32 IParameters.GetGenICamXML ( out String xmlData )

获取设备属性树XML

参数

xmlData 设备xml

返回

成功，返回MV_OK；失败，返回错误码

◆ GetNodeAccessMode()

Int32 IParameters.GetNodeAccessMode ( String name,

out XmlAccessMode mode

)

获得当前节点的访问模式

参数

name 节点名称

mode 节点的访问模式

返回

成功，返回MV_OK；失败，返回错误码

◆ GetNodeInterfaceType()

Int32 IParameters.GetNodeInterfaceType ( String name,

out XmlInterfaceType type

)

获得当前节点的类型

参数

name 节点名称

type 节点类型

返回

成功，返回MV_OK；失败，返回错误码

◆ FileAccessRead() [1/2]

Int32 IParameters.FileAccessRead ( String deviceFileName,

String localFilePath

)

从设备读取文件，保存为本地文件

参数

deviceFileName 设备文件名

localFilePath 本地文件路径

返回

成功，返回MV_OK；失败，返回错误码

◆ FileAccessRead() [2/2]

Int32 IParameters.FileAccessRead ( String devFileName,

out Byte [] buffer

)

从设备读取文件，保存在内存

参数

devFileName 设备文件名

buffer 缓存

返回

成功，返回MV_OK；失败，返回错误码

◆ FileAccessWrite() [1/2]

Int32 IParameters.FileAccessWrite ( String deviceFileName,

String localFilePath

)

将文件写入设备

参数

deviceFileName 设备文件名

localFilePath 本地文件路径

返回

成功，返回MV_OK；失败，返回错误码

◆ FileAccessWrite() [2/2]

Int32 IParameters.FileAccessWrite ( String devFileName,

Byte [] buffer

)

将内存中的文件写入设备

参数

devFileName 设备文件名

buffer 缓存

返回

成功，返回MV_OK；失败，返回错误码

◆ GetFileAccessProgress()

Int32 IParameters.GetFileAccessProgress ( out Int64 completed,

out Int64 total

)

获取文件存取的进度

参数

completed 已完成的长度

total 总长度

返回

成功，返回MV_OK；失败，返回错误码

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

类 | 枚举

图像采集

图像采集相关接口和数据结构，用于实现图像采集功能 更多...

类

class StreamExceptionEventArgs

流异常事件 更多...

interface IChunkData

Chunk数据 更多...

interface IChunkInfo

图像帧里面的chunk信息 更多...

interface IImage

提供获取图像缓存、图像属性的接口 更多...

interface IFrameOut

图像数据和帧信息 更多...

class FrameGrabbedEventArgs

采集一帧图像的事件，用于获取图像数据和帧信息 更多...

interface IStreamGrabber

提供取流相关接口 更多...

枚举

enum MvGvspPixelType {

MvGvspPixelType.PixelType_Gvsp_Undefined = -1,

MvGvspPixelType.PixelType_Gvsp_Mono1p = 0x01010037,

MvGvspPixelType.PixelType_Gvsp_Mono2p = 0x01020038,

MvGvspPixelType.PixelType_Gvsp_Mono4p = 0x01040039,

MvGvspPixelType.PixelType_Gvsp_Mono8 = 0x01080001,

MvGvspPixelType.PixelType_Gvsp_Mono8_Signed = 0x01080002,

MvGvspPixelType.PixelType_Gvsp_Mono10 = 0x01100003,

MvGvspPixelType.PixelType_Gvsp_Mono10_Packed = 0x010c0004,

MvGvspPixelType.PixelType_Gvsp_Mono12 = 0x01100005,

MvGvspPixelType.PixelType_Gvsp_Mono12_Packed = 0x010c0006,

MvGvspPixelType.PixelType_Gvsp_Mono14 = 0x01100025,

MvGvspPixelType.PixelType_Gvsp_Mono16 = 0x01100007,

MvGvspPixelType.PixelType_Gvsp_BayerGR8 = 0x01080008,

MvGvspPixelType.PixelType_Gvsp_BayerRG8 = 0x01080009,

MvGvspPixelType.PixelType_Gvsp_BayerGB8 = 0x0108000a,

MvGvspPixelType.PixelType_Gvsp_BayerBG8 = 0x0108000b,

MvGvspPixelType.PixelType_Gvsp_BayerRBGG8 = 0x01080046,

MvGvspPixelType.PixelType_Gvsp_BayerGR10 = 0x0110000c,

MvGvspPixelType.PixelType_Gvsp_BayerRG10 = 0x0110000d,

MvGvspPixelType.PixelType_Gvsp_BayerGB10 = 0x0110000e,

MvGvspPixelType.PixelType_Gvsp_BayerBG10 = 0x0110000f,

MvGvspPixelType.PixelType_Gvsp_BayerGR12 = 0x01100010,

MvGvspPixelType.PixelType_Gvsp_BayerRG12 = 0x01100011,

MvGvspPixelType.PixelType_Gvsp_BayerGB12 = 0x01100012,

MvGvspPixelType.PixelType_Gvsp_BayerBG12 = 0x01100013,

MvGvspPixelType.PixelType_Gvsp_BayerGR10_Packed = 0x010c0026,

MvGvspPixelType.PixelType_Gvsp_BayerRG10_Packed = 0x010c0027,

MvGvspPixelType.PixelType_Gvsp_BayerGB10_Packed = 0x010c0028,

MvGvspPixelType.PixelType_Gvsp_BayerBG10_Packed = 0x010c0029,

MvGvspPixelType.PixelType_Gvsp_BayerGR12_Packed = 0x010c002a,

MvGvspPixelType.PixelType_Gvsp_BayerRG12_Packed = 0x010c002b,

MvGvspPixelType.PixelType_Gvsp_BayerGB12_Packed = 0x010c002c,

MvGvspPixelType.PixelType_Gvsp_BayerBG12_Packed = 0x010c002d,

MvGvspPixelType.PixelType_Gvsp_BayerGR16 = 0x0110002e,

MvGvspPixelType.PixelType_Gvsp_BayerRG16 = 0x0110002f,

MvGvspPixelType.PixelType_Gvsp_BayerGB16 = 0x01100030,

MvGvspPixelType.PixelType_Gvsp_BayerBG16 = 0x01100031,

MvGvspPixelType.PixelType_Gvsp_RGB8_Packed = 0x02180014,

MvGvspPixelType.PixelType_Gvsp_BGR8_Packed = 0x02180015,

MvGvspPixelType.PixelType_Gvsp_RGBA8_Packed = 0x02200016,

MvGvspPixelType.PixelType_Gvsp_BGRA8_Packed = 0x02200017,

MvGvspPixelType.PixelType_Gvsp_RGB10_Packed = 0x02300018,

MvGvspPixelType.PixelType_Gvsp_BGR10_Packed = 0x02300019,

MvGvspPixelType.PixelType_Gvsp_RGB12_Packed = 0x0230001a,

MvGvspPixelType.PixelType_Gvsp_BGR12_Packed = 0x0230001b,

MvGvspPixelType.PixelType_Gvsp_RGB16_Packed = 0x02300033,

MvGvspPixelType.PixelType_Gvsp_BGR16_Packed = 0x0230004b,

MvGvspPixelType.PixelType_Gvsp_RGBA16_Packed = 0x02400040,

MvGvspPixelType.PixelType_Gvsp_BGRA16_Packed = 0x02400051,

MvGvspPixelType.PixelType_Gvsp_RGB10V1_Packed = 0x0220001c,

MvGvspPixelType.PixelType_Gvsp_RGB10V2_Packed = 0x0220001d,

MvGvspPixelType.PixelType_Gvsp_RGB12V1_Packed = 0x02240034,

MvGvspPixelType.PixelType_Gvsp_RGB565_Packed = 0x02100035,

MvGvspPixelType.PixelType_Gvsp_BGR565_Packed = 0x02100036,

MvGvspPixelType.PixelType_Gvsp_YUV411_Packed = 0x020c001e,

MvGvspPixelType.PixelType_Gvsp_YUV422_Packed = 0x0210001f,

MvGvspPixelType.PixelType_Gvsp_YUV422_YUYV_Packed = 0x02100032,

MvGvspPixelType.PixelType_Gvsp_YUV444_Packed = 0x02180020,

MvGvspPixelType.PixelType_Gvsp_YCBCR8_CBYCR = 0x0218003a,

MvGvspPixelType.PixelType_Gvsp_YCBCR422_8 = 0x0210003b,

MvGvspPixelType.PixelType_Gvsp_YCBCR422_8_CBYCRY = 0x02100043,

MvGvspPixelType.PixelType_Gvsp_YCBCR411_8_CBYYCRYY = 0x020c003c,

MvGvspPixelType.PixelType_Gvsp_YCBCR601_8_CBYCR = 0x0218003d,

MvGvspPixelType.PixelType_Gvsp_YCBCR601_422_8 = 0x0210003e,

MvGvspPixelType.PixelType_Gvsp_YCBCR601_422_8_CBYCRY = 0x02100044,

MvGvspPixelType.PixelType_Gvsp_YCBCR601_411_8_CBYYCRYY = 0x020c003f,

MvGvspPixelType.PixelType_Gvsp_YCBCR709_8_CBYCR = 0x02180040,

MvGvspPixelType.PixelType_Gvsp_YCBCR709_422_8 = 0x02100041,

MvGvspPixelType.PixelType_Gvsp_YCBCR709_422_8_CBYCRY = 0x02100045,

MvGvspPixelType.PixelType_Gvsp_YCBCR709_411_8_CBYYCRYY = 0x020c0042,

MvGvspPixelType.PixelType_Gvsp_YUV420SP_NV12 = 0X020c8001,

MvGvspPixelType.PixelType_Gvsp_YUV420SP_NV21 = 0X020c8002,

MvGvspPixelType.PixelType_Gvsp_RGB8_Planar = 0x02180021,

MvGvspPixelType.PixelType_Gvsp_RGB10_Planar = 0x02300022,

MvGvspPixelType.PixelType_Gvsp_RGB12_Planar = 0x02300023,

MvGvspPixelType.PixelType_Gvsp_RGB16_Planar = 0x02300024,

MvGvspPixelType.PixelType_Gvsp_Jpeg = unchecked((Int32)0x80180001),

MvGvspPixelType.PixelType_Gvsp_Coord3D_ABC32f = 0x026000C0,

MvGvspPixelType.PixelType_Gvsp_Coord3D_ABC32f_Planar = 0x026000C1,

MvGvspPixelType.PixelType_Gvsp_Coord3D_AC32f = 0x024000C2,

MvGvspPixelType.PixelType_Gvsp_COORD3D_DEPTH_PLUS_MASK = unchecked((Int32)0x821c0001),

MvGvspPixelType.PixelType_Gvsp_Coord3D_ABC32 = unchecked((Int32)0x82603001),

MvGvspPixelType.PixelType_Gvsp_Coord3D_AB32f = unchecked((Int32)0x82403002),

MvGvspPixelType.PixelType_Gvsp_Coord3D_AB32 = unchecked((Int32)0x82403003),

MvGvspPixelType.PixelType_Gvsp_Coord3D_AC32f_64 = unchecked((Int32)0x024000C2),

MvGvspPixelType.PixelType_Gvsp_Coord3D_AC32f_Planar = 0x024000C3,

MvGvspPixelType.PixelType_Gvsp_Coord3D_AC32 = unchecked((Int32)0x82403004),

MvGvspPixelType.PixelType_Gvsp_Coord3D_A32f = 0x012000BD,

MvGvspPixelType.PixelType_Gvsp_Coord3D_A32 = unchecked((Int32)0x81203005),

MvGvspPixelType.PixelType_Gvsp_Coord3D_C32f = 0x012000BF,

MvGvspPixelType.PixelType_Gvsp_Coord3D_C32 = unchecked((Int32)0x81203006),

MvGvspPixelType.PixelType_Gvsp_Coord3D_ABC16 = 0x023000b9,

MvGvspPixelType.PixelType_Gvsp_Coord3D_C16 = 0x011000b8,

MvGvspPixelType.PixelType_Gvsp_Float32 = unchecked((Int32)0x81200001),

MvGvspPixelType.PixelType_Gvsp_HB_Mono8 = unchecked((Int32)0x81080001),

MvGvspPixelType.PixelType_Gvsp_HB_Mono10 = unchecked((Int32)0x81100003),

MvGvspPixelType.PixelType_Gvsp_HB_Mono10_Packed = unchecked((Int32)0x810c0004),

MvGvspPixelType.PixelType_Gvsp_HB_Mono12 = unchecked((Int32)0x81100005),

MvGvspPixelType.PixelType_Gvsp_HB_Mono12_Packed = unchecked((Int32)0x810c0006),

MvGvspPixelType.PixelType_Gvsp_HB_Mono16 = unchecked((Int32)0x81100007),

MvGvspPixelType.PixelType_Gvsp_HB_BayerGR8 = unchecked((Int32)0x81080008),

MvGvspPixelType.PixelType_Gvsp_HB_BayerRG8 = unchecked((Int32)0x81080009),

MvGvspPixelType.PixelType_Gvsp_HB_BayerGB8 = unchecked((Int32)0x8108000a),

MvGvspPixelType.PixelType_Gvsp_HB_BayerBG8 = unchecked((Int32)0x8108000b),

MvGvspPixelType.PixelType_Gvsp_HB_BayerRBGG8 = unchecked((Int32)0x81080046),

MvGvspPixelType.PixelType_Gvsp_HB_BayerGR10 = unchecked((Int32)0x8110000c),

MvGvspPixelType.PixelType_Gvsp_HB_BayerRG10 = unchecked((Int32)0x8110000d),

MvGvspPixelType.PixelType_Gvsp_HB_BayerGB10 = unchecked((Int32)0x8110000e),

MvGvspPixelType.PixelType_Gvsp_HB_BayerBG10 = unchecked((Int32)0x8110000f),

MvGvspPixelType.PixelType_Gvsp_HB_BayerGR12 = unchecked((Int32)0x81100010),

MvGvspPixelType.PixelType_Gvsp_HB_BayerRG12 = unchecked((Int32)0x81100011),

MvGvspPixelType.PixelType_Gvsp_HB_BayerGB12 = unchecked((Int32)0x81100012),

MvGvspPixelType.PixelType_Gvsp_HB_BayerBG12 = unchecked((Int32)0x81100013),

MvGvspPixelType.PixelType_Gvsp_HB_BayerGR10_Packed = unchecked((Int32)0x810c0026),

MvGvspPixelType.PixelType_Gvsp_HB_BayerRG10_Packed = unchecked((Int32)0x810c0027),

MvGvspPixelType.PixelType_Gvsp_HB_BayerGB10_Packed = unchecked((Int32)0x810c0028),

MvGvspPixelType.PixelType_Gvsp_HB_BayerBG10_Packed = unchecked((Int32)0x810c0029),

MvGvspPixelType.PixelType_Gvsp_HB_BayerGR12_Packed = unchecked((Int32)0x810c002a),

MvGvspPixelType.PixelType_Gvsp_HB_BayerRG12_Packed = unchecked((Int32)0x810c002b),

MvGvspPixelType.PixelType_Gvsp_HB_BayerGB12_Packed = unchecked((Int32)0x810c002c),

MvGvspPixelType.PixelType_Gvsp_HB_BayerBG12_Packed = unchecked((Int32)0x810c002d),

MvGvspPixelType.PixelType_Gvsp_HB_YUV422_Packed = unchecked((Int32)0x8210001f),

MvGvspPixelType.PixelType_Gvsp_HB_YUV422_YUYV_Packed = unchecked((Int32)0x82100032),

MvGvspPixelType.PixelType_Gvsp_HB_RGB8_Packed = unchecked((Int32)0x82180014),

MvGvspPixelType.PixelType_Gvsp_HB_BGR8_Packed = unchecked((Int32)0x82180015),

MvGvspPixelType.PixelType_Gvsp_HB_RGBA8_Packed = unchecked((Int32)0x82200016),

MvGvspPixelType.PixelType_Gvsp_HB_BGRA8_Packed = unchecked((Int32)0x82200017),

MvGvspPixelType.PixelType_Gvsp_HB_RGB16_Packed = unchecked((Int32)0x82300033),

MvGvspPixelType.PixelType_Gvsp_HB_BGR16_Packed = unchecked((Int32)0x8230004B),

MvGvspPixelType.PixelType_Gvsp_HB_RGBA16_Packed = unchecked((Int32)0x82400064),

MvGvspPixelType.PixelType_Gvsp_HB_BGRA16_Packed = unchecked((Int32)0x82400051)

}

像素格式 更多...

enum StreamExceptionType {

StreamExceptionType.AbnormalImage = 0x4001,

StreamExceptionType.ListOverflow = 0x4002,

StreamExceptionType.ListEmpty = 0x4003,

StreamExceptionType.Reconnection = 0x4004,

StreamExceptionType.Disconnection = 0x4005,

StreamExceptionType.DeviceException = 0x4006

}

流异常类型 更多...

enum StreamGrabStrategy {

StreamGrabStrategy.OneByOne = 0,

StreamGrabStrategy.LatestImageOnly = 1,

StreamGrabStrategy.LatestImages = 2,

StreamGrabStrategy.UpcomingImage = 3

}

取流策略 更多...

详细描述

图像采集相关接口和数据结构，用于实现图像采集功能

枚举类型说明

◆ MvGvspPixelType

enum MvGvspPixelType

strong

像素格式

枚举值

PixelType_Gvsp_Undefined 未定义像素格式

PixelType_Gvsp_Mono1p Mono1p

PixelType_Gvsp_Mono2p Mono2p

PixelType_Gvsp_Mono4p Mono4p

PixelType_Gvsp_Mono8 Mono8

PixelType_Gvsp_Mono8_Signed Mono8_Signed

PixelType_Gvsp_Mono10 Mono10

PixelType_Gvsp_Mono10_Packed Mono10_Packed

PixelType_Gvsp_Mono12 Mono12

PixelType_Gvsp_Mono12_Packed Mono12_Packed

PixelType_Gvsp_Mono14 Mono14

PixelType_Gvsp_Mono16 Mono16

PixelType_Gvsp_BayerGR8 BayerGR8

PixelType_Gvsp_BayerRG8 BayerRG8

PixelType_Gvsp_BayerGB8 BayerGB8

PixelType_Gvsp_BayerBG8 BayerBG8

PixelType_Gvsp_BayerRBGG8 BayerRBGG8

PixelType_Gvsp_BayerGR10 BayerGR10

PixelType_Gvsp_BayerRG10 BayerRG10

PixelType_Gvsp_BayerGB10 BayerGB10

PixelType_Gvsp_BayerBG10 BayerBG10

PixelType_Gvsp_BayerGR12 BayerGR12

PixelType_Gvsp_BayerRG12 BayerRG12

PixelType_Gvsp_BayerGB12 BayerGB12

PixelType_Gvsp_BayerBG12 BayerBG12

PixelType_Gvsp_BayerGR10_Packed BayerGR10_Packed

PixelType_Gvsp_BayerRG10_Packed BayerRG10_Packed

PixelType_Gvsp_BayerGB10_Packed BayerGB10_Packed

PixelType_Gvsp_BayerBG10_Packed BayerBG10_Packed

PixelType_Gvsp_BayerGR12_Packed BayerGR12_Packed

PixelType_Gvsp_BayerRG12_Packed BayerRG12_Packed

PixelType_Gvsp_BayerGB12_Packed BayerGB12_Packed

PixelType_Gvsp_BayerBG12_Packed BayerBG12_Packed

PixelType_Gvsp_BayerGR16 BayerGR16

PixelType_Gvsp_BayerRG16 BayerRG16

PixelType_Gvsp_BayerGB16 BayerGB16

PixelType_Gvsp_BayerBG16 BayerBG16

PixelType_Gvsp_RGB8_Packed RGB8_Packed

PixelType_Gvsp_BGR8_Packed BGR8_Packed

PixelType_Gvsp_RGBA8_Packed RGBA8_Packed

PixelType_Gvsp_BGRA8_Packed BGRA8_Packed

PixelType_Gvsp_RGB10_Packed RGB10_Packed

PixelType_Gvsp_BGR10_Packed BGR10_Packed

PixelType_Gvsp_RGB12_Packed RGB12_Packed

PixelType_Gvsp_BGR12_Packed BGR12_Packed

PixelType_Gvsp_RGB16_Packed RGB16_Packed

PixelType_Gvsp_BGR16_Packed BGR16_Packed///

PixelType_Gvsp_RGBA16_Packed RGBA16_Packed

PixelType_Gvsp_BGRA16_Packed BGRA16_Packed

PixelType_Gvsp_RGB10V1_Packed RGB10V1_Packe

PixelType_Gvsp_RGB10V2_Packed RGB10V2_Packed

PixelType_Gvsp_RGB12V1_Packed RGB12V1_Packed

PixelType_Gvsp_RGB565_Packed RGB565_Packed

PixelType_Gvsp_BGR565_Packed BGR565_Packed

PixelType_Gvsp_YUV411_Packed YUV411_Packed

PixelType_Gvsp_YUV422_Packed YUV422_Packed

PixelType_Gvsp_YUV422_YUYV_Packed YUV422_YUYV_Packed

PixelType_Gvsp_YUV444_Packed YUV444_Packed

PixelType_Gvsp_YCBCR8_CBYCR YCBCR8_CBYCR

PixelType_Gvsp_YCBCR422_8 YCBCR422_8

PixelType_Gvsp_YCBCR422_8_CBYCRY YCBCR422_8_CBYCRY

PixelType_Gvsp_YCBCR411_8_CBYYCRYY YCBCR411_8_CBYYCRYY

PixelType_Gvsp_YCBCR601_8_CBYCR YCBCR601_8_CBYCR

PixelType_Gvsp_YCBCR601_422_8 YCBCR601_422_8

PixelType_Gvsp_YCBCR601_422_8_CBYCRY YCBCR601_422_8_CBYCRY

PixelType_Gvsp_YCBCR601_411_8_CBYYCRYY YCBCR601_411_8_CBYYCRYY

PixelType_Gvsp_YCBCR709_8_CBYCR YCBCR709_8_CBYCR

PixelType_Gvsp_YCBCR709_422_8 YCBCR709_422_8

PixelType_Gvsp_YCBCR709_422_8_CBYCRY YCBCR709_422_8_CBYCRY

PixelType_Gvsp_YCBCR709_411_8_CBYYCRYY YCBCR709_411_8_CBYYCRYY

PixelType_Gvsp_YUV420SP_NV12 YUV420SP_NV12

PixelType_Gvsp_YUV420SP_NV21 YUV420SP_NV21

PixelType_Gvsp_RGB8_Planar RGB8_Planar

PixelType_Gvsp_RGB10_Planar RGB10_Planar

PixelType_Gvsp_RGB12_Planar RGB12_Planar

PixelType_Gvsp_RGB16_Planar RGB16_Planar

PixelType_Gvsp_Jpeg Jpeg

PixelType_Gvsp_Coord3D_ABC32f Coord3D_ABC32f

PixelType_Gvsp_Coord3D_ABC32f_Planar Coord3D_ABC32f_Planar

PixelType_Gvsp_Coord3D_AC32f Coord3D_AC32f

PixelType_Gvsp_COORD3D_DEPTH_PLUS_MASK COORD3D_DEPTH_PLUS_MASK

PixelType_Gvsp_Coord3D_ABC32 Coord3D_ABC32

PixelType_Gvsp_Coord3D_AB32f Coord3D_AB32f

PixelType_Gvsp_Coord3D_AB32 Coord3D_AB32

PixelType_Gvsp_Coord3D_AC32f_64 Coord3D_AC32f_64

PixelType_Gvsp_Coord3D_AC32f_Planar Coord3D_AC32f_Planar

PixelType_Gvsp_Coord3D_AC32 Coord3D_AC32

PixelType_Gvsp_Coord3D_A32f Coord3D_A32f

PixelType_Gvsp_Coord3D_A32 Coord3D_A32

PixelType_Gvsp_Coord3D_C32f Coord3D_C32f

PixelType_Gvsp_Coord3D_C32 Coord3D_C32

PixelType_Gvsp_Coord3D_ABC16 Coord3D_ABC16

PixelType_Gvsp_Coord3D_C16 Coord3D_C16

PixelType_Gvsp_Float32 Float32

PixelType_Gvsp_HB_Mono8 HB_Mono8

PixelType_Gvsp_HB_Mono10 HB_Mono10

PixelType_Gvsp_HB_Mono10_Packed HB_Mono10_Packed

PixelType_Gvsp_HB_Mono12 HB_Mono12

PixelType_Gvsp_HB_Mono12_Packed HB_Mono12_Packed

PixelType_Gvsp_HB_Mono16 HB_Mono16

PixelType_Gvsp_HB_BayerGR8 HB_BayerGR8

PixelType_Gvsp_HB_BayerRG8 HB_BayerRG8

PixelType_Gvsp_HB_BayerGB8 HB_BayerGB8

PixelType_Gvsp_HB_BayerBG8 HB_BayerBG8

PixelType_Gvsp_HB_BayerRBGG8 HB_BayerRBGG8

PixelType_Gvsp_HB_BayerGR10 HB_BayerGR10

PixelType_Gvsp_HB_BayerRG10 HB_BayerRG10

PixelType_Gvsp_HB_BayerGB10 HB_BayerGB10

PixelType_Gvsp_HB_BayerBG10 HB_BayerBG10

PixelType_Gvsp_HB_BayerGR12 HB_BayerGR12

PixelType_Gvsp_HB_BayerRG12 HB_BayerRG12

PixelType_Gvsp_HB_BayerGB12 HB_BayerGB12

PixelType_Gvsp_HB_BayerBG12 HB_BayerBG12

PixelType_Gvsp_HB_BayerGR10_Packed HB_BayerGR10_Packed

PixelType_Gvsp_HB_BayerRG10_Packed HB_BayerRG10_Packed

PixelType_Gvsp_HB_BayerGB10_Packed HB_BayerGB10_Packed

PixelType_Gvsp_HB_BayerBG10_Packed HB_BayerBG10_Packed

PixelType_Gvsp_HB_BayerGR12_Packed HB_BayerGR12_Packed

PixelType_Gvsp_HB_BayerRG12_Packed HB_BayerRG12_Packed

PixelType_Gvsp_HB_BayerGB12_Packed HB_BayerGB12_Packed

PixelType_Gvsp_HB_BayerBG12_Packed HB_BayerBG12_Packed

PixelType_Gvsp_HB_YUV422_Packed HB_YUV422_Packed

PixelType_Gvsp_HB_YUV422_YUYV_Packed HB_YUV422_YUYV_Packed

PixelType_Gvsp_HB_RGB8_Packed HB_RGB8_Packed

PixelType_Gvsp_HB_BGR8_Packed HB_BGR8_Packed

PixelType_Gvsp_HB_RGBA8_Packed HB_RGBA8_Packed

PixelType_Gvsp_HB_BGRA8_Packed HB_BGRA8_Packed

PixelType_Gvsp_HB_RGB16_Packed HB_RGB16_Packed

PixelType_Gvsp_HB_BGR16_Packed HB_BGR16_Packed

PixelType_Gvsp_HB_RGBA16_Packed HB_RGBA16_Packed

PixelType_Gvsp_HB_BGRA16_Packed HB_BGRA16_Packed

◆ StreamExceptionType

enum StreamExceptionType

strong

流异常类型

枚举值

AbnormalImage 异常的图像，该帧被丢弃

ListOverflow 缓存列表溢出，清除最旧的一帧

ListEmpty 缓存列表为空，该帧被丢弃

Reconnection 断流恢复

Disconnection 断流,恢复失败,取流被中止

DeviceException 设备异常,取流被中止

◆ StreamGrabStrategy

enum StreamGrabStrategy

strong

取流策略

枚举值

OneByOne 从旧到新一帧一帧的获取图像（默认为该策略）

LatestImageOnly 获取列表中最新的一帧图像，同时清除列表中的其余图像

LatestImages 从输出缓存列表中获取最新的OutputQueueSize帧图像，其中OutputQueueSize范围为1-ImageNodeNum，可通过 SetOutputQueueSize() 设置。 ImageNodeNum 默认为1，可调用 SetImageNodeNum() 设置。 OutputQueueSize 设置成1等同于 LatestImagesOnly 策略，OutputQueueSize设置成ImageNodeNum等同于OneByOne策略。

UpcomingImage 在调用取流接口时忽略输出缓存列表中所有图像，并等待设备即将生成的一帧图像。该策略只支持GigE设备，不支持U3V设备

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

StreamExceptionEventArgs类 参考 图像采集

流异常事件 更多...

继承自 EventArgs .

属性

StreamExceptionType StreamException [get]

流异常类型 更多...

详细描述

流异常事件

属性说明

◆ StreamException

StreamExceptionType StreamExceptionEventArgs.StreamException

get

流异常类型

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IChunkData接口 参考 图像采集

Chunk数据 更多...

属性

IntPtr DataPtr [get]

Chunk数据指针（非托管内存） 更多...

Byte [] Data [get]

Chunk数据，内部会进行一次拷贝，将非托管内存拷贝到托管内存 更多...

UInt32 ChunkID [get]

ChunkID 更多...

UInt32 Length [get]

Chunk数据长度 更多...

详细描述

Chunk数据

属性说明

◆ DataPtr

IntPtr IChunkData.DataPtr

get

Chunk数据指针（非托管内存）

◆ Data

Byte [] IChunkData.Data

get

Chunk数据，内部会进行一次拷贝，将非托管内存拷贝到托管内存

◆ ChunkID

UInt32 IChunkData.ChunkID

get

ChunkID

◆ Length

UInt32 IChunkData.Length

get

Chunk数据长度

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IChunkInfo接口 参考 图像采集

图像帧里面的chunk信息 更多...

继承自 IEnumerable< IChunkData > .

属性

IChunkData this[UInt32 ChunkID] [get]

通过ChunkID获取对应的ChunkData 更多...

详细描述

图像帧里面的chunk信息

属性说明

◆ this[UInt32 ChunkID]

IChunkData IChunkInfo.this[UInt32 ChunkID]

get

通过ChunkID获取对应的ChunkData

参数

ChunkID

返回

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | 属性 | 所有成员列表

IImage接口 参考 图像采集

提供获取图像缓存、图像属性的接口 更多...

继承自 ICloneable , 以及 IDisposable .

Public 成员函数

Bitmap ToBitmap ()

转换为Bitmap 更多...

属性

IntPtr PixelDataPtr [get]

图像数据指针（取流接口返回的Image数据是非托管内存） 更多...

Byte [] PixelData [get]

图像数据（如果图像数据是非托管内存，内部会进行一次拷贝，将非托管内存拷贝到托管内存 ） 更多...

UInt32 Width [get]

图像宽度 更多...

UInt32 Height [get]

图像高度 更多...

MvGvspPixelType PixelType [get]

像素格式 更多...

UInt64 ImageSize [get]

图像大小 更多...

详细描述

提供获取图像缓存、图像属性的接口

成员函数说明

◆ ToBitmap()

Bitmap IImage.ToBitmap ( )

转换为Bitmap

返回

Bitmap对象，失败返回null

属性说明

◆ PixelDataPtr

IntPtr IImage.PixelDataPtr

get

图像数据指针（取流接口返回的Image数据是非托管内存）

◆ PixelData

Byte [] IImage.PixelData

get

图像数据（如果图像数据是非托管内存，内部会进行一次拷贝，将非托管内存拷贝到托管内存 ）

◆ Width

UInt32 IImage.Width

get

图像宽度

◆ Height

UInt32 IImage.Height

get

图像高度

◆ PixelType

MvGvspPixelType IImage.PixelType

get

像素格式

◆ ImageSize

UInt64 IImage.ImageSize

get

图像大小

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IFrameOut接口 参考 图像采集

图像数据和帧信息 更多...

继承自 IDisposable , 以及 ICloneable .

属性

IImage Image [get]

图像数据 更多...

UInt32 FrameNum [get]

帧号 更多...

UInt64 DevTimeStamp [get]

设备时间戳 更多...

UInt64 HostTimeStamp [get]

主机时间戳 更多...

UInt64 FrameLen [get]

帧长度 更多...

UInt32 SecondCount [get]

设备水印时标 更多...

UInt32 CycleCount [get]

周期数 更多...

UInt32 CycleOffset [get]

周期偏移量 更多...

float Gain [get]

增益 更多...

float ExposureTime [get]

曝光时间 更多...

UInt32 AverageBrightness [get]

平均亮度 更多...

UInt32 Red [get]

白平衡红色通道 更多...

UInt32 Green [get]

白平衡绿色通道 更多...

UInt32 Blue [get]

白平衡蓝色通道 更多...

UInt32 FrameCount [get]

总帧数 更多...

UInt32 TriggerIndex [get]

触发计数 更多...

UInt32 Input [get]

输入 更多...

UInt32 Output [get]

输出 更多...

UInt32 OffsetX [get]

ROI区域，水平偏移量 更多...

UInt32 OffsetY [get]

ROI区域，垂直偏移量 更多...

UInt32 LostPacket [get]

本帧丢包数 更多...

IChunkInfo ChunkInfo [get]

Chunk数据 更多...

详细描述

图像数据和帧信息

属性说明

◆ Image

IImage IFrameOut.Image

get

图像数据

◆ FrameNum

UInt32 IFrameOut.FrameNum

get

帧号

◆ DevTimeStamp

UInt64 IFrameOut.DevTimeStamp

get

设备时间戳

◆ HostTimeStamp

UInt64 IFrameOut.HostTimeStamp

get

主机时间戳

◆ FrameLen

UInt64 IFrameOut.FrameLen

get

帧长度

◆ SecondCount

UInt32 IFrameOut.SecondCount

get

设备水印时标

◆ CycleCount

UInt32 IFrameOut.CycleCount

get

周期数

◆ CycleOffset

UInt32 IFrameOut.CycleOffset

get

周期偏移量

◆ Gain

float IFrameOut.Gain

get

增益

◆ ExposureTime

float IFrameOut.ExposureTime

get

曝光时间

◆ AverageBrightness

UInt32 IFrameOut.AverageBrightness

get

平均亮度

◆ Red

UInt32 IFrameOut.Red

get

白平衡红色通道

◆ Green

UInt32 IFrameOut.Green

get

白平衡绿色通道

◆ Blue

UInt32 IFrameOut.Blue

get

白平衡蓝色通道

◆ FrameCount

UInt32 IFrameOut.FrameCount

get

总帧数

◆ TriggerIndex

UInt32 IFrameOut.TriggerIndex

get

触发计数

◆ Input

UInt32 IFrameOut.Input

get

输入

◆ Output

UInt32 IFrameOut.Output

get

输出

◆ OffsetX

UInt32 IFrameOut.OffsetX

get

ROI区域，水平偏移量

◆ OffsetY

UInt32 IFrameOut.OffsetY

get

ROI区域，垂直偏移量

◆ LostPacket

UInt32 IFrameOut.LostPacket

get

本帧丢包数

◆ ChunkInfo

IChunkInfo IFrameOut.ChunkInfo

get

Chunk数据

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

FrameGrabbedEventArgs类 参考 图像采集

采集一帧图像的事件，用于获取图像数据和帧信息 更多...

继承自 EventArgs .

属性

IFrameOut FrameOut [get]

图像帧信息 更多...

详细描述

采集一帧图像的事件，用于获取图像数据和帧信息

属性说明

◆ FrameOut

IFrameOut FrameGrabbedEventArgs.FrameOut

get

图像帧信息

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | 事件 | 所有成员列表

IStreamGrabber接口 参考 图像采集

提供取流相关接口 更多...

Public 成员函数

Int32 SetImageNodeNum (UInt32 num)

设置SDK内部图像缓存节点个数，大于等于1，在 IStreamGrabber.StartGrabbing() 前调用 更多...

Int32 GetValidImageNum (out UInt32 num)

获取当前图像缓存区的有效图像个数 更多...

Int32 StartGrabbing ()

开始取流 更多...

Int32 StartGrabbing (StreamGrabStrategy strategy)

开始取流，支持设置取流策略 更多...

Int32 SetOutputQueueSize (UInt32 size)

设置输出缓存个数 更多...

Int32 StopGrabbing ()

停止取流 更多...

Int32 GetImageBuffer (UInt32 timeoutInMS, out IFrameOut frameOut)

获取一帧图像 更多...

Int32 FreeImageBuffer (IFrameOut frame)

释放图像缓存（此接口用于释放不再使用的图像缓存，与 IStreamGrabber.GetImageBuffer() 配套使用） 更多...

Int32 ClearImageBuffer ()

清除取流数据缓存 更多...

事件

EventHandler< StreamExceptionEventArgs > StreamExceptionEvent

设备流异常事件，只有USB设备支持 更多...

EventHandler< FrameGrabbedEventArgs > FrameGrabedEvent

采集一帧图像的事件，获取图像数据 更多...

详细描述

提供取流相关接口

成员函数说明

◆ SetImageNodeNum()

Int32 IStreamGrabber.SetImageNodeNum ( UInt32 num )

设置SDK内部图像缓存节点个数，大于等于1，在 IStreamGrabber.StartGrabbing() 前调用

参数

num 缓存节点个数

返回

成功，返回MV_OK；失败，返回错误码

注意

调用该接口可以设置SDK内部图像缓存节点个数，在调用 IStreamGrabber.StartGrabbing() 开始抓图前调用。 在SDK中默认是1个节点。

◆ GetValidImageNum()

Int32 IStreamGrabber.GetValidImageNum ( out UInt32 num )

获取当前图像缓存区的有效图像个数

参数

num 有效图像个数

返回

成功，返回MV_OK；失败，返回错误码

◆ StartGrabbing() [1/2]

Int32 IStreamGrabber.StartGrabbing ( )

开始取流

返回

成功，返回MV_OK；失败，返回错误码

◆ StartGrabbing() [2/2]

Int32 IStreamGrabber.StartGrabbing ( StreamGrabStrategy strategy )

开始取流，支持设置取流策略

参数

strategy 策略枚举值

返回

成功，返回MV_OK；失败，返回错误码

◆ SetOutputQueueSize()

Int32 IStreamGrabber.SetOutputQueueSize ( UInt32 size )

设置输出缓存个数

注意

仅在 StreamGrabStrategy.LatestImages 策略下才有效，范围：1-ImageNodeNum

参数

size 输出缓存个数

返回

成功，返回MV_OK；失败，返回错误码

◆ StopGrabbing()

Int32 IStreamGrabber.StopGrabbing ( )

停止取流

返回

成功，返回MV_OK；失败，返回错误码

◆ GetImageBuffer()

Int32 IStreamGrabber.GetImageBuffer ( UInt32 timeoutInMS,

out IFrameOut frameOut

)

获取一帧图像

参数

timeoutInMS 等待超时时间

frameOut 图像数据和图像信息

返回

成功，返回MV_OK；失败，返回错误码

◆ FreeImageBuffer()

Int32 IStreamGrabber.FreeImageBuffer ( IFrameOut frame )

释放图像缓存（此接口用于释放不再使用的图像缓存，与 IStreamGrabber.GetImageBuffer() 配套使用）

参数

frame 图像数据和图像数据

返回

成功，返回MV_OK；失败，返回错误码

◆ ClearImageBuffer()

Int32 IStreamGrabber.ClearImageBuffer ( )

清除取流数据缓存

返回

成功，返回MV_OK；失败，返回错误码

注解

该接口允许用户不停止取流的情况下清除缓存中不需要的图像。

该接口在连续模式切触发模式后，可以清除历史数据。

事件说明

◆ StreamExceptionEvent

EventHandler<StreamExceptionEventArgs> IStreamGrabber.StreamExceptionEvent

设备流异常事件，只有USB设备支持

注意

在 IStreamGrabber.StartGrabbing() 前调用

◆ FrameGrabedEvent

EventHandler<FrameGrabbedEventArgs> IStreamGrabber.FrameGrabedEvent

采集一帧图像的事件，获取图像数据

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

类 | 枚举

图像渲染

图像渲染相关接口和数据结构，用于实现将获取到的图像显示在您的程序上 更多...

类

struct MvColor

颜色 更多...

struct MvRect

矩形 更多...

struct MvPoint

点 更多...

struct MvCircle

圆形 更多...

struct MvLine

线条 更多...

interface IImageRender

提供图像渲染、图形绘制接口 更多...

枚举

enum RenderMode {

RenderMode.Default = 0,

RenderMode.D3D = 1,

RenderMode.OPENGL = 2

}

图像渲染模式 更多...

详细描述

图像渲染相关接口和数据结构，用于实现将获取到的图像显示在您的程序上

枚举类型说明

◆ RenderMode

enum RenderMode

strong

图像渲染模式

枚举值

Default 默认模式，Windows：GDI，Linux：OpenGL

D3D Direct3D，只支持Windows

OPENGL OpenGL，只支持Windows

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | Public 属性 | 所有成员列表

MvColor结构体 参考 图像渲染

颜色 更多...

Public 成员函数

MvColor (float r, float g, float b, float alpha)

构造函数 更多...

Public 属性

float R

红色，根据像素颜色的相对深度，范围为[0.0 , 1.0]，代表着[0, 255]的颜色深度 更多...

float G

绿色，根据像素颜色的相对深度，范围为[0.0 , 1.0]，代表着[0, 255]的颜色深度 更多...

float B

蓝色，根据像素颜色的相对深度，范围为[0.0 , 1.0]，代表着[0, 255]的颜色深度 更多...

float Alpha

透明度，根据像素颜色的相对透明度，范围为[0.0 , 1.0] （此参数功能暂不支持） 更多...

详细描述

颜色

构造及析构函数说明

◆ MvColor()

MvColor.MvColor ( float r,

float g,

float b,

float alpha

)

构造函数

参数

r 红色，根据像素颜色的相对深度，范围为[0.0 , 1.0]，代表着[0, 255]的颜色深度

g 绿色，根据像素颜色的相对深度，范围为[0.0 , 1.0]，代表着[0, 255]的颜色深度

b 蓝色，根据像素颜色的相对深度，范围为[0.0 , 1.0]，代表着[0, 255]的颜色深度

alpha 透明度，根据像素颜色的相对透明度，范围为[0.0 , 1.0] （此参数功能暂不支持）

类成员变量说明

◆ R

float MvColor.R

红色，根据像素颜色的相对深度，范围为[0.0 , 1.0]，代表着[0, 255]的颜色深度

◆ G

float MvColor.G

绿色，根据像素颜色的相对深度，范围为[0.0 , 1.0]，代表着[0, 255]的颜色深度

◆ B

float MvColor.B

蓝色，根据像素颜色的相对深度，范围为[0.0 , 1.0]，代表着[0, 255]的颜色深度

◆ Alpha

float MvColor.Alpha

透明度，根据像素颜色的相对透明度，范围为[0.0 , 1.0] （此参数功能暂不支持）

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | Public 属性 | 所有成员列表

MvRect结构体 参考 图像渲染

矩形 更多...

Public 成员函数

MvRect (float top, float bottom, float left, float right)

构造函数 更多...

Public 属性

float Top

矩形上边缘距离图像上边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0] 更多...

float Bottom

矩形下边缘距离图像下边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0] 更多...

float Left

矩形左边缘距离图像左边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0] 更多...

float Right

矩形右边缘距离图像右边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0] 更多...

详细描述

矩形

构造及析构函数说明

◆ MvRect()

MvRect.MvRect ( float top,

float bottom,

float left,

float right

)

构造函数

参数

top 矩形上边缘距离图像上边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]

bottom 矩形下边缘距离图像下边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]

left 矩形左边缘距离图像左边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]

right 矩形右边缘距离图像右边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]

类成员变量说明

◆ Top

float MvRect.Top

矩形上边缘距离图像上边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]

◆ Bottom

float MvRect.Bottom

矩形下边缘距离图像下边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]

◆ Left

float MvRect.Left

矩形左边缘距离图像左边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]

◆ Right

float MvRect.Right

矩形右边缘距离图像右边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | Public 属性 | 所有成员列表

MvPoint结构体 参考 图像渲染

点 更多...

Public 成员函数

MvPoint (float x, float y)

构造函数 更多...

Public 属性

float X

该点距离图像左边缘距离，根据图像的相对位置，范围为[0.0 , 1.0] 更多...

float Y

该点距离图像上边缘距离，根据图像的相对位置，范围为[0.0 , 1.0] 更多...

详细描述

点

构造及析构函数说明

◆ MvPoint()

MvPoint.MvPoint ( float x,

float y

)

构造函数

参数

x 该点距离图像左边缘距离，根据图像的相对位置，范围为[0.0 , 1.0]

y 该点距离图像上边缘距离，根据图像的相对位置，范围为[0.0 , 1.0]

类成员变量说明

◆ X

float MvPoint.X

该点距离图像左边缘距离，根据图像的相对位置，范围为[0.0 , 1.0]

◆ Y

float MvPoint.Y

该点距离图像上边缘距离，根据图像的相对位置，范围为[0.0 , 1.0]

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | Public 属性 | 所有成员列表

MvCircle结构体 参考 图像渲染

圆形 更多...

Public 成员函数

MvCircle (MvPoint centerPoint, float r1, float r2)

构造函数 更多...

Public 属性

MvPoint CenterPoint

圆心 更多...

float R1

宽向半径，根据图像的相对位置[0, 1.0]，半径与圆心的位置有关，需保证画出的圆在显示框范围之内，否则报错 更多...

float R2

高向半径，根据图像的相对位置[0, 1.0]，半径与圆心的位置有关，需保证画出的圆在显示框范围之内，否则报错 更多...

详细描述

圆形

构造及析构函数说明

◆ MvCircle()

MvCircle.MvCircle ( MvPoint centerPoint,

float r1,

float r2

)

构造函数

参数

centerPoint 圆心

r1 宽向半径，根据图像的相对位置[0, 1.0]，半径与圆心的位置有关，需保证画出的圆在显示框范围之内，否则报错

r2 高向半径，根据图像的相对位置[0, 1.0]，半径与圆心的位置有关，需保证画出的圆在显示框范围之内，否则报错

类成员变量说明

◆ CenterPoint

MvPoint MvCircle.CenterPoint

圆心

◆ R1

float MvCircle.R1

宽向半径，根据图像的相对位置[0, 1.0]，半径与圆心的位置有关，需保证画出的圆在显示框范围之内，否则报错

◆ R2

float MvCircle.R2

高向半径，根据图像的相对位置[0, 1.0]，半径与圆心的位置有关，需保证画出的圆在显示框范围之内，否则报错

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 属性 | 所有成员列表

MvLine结构体 参考 图像渲染

线条 更多...

Public 属性

MvPoint StartPoint

线条的起始点坐标 更多...

MvPoint EndPoint

线条的终点坐标 更多...

详细描述

线条

类成员变量说明

◆ StartPoint

MvPoint MvLine.StartPoint

线条的起始点坐标

◆ EndPoint

MvPoint MvLine.EndPoint

线条的终点坐标

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | 所有成员列表

IImageRender接口 参考 图像渲染

提供图像渲染、图形绘制接口 更多...

Public 成员函数

Int32 DisplayOneFrame (IntPtr hWnd, IImage image, RenderMode mode=RenderMode.Default)

显示一帧图像 更多...

Int32 DisplayOneFrame (IntPtr hWnd, IntPtr imageDataPtr, UInt32 imageLen, UInt32 width, UInt32 height, MvGvspPixelType PixelType, RenderMode mode=RenderMode.Default)

显示一帧图像 更多...

Int32 DrawRect (MvRect rect, MvColor color, UInt32 lineWidth)

在图像上绘制矩形 更多...

Int32 DrawCircle (MvCircle circle, MvColor color, UInt32 lineWidth)

在图像上绘制圆形 更多...

Int32 DrawLine (MvLine line, MvColor color, UInt32 lineWidth)

在图像上绘制线条 更多...

详细描述

提供图像渲染、图形绘制接口

成员函数说明

◆ DisplayOneFrame() [1/2]

Int32 IImageRender.DisplayOneFrame ( IntPtr hWnd,

IImage image,

RenderMode mode = RenderMode.Default

)

显示一帧图像

参数

hWnd 窗口句柄

image 图像信息

mode 渲染模式

返回

成功，返回MV_OK；失败，返回错误码

渲染方式可选择GDI或D3D，默认选择为GDI模式。渲染引擎仅在客户端不连接相机的情况下可以进行设置。GDI模式对电脑的显卡性能没有要求，适用于所有电脑。 D3D模式适用于安装显卡驱动且显卡内存大于1GB的电脑，该模式下客户端预览的图像效果会优于GDI模式下的图像效果。

◆ DisplayOneFrame() [2/2]

Int32 IImageRender.DisplayOneFrame ( IntPtr hWnd,

IntPtr imageDataPtr,

UInt32 imageLen,

UInt32 width,

UInt32 height,

MvGvspPixelType PixelType,

RenderMode mode = RenderMode.Default

)

显示一帧图像

参数

hWnd 窗口句柄

imageDataPtr 图像数据指针

imageLen 图像数据长度

width 图像宽

height 图像高

PixelType 像素格式

mode 渲染模式

返回

成功，返回MV_OK；失败，返回错误码

渲染方式可选择GDI或D3D，默认选择为GDI模式。渲染引擎仅在客户端不连接相机的情况下可以进行设置。GDI模式对电脑的显卡性能没有要求，适用于所有电脑。 D3D模式适用于安装显卡驱动且显卡内存大于1GB的电脑，该模式下客户端预览的图像效果会优于GDI模式下的图像效果。

◆ DrawRect()

Int32 IImageRender.DrawRect ( MvRect rect,

MvColor color,

UInt32 lineWidth

)

在图像上绘制矩形

参数

rect 矩形框

color 线条颜色

lineWidth 线条宽度，只能是1或2

返回

成功，返回MV_OK；失败，返回错误码

◆ DrawCircle()

Int32 IImageRender.DrawCircle ( MvCircle circle,

MvColor color,

UInt32 lineWidth

)

在图像上绘制圆形

参数

circle 圆形信息

color 线条颜色

lineWidth 线条宽度，只能是1或2

返回

成功，返回MV_OK；失败，返回错误码

◆ DrawLine()

Int32 IImageRender.DrawLine ( MvLine line,

MvColor color,

UInt32 lineWidth

)

在图像上绘制线条

参数

line 线条信息

color 线条颜色

lineWidth 线条宽度，只能是1或2

返回

成功，返回MV_OK；失败，返回错误码

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

类 | 枚举

图像处理

图像处理相关接口和数据结构，用于实现图像解码、图像旋转、对比度调整等图像处理功能 更多...

类

interface IImageDecoder

图像解码 更多...

interface IImageProcess

提供图像处理相关接口，比如旋转、翻转、对比度、饱和度等 更多...

struct ImageFormatInfo

图像格式信息 更多...

interface IImageSaver

提供保存图像数据到文件的接口，支持BMP、JPG、PNG、TIFF格式图像 更多...

struct GammaParam

Gamma参数 更多...

struct CCMParam

CCM参数 更多...

interface IPixelTypeConverter

提供像素格式转换相关接口 更多...

struct RecordParam

录像参数 更多...

interface IVideoRecorder

录像,将图片录制成AVI格式视频 更多...

枚举

enum ImageRotateAngle {

ImageRotateAngle.R90 = 1,

ImageRotateAngle.R180 = 2,

ImageRotateAngle.R270 = 3

}

图像旋转角度 更多...

enum ImageFlipType {

ImageFlipType.Vertical = 1,

ImageFlipType.Horizontal = 2

}

图像翻转类型 更多...

enum ImageReconstructionMethod { ImageReconstructionMethod.SplitByLine = 1 }

图像重构方式 更多...

enum ImageStitchingMethod { ImageStitchingMethod.Vertical = 1 }

图像拼接方式 更多...

enum ImageFormatType {

ImageFormatType.Bmp = 1,

ImageFormatType.Jpeg = 2,

ImageFormatType.Png = 3,

ImageFormatType.Tiff = 4

}

图像格式 更多...

enum CFAMethod {

CFAMethod.Fast = 0,

CFAMethod.Equilibrated = 1,

CFAMethod.Optimal = 2,

CFAMethod.OptimalPlus = 3

}

图像插值算法类型 更多...

enum GammaType {

GammaType.None = 0,

GammaType.Value = 1,

GammaType.UserCurve = 2,

GammaType.LRGB2SRGB = 3,

GammaType.SRGB2LRGB = 4

}

Gamma类型 更多...

enum VideoFormatType { VideoFormatType.AVI = 1 }

视频格式 更多...

详细描述

图像处理相关接口和数据结构，用于实现图像解码、图像旋转、对比度调整等图像处理功能

枚举类型说明

◆ ImageRotateAngle

enum ImageRotateAngle

strong

图像旋转角度

枚举值

R90 90度

R180 180度

R270 270度

◆ ImageFlipType

enum ImageFlipType

strong

图像翻转类型

枚举值

Vertical 垂直翻转

Horizontal 水平翻转

◆ ImageReconstructionMethod

enum ImageReconstructionMethod

strong

图像重构方式

枚举值

SplitByLine 源图像按行拆分成多张图像

◆ ImageStitchingMethod

enum ImageStitchingMethod

strong

图像拼接方式

枚举值

Vertical 垂直方向拼接

◆ ImageFormatType

enum ImageFormatType

strong

图像格式

枚举值

Bmp BMP图像格式

Jpeg JPEG图像格式

Png PNG图像格式

Tiff TIFF图像格式

◆ CFAMethod

enum CFAMethod

strong

图像插值算法类型

枚举值

Fast 快速

Equilibrated 均衡

Optimal 最优

OptimalPlus 最优+

◆ GammaType

enum GammaType

strong

Gamma类型

枚举值

None 不启用

Value Gamma值

UserCurve Gamma曲线

8位，长度：256*sizeof(unsigned char)

10位，长度：1024*sizeof(unsigned short)

12位，长度：4096*sizeof(unsigned short)

16位，长度：65536*sizeof(unsigned short)

LRGB2SRGB linear RGB to sRGB

SRGB2LRGB sRGB to linear RGB（仅色彩插值时支持，色彩校正时无效）

◆ VideoFormatType

enum VideoFormatType

strong

视频格式

枚举值

AVI AVI格式

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | 所有成员列表

IImageDecoder接口 参考 图像处理

图像解码 更多...

Public 成员函数

Int32 HBDecode (IFrameOut inFrameInfo, out IFrameOut outFrameInfo)

无损解码 更多...

详细描述

图像解码

成员函数说明

◆ HBDecode()

Int32 IImageDecoder.HBDecode ( IFrameOut inFrameInfo,

out IFrameOut outFrameInfo

)

无损解码

参数

inFrameInfo 输入图像及帧信息

outFrameInfo 输出图像及帧信息

返回

成功，返回MV_OK；失败，返回错误码

将从相机中取到的无损压缩码流解码成裸数据，同时支持解析当前相机实时图像的水印信息。

注意

若输入的无损码流不是当前相机采集或并非实时码流，则水印解析可能异常。

若解码失败，请检查以下情况： 确认CPU是否支持 SSE AVX指令集（需要支持）

确认当前帧是否异常（丢包等），若异常则可能导致解码失败

确认当前相机出图是否异常。若相机出图异常，即使不丢包，也将解码失败

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | 所有成员列表

IImageProcess接口 参考 图像处理

提供图像处理相关接口，比如旋转、翻转、对比度、饱和度等 更多...

Public 成员函数

Int32 RotateImage (IImage inImage, out IImage outImage, ImageRotateAngle angle)

图像旋转 更多...

Int32 FlipImage (IImage inImage, out IImage outImage, ImageFlipType flipType)

图像翻转 更多...

Int32 ImageContrast (IImage inImage, out IImage outImage, UInt32 contrastFactor)

图像对比度调节 更多...

Int32 ReconstructImage (IImage inImage, UInt32 exposureNum, ImageReconstructionMethod method, ImageStitchingMethod imageStitchingMethod, out IImage outImage)

重构图像（用于分时曝光功能，图像拆分后再拼接） 更多...

详细描述

提供图像处理相关接口，比如旋转、翻转、对比度、饱和度等

成员函数说明

◆ RotateImage()

Int32 IImageProcess.RotateImage ( IImage inImage,

out IImage outImage,

ImageRotateAngle angle

)

图像旋转

参数

inImage 输入图像

outImage 输出图像。图像使用完之后需调用Dispose方法及时释放内存，防止内存快速上涨。

angle 旋转角度

返回

成功，返回MV_OK；失败，返回错误码

注意

该接口只支持MONO8/RGB24/BGR24格式数据的90/180/270度旋转。

◆ FlipImage()

Int32 IImageProcess.FlipImage ( IImage inImage,

out IImage outImage,

ImageFlipType flipType

)

图像翻转

参数

inImage 输入图像

outImage 输出图像。图像使用完之后需调用Dispose方法及时释放内存，防止内存快速上涨。

flipType 翻转类型

返回

成功，返回MV_OK；失败，返回错误码

注意

该接口只支持MONO8/RGB24/BGR24格式数据的垂直和水平翻转。

◆ ImageContrast()

Int32 IImageProcess.ImageContrast ( IImage inImage,

out IImage outImage,

UInt32 contrastFactor

)

图像对比度调节

参数

inImage 输入图像

outImage 输出图像。图像使用完之后需调用Dispose方法及时释放内存，防止内存快速上涨。

contrastFactor 对比度值，[1, 10000]

返回

成功，返回MV_OK；失败，返回错误码

◆ ReconstructImage()

Int32 IImageProcess.ReconstructImage ( IImage inImage,

UInt32 exposureNum,

ImageReconstructionMethod method,

ImageStitchingMethod imageStitchingMethod,

out IImage outImage

)

重构图像（用于分时曝光功能，图像拆分后再拼接）

参数

inImage 输入图像

exposureNum 曝光个数(1-8]

method 图像重构的方式

imageStitchingMethod 图像拼接的方式

outImage 输出图像。图像使用完之后需调用Dispose方法及时释放内存，防止内存快速上涨。

返回

成功，返回MV_OK；失败，返回错误码

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 属性 | 所有成员列表

ImageFormatInfo结构体 参考 图像处理

图像格式信息 更多...

Public 属性

ImageFormatType FormatType

图像格式 更多...

UInt32 JpegQuality

JPEG编码质量(50-99]，其他格式无效 更多...

详细描述

图像格式信息

类成员变量说明

◆ FormatType

ImageFormatType ImageFormatInfo.FormatType

图像格式

◆ JpegQuality

UInt32 ImageFormatInfo.JpegQuality

JPEG编码质量(50-99]，其他格式无效

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | 所有成员列表

IImageSaver接口 参考 图像处理

提供保存图像数据到文件的接口，支持BMP、JPG、PNG、TIFF格式图像 更多...

Public 成员函数

Int32 SaveImageToFile (String filePath, IImage image, ImageFormatInfo imageFormatInfo, CFAMethod cfaMethod)

保存图像到文件，支持BMP、JPG、PNG、TIFF格式图像 更多...

Int32 SaveImageToBuffer (Byte[] buffer, out UInt32 dataLen, IImage image, ImageFormatInfo imageFormatInfo, CFAMethod cfaMethod)

保存图像到缓存，支持BMP、JPG格式图像 更多...

详细描述

提供保存图像数据到文件的接口，支持BMP、JPG、PNG、TIFF格式图像

成员函数说明

◆ SaveImageToFile()

Int32 IImageSaver.SaveImageToFile ( String filePath,

IImage image,

ImageFormatInfo imageFormatInfo,

CFAMethod cfaMethod

)

保存图像到文件，支持BMP、JPG、PNG、TIFF格式图像

参数

filePath 文件路径

image 图像数据

imageFormatInfo 图像格式信息

cfaMethod 图像插值方法

返回

成功，返回MV_OK；失败，返回错误码

◆ SaveImageToBuffer()

Int32 IImageSaver.SaveImageToBuffer ( Byte [] buffer,

out UInt32 dataLen,

IImage image,

ImageFormatInfo imageFormatInfo,

CFAMethod cfaMethod

)

保存图像到缓存，支持BMP、JPG格式图像

参数

buffer 图像缓存

dataLen 转换后的图像数据长度

image 图像数据

imageFormatInfo 图像格式信息

cfaMethod 图像插值方法

返回

成功，返回MV_OK；失败，返回错误码

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 属性 | 所有成员列表

GammaParam结构体 参考 图像处理

Gamma参数 更多...

Public 属性

GammaType Type

Gamma类型 更多...

float Value

Gamma值[0.1, 4.0] 更多...

Byte [] CurveBuf

Gamma曲线缓存 更多...

UInt32 CurveLen

Gamma曲线长度 更多...

详细描述

Gamma参数

类成员变量说明

◆ Type

GammaType GammaParam.Type

Gamma类型

◆ Value

float GammaParam.Value

Gamma值[0.1, 4.0]

◆ CurveBuf

Byte [] GammaParam.CurveBuf

Gamma曲线缓存

◆ CurveLen

UInt32 GammaParam.CurveLen

Gamma曲线长度

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 属性 | 所有成员列表

CCMParam结构体 参考 图像处理

CCM参数 更多...

Public 属性

bool CCMEnable

是否启用CCM 更多...

Int32 [] CCMat

CCM矩阵[-65536~65536],必须是Int32[9] 更多...

UInt32 CCMScale

量化系数（2的整数幂，最大65536） 更多...

详细描述

CCM参数

类成员变量说明

◆ CCMEnable

bool CCMParam.CCMEnable

是否启用CCM

◆ CCMat

Int32 [] CCMParam.CCMat

CCM矩阵[-65536~65536],必须是Int32[9]

◆ CCMScale

UInt32 CCMParam.CCMScale

量化系数（2的整数幂，最大65536）

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | 所有成员列表

IPixelTypeConverter接口 参考 图像处理

提供像素格式转换相关接口 更多...

Public 成员函数

Int32 SetBayerCvtQuality (CFAMethod method)

设置图像插值算法类型 更多...

Int32 SetBayerFilterEnable (bool enable)

插值算法平滑使能设置 更多...

Int32 SetBayerGammaValue (float gammaValue)

设置Bayer格式的Gamma值 更多...

Int32 SetGammaValue (MvGvspPixelType pixelType, float gammaValue)

设置Mono8/Bayer8/10/12/16格式的Gamma值 更多...

Int32 SetBayerGammaParam (GammaParam gammaParam)

设置Bayer格式的Gamma信息 更多...

Int32 SetBayerCCMParam (CCMParam ccmParam)

设置Bayer格式的CCM使能和矩阵，量化系数默认1024 更多...

Int32 ConvertPixelType (IImage inImage, out IImage outImage, MvGvspPixelType dstPixelType)

像素格式转换 更多...

Int32 ConvertPixelType (IImage inImage, Byte[] outBuffer, out UInt64 outDataLen, MvGvspPixelType dstPixelType)

像素格式转换 更多...

UInt64 GetBufferSizeForConvert (MvGvspPixelType dstPixelType, UInt32 width, UInt32 height)

获取像素格式转换所需的缓存大小 更多...

详细描述

提供像素格式转换相关接口

成员函数说明

◆ SetBayerCvtQuality()

Int32 IPixelTypeConverter.SetBayerCvtQuality ( CFAMethod method )

设置图像插值算法类型

参数

method 图像插值算法

返回

成功，返回MV_OK；失败，返回错误码

设置内部图像转换接口的Bayer插值算法类型参数，IPixelTypeConverter、IImageSaver使用的插值算法是该接口所设定的

◆ SetBayerFilterEnable()

Int32 IPixelTypeConverter.SetBayerFilterEnable ( bool enable )

插值算法平滑使能设置

参数

enable 平滑使能（默认关闭）

返回

成功，返回MV_OK；失败，返回错误码

设置内部图像转换接口的Bayer插值平滑使能参数，IPixelTypeConverter、IImageSaver使用的插值算法是该接口所设定的。

◆ SetBayerGammaValue()

Int32 IPixelTypeConverter.SetBayerGammaValue ( float gammaValue )

设置Bayer格式的Gamma值

参数

gammaValue Gamma值：0.1 ~ 4.0

返回

成功，返回MV_OK；失败，返回错误码

设置该值后，IPixelTypeConverter、IImageSaver将Bayer8/10/12/16格式转成RGB24/48， RGBA32/64，BGR24/48，BGRA32/64时起效。

◆ SetGammaValue()

Int32 IPixelTypeConverter.SetGammaValue ( MvGvspPixelType pixelType,

float gammaValue

)

设置Mono8/Bayer8/10/12/16格式的Gamma值

参数

pixelType 像素格式

gammaValue Gamma值:0.1 ~ 4.0

返回

成功，返回MV_OK；失败，返回错误码

设置Mono8的gamma值后，再调用ConvertPixelType(MvCameraControl.IImage, byte[], out ulong, MvCameraControl.MvGvspPixelType)将Mono8转成Mono8时gamma值起效。 设置Bayer8/10/12/16的gamma值后,IPixelTypeConverter、IImageSaver将Bayer8/10/12/16格式转成RGB24/48， RGBA32/64，BGR24/48，BGRA32/64时起效。 该接口兼容SetBayerGammaValue接口，新增支持Mono8像素格式

◆ SetBayerGammaParam()

Int32 IPixelTypeConverter.SetBayerGammaParam ( GammaParam gammaParam )

设置Bayer格式的Gamma信息

参数

gammaParam Gamma参数

返回

成功，返回MV_OK；失败，返回错误码

设置该信息后，在IPixelTypeConverter、IImageSaver将Bayer8/10/12/16格式转成RGB24/48， RGBA32/64，BGR24/48，BGRA32/64时起效。

◆ SetBayerCCMParam()

Int32 IPixelTypeConverter.SetBayerCCMParam ( CCMParam ccmParam )

设置Bayer格式的CCM使能和矩阵，量化系数默认1024

参数

ccmParam CCM参数

返回

成功，返回MV_OK；失败，返回错误码

开启CCM并设置CCM矩阵后，在IPixelTypeConverter、IImageSaver将Bayer8/10/12/16格式转成RGB24/48， RGBA32/64，BGR24/48，BGRA32/64时起效。

◆ ConvertPixelType() [1/2]

Int32 IPixelTypeConverter.ConvertPixelType ( IImage inImage,

out IImage outImage,

MvGvspPixelType dstPixelType

)

像素格式转换

参数

inImage 输入图像

outImage 输出图像

dstPixelType 目标像素格式

返回

成功，返回MV_OK；失败，返回错误码

◆ ConvertPixelType() [2/2]

Int32 IPixelTypeConverter.ConvertPixelType ( IImage inImage,

Byte [] outBuffer,

out UInt64 outDataLen,

MvGvspPixelType dstPixelType

)

像素格式转换

参数

inImage 输入图像

outBuffer 输出图像缓存

outDataLen 输出图像长度

dstPixelType 目标像素格式

返回

成功，返回MV_OK；失败，返回错误码

◆ GetBufferSizeForConvert()

UInt64 IPixelTypeConverter.GetBufferSizeForConvert ( MvGvspPixelType dstPixelType,

UInt32 width,

UInt32 height

)

获取像素格式转换所需的缓存大小

参数

dstPixelType 目标像素格式

width 图像宽

height 图像高

返回

缓存大小

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 属性 | 所有成员列表

RecordParam结构体 参考 图像处理

录像参数 更多...

Public 属性

MvGvspPixelType PixelType

输入数据的像素格式 更多...

UInt32 Width

图像宽（指定目标参数时需为2的倍数） 更多...

UInt32 Height

图像高（指定目标参数时需为2的倍数） 更多...

float FrameRate

帧率fps(大于1/16) 更多...

UInt32 BitRate

码率kbps(128-16*1024) 更多...

VideoFormatType FormatType

录像格式 更多...

详细描述

录像参数

类成员变量说明

◆ PixelType

MvGvspPixelType RecordParam.PixelType

输入数据的像素格式

◆ Width

UInt32 RecordParam.Width

图像宽（指定目标参数时需为2的倍数）

◆ Height

UInt32 RecordParam.Height

图像高（指定目标参数时需为2的倍数）

◆ FrameRate

float RecordParam.FrameRate

帧率fps(大于1/16)

◆ BitRate

UInt32 RecordParam.BitRate

码率kbps(128-16*1024)

◆ FormatType

VideoFormatType RecordParam.FormatType

录像格式

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | 所有成员列表

IVideoRecorder接口 参考 图像处理

录像,将图片录制成AVI格式视频 更多...

Public 成员函数

Int32 StartRecord (String filePath, RecordParam recordParam)

开始录像 更多...

Int32 InputOneFrame (IImage image)

输入录像数据 更多...

Int32 StopRecord ()

停止录像 更多...

详细描述

录像,将图片录制成AVI格式视频

成员函数说明

◆ StartRecord()

Int32 IVideoRecorder.StartRecord ( String filePath,

RecordParam recordParam

)

开始录像

参数

filePath 录像文件存放路径

recordParam 录像参数

返回

成功，返回MV_OK；失败，返回错误码

◆ InputOneFrame()

Int32 IVideoRecorder.InputOneFrame ( IImage image )

输入录像数据

参数

image 图像数据

返回

成功，返回MV_OK；失败，返回错误码

◆ StopRecord()

Int32 IVideoRecorder.StopRecord ( )

停止录像

返回

成功，返回MV_OK；失败，返回错误码

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

类

事件功能

设备事件相关数据结构和事件订阅相关接口，用于实现设备事件接收功能 更多...

类

interface IEventOutInfo

设备event信息 更多...

class DeviceEventArgs

设备事件 更多...

interface IEventGrabber

提供设备事件订阅相关接口 更多...

详细描述

设备事件相关数据结构和事件订阅相关接口，用于实现设备事件接收功能

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IEventOutInfo接口 参考 事件功能

设备event信息 更多...

属性

String EventName [get]

Event名称 更多...

UInt16 EventID [get]

EventID 更多...

UInt16 StreamChannel [get]

流通道序号 更多...

UInt64 BlockId [get]

帧号 更多...

UInt64 Timestamp [get]

时间戳 更多...

UInt32 EventDataSize [get]

Event数据长度 更多...

Byte [] EventData [get]

Event数据，内部会进行一次拷贝，将非托管内存拷贝到托管内存 更多...

详细描述

设备event信息

属性说明

◆ EventName

String IEventOutInfo.EventName

get

Event名称

◆ EventID

UInt16 IEventOutInfo.EventID

get

EventID

◆ StreamChannel

UInt16 IEventOutInfo.StreamChannel

get

流通道序号

◆ BlockId

UInt64 IEventOutInfo.BlockId

get

帧号

◆ Timestamp

UInt64 IEventOutInfo.Timestamp

get

时间戳

◆ EventDataSize

UInt32 IEventOutInfo.EventDataSize

get

Event数据长度

◆ EventData

Byte [] IEventOutInfo.EventData

get

Event数据，内部会进行一次拷贝，将非托管内存拷贝到托管内存

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

DeviceEventArgs类 参考 事件功能

设备事件 更多...

继承自 EventArgs .

属性

IEventOutInfo EventInfo [get]

事件信息 更多...

详细描述

设备事件

属性说明

◆ EventInfo

IEventOutInfo DeviceEventArgs.EventInfo

get

事件信息

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 成员函数 | 事件 | 所有成员列表

IEventGrabber接口 参考 事件功能

提供设备事件订阅相关接口 更多...

Public 成员函数

Int32 SubscribeEvent (String eventName)

订阅事件 更多...

Int32 UnSubscribeEvent (String eventName)

取消事件订阅 更多...

Int32 SubscribeAllEvent ()

订阅所有事件 更多...

Int32 UnSubscribeAllEvent ()

取消订阅所有事件 更多...

事件

EventHandler< DeviceEventArgs > DeviceEvent

设备事件 更多...

详细描述

提供设备事件订阅相关接口

成员函数说明

◆ SubscribeEvent()

Int32 IEventGrabber.SubscribeEvent ( String eventName )

订阅事件

参数

eventName 事件名称

返回

成功，返回MV_OK；失败，返回错误码

◆ UnSubscribeEvent()

Int32 IEventGrabber.UnSubscribeEvent ( String eventName )

取消事件订阅

参数

eventName 事件名称

返回

成功，返回MV_OK；失败，返回错误码

◆ SubscribeAllEvent()

Int32 IEventGrabber.SubscribeAllEvent ( )

订阅所有事件

返回

成功，返回MV_OK；失败，返回错误码

◆ UnSubscribeAllEvent()

Int32 IEventGrabber.UnSubscribeAllEvent ( )

取消订阅所有事件

返回

成功，返回MV_OK；失败，返回错误码

事件说明

◆ DeviceEvent

EventHandler<DeviceEventArgs> IEventGrabber.DeviceEvent

设备事件

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

类

GenTL

GenTL标准相关数据结构和接口，用于实现通过GenTL接口枚举第三方设备 更多...

类

interface IGenTLIFInfo

通过GenTL枚举到的接口信息。此处的“接口信息”可能为采集卡信息，也可能为GenTL标准定义的接口 更多...

interface IGenTLDevInfo

通过GenTL枚举到的设备信息 更多...

class GenTLManager

提供GenTL相关接口 更多...

详细描述

GenTL标准相关数据结构和接口，用于实现通过GenTL接口枚举第三方设备

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IGenTLIFInfo接口 参考 GenTL

通过GenTL枚举到的接口信息。此处的“接口信息”可能为采集卡信息，也可能为GenTL标准定义的接口 更多...

属性

String InterfaceID [get]

GenTL接口ID 更多...

String TLType [get]

传输层类型 更多...

String DisplayName [get]

显示名称 更多...

UInt32 CtiIndex [get]

GenTL的cti文件索引 更多...

详细描述

通过GenTL枚举到的接口信息。此处的“接口信息”可能为采集卡信息，也可能为GenTL标准定义的接口

属性说明

◆ InterfaceID

String IGenTLIFInfo.InterfaceID

get

GenTL接口ID

◆ TLType

String IGenTLIFInfo.TLType

get

传输层类型

◆ DisplayName

String IGenTLIFInfo.DisplayName

get

显示名称

◆ CtiIndex

UInt32 IGenTLIFInfo.CtiIndex

get

GenTL的cti文件索引

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

IGenTLDevInfo接口 参考 GenTL

通过GenTL枚举到的设备信息 更多...

属性

String InterfaceID [get]

GenTL接口ID 更多...

String DeviceID [get]

设备ID 更多...

String VendorName [get]

供应商名字 更多...

String ModelName [get]

型号名字 更多...

String TLType [get]

传输层类型 更多...

String DisplayName [get]

设备显示名称 更多...

String UserDefinedName [get]

用户自定义名字 更多...

String SerialNumber [get]

序列号 更多...

String DeviceVersion [get]

设备版本号 更多...

UInt32 CtiIndex [get]

GenTL的cti文件索引 更多...

详细描述

通过GenTL枚举到的设备信息

属性说明

◆ InterfaceID

String IGenTLDevInfo.InterfaceID

get

GenTL接口ID

◆ DeviceID

String IGenTLDevInfo.DeviceID

get

设备ID

◆ VendorName

String IGenTLDevInfo.VendorName

get

供应商名字

◆ ModelName

String IGenTLDevInfo.ModelName

get

型号名字

◆ TLType

String IGenTLDevInfo.TLType

get

传输层类型

◆ DisplayName

String IGenTLDevInfo.DisplayName

get

设备显示名称

◆ UserDefinedName

String IGenTLDevInfo.UserDefinedName

get

用户自定义名字

◆ SerialNumber

String IGenTLDevInfo.SerialNumber

get

序列号

◆ DeviceVersion

String IGenTLDevInfo.DeviceVersion

get

设备版本号

◆ CtiIndex

UInt32 IGenTLDevInfo.CtiIndex

get

GenTL的cti文件索引

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

静态 Public 成员函数 | 所有成员列表

GenTLManager类 参考 GenTL

提供GenTL相关接口 更多...

静态 Public 成员函数

static Int32 EnumInterfacesByGenTL (String ctiPath, out List< IGenTLIFInfo > IFList)

通过GenTL枚举接口。此处的“接口”包括采集卡和GenTL标准定义的接口 更多...

static Int32 EnumDevicesByGenTL (IGenTLIFInfo IFInfo, out List< IGenTLDevInfo > devList)

通过GenTL枚举接口，并通过接口信息枚举接口上连接着的相机。此处的“接口”包括采集卡和GenTL标准定义的接口 更多...

static Int32 UnloadGenTLLibrary (String ctiPath)

卸载cti库 更多...

详细描述

提供GenTL相关接口

成员函数说明

◆ EnumInterfacesByGenTL()

static Int32 GenTLManager.EnumInterfacesByGenTL ( String ctiPath,

out List< IGenTLIFInfo > IFList

)

static

通过GenTL枚举接口。此处的“接口”包括采集卡和GenTL标准定义的接口

参数

ctiPath GenTL的cti文件路径

IFList 接口列表

返回

成功，返回MV_OK；失败，返回错误码

◆ EnumDevicesByGenTL()

static Int32 GenTLManager.EnumDevicesByGenTL ( IGenTLIFInfo IFInfo,

out List< IGenTLDevInfo > devList

)

static

通过GenTL枚举接口，并通过接口信息枚举接口上连接着的相机。此处的“接口”包括采集卡和GenTL标准定义的接口

参数

IFInfo 接口信息

devList 相机列表

返回

成功，返回MV_OK；失败，返回错误码

枚举到设备后，通过DeviceFactory创建相机实例。

◆ UnloadGenTLLibrary()

static Int32 GenTLManager.UnloadGenTLLibrary ( String ctiPath )

static

卸载cti库

参数

ctiPath 枚举卡时加载的cti文件路径

返回

成功，返回MV_OK；失败，返回错误码

注意

卸载前需要保证通过该cti枚举出的相机已全部关闭，否则将报“前置条件错误”

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

类

状态码及异常

接口调用的状态码及SDK抛出异常信息 更多...

类

class MvError

错误码定义 更多...

class MvException

异常信息 更多...

详细描述

接口调用的状态码及SDK抛出异常信息

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

Public 属性 | 所有成员列表

MvError类 参考 状态码及异常

错误码定义 更多...

Public 属性

const Int32 MV_OK = unchecked((Int32)0x00000000)

成功，无错误 更多...

const Int32 MV_E_HANDLE = unchecked((Int32)0x80000000)

错误或无效的句柄 更多...

const Int32 MV_E_SUPPORT = unchecked((Int32)0x80000001)

不支持的功能 更多...

const Int32 MV_E_BUFOVER = unchecked((Int32)0x80000002)

缓存已满 更多...

const Int32 MV_E_CALLORDER = unchecked((Int32)0x80000003)

函数调用顺序错误 更多...

const Int32 MV_E_PARAMETER = unchecked((Int32)0x80000004)

错误的参数 更多...

const Int32 MV_E_RESOURCE = unchecked((Int32)0x80000006)

资源申请失败 更多...

const Int32 MV_E_NODATA = unchecked((Int32)0x80000007)

无数据 更多...

const Int32 MV_E_PRECONDITION = unchecked((Int32)0x80000008)

前置条件有误，或运行环境已发生变化 更多...

const Int32 MV_E_VERSION = unchecked((Int32)0x80000009)

版本不匹配 更多...

const Int32 MV_E_NOENOUGH_BUF = unchecked((Int32)0x8000000A)

传入的内存空间不足 更多...

const Int32 MV_E_ABNORMAL_IMAGE = unchecked((Int32)0x8000000B)

异常图像，可能是丢包导致图像不完整 更多...

const Int32 MV_E_LOAD_LIBRARY = unchecked((Int32)0x8000000C)

动态导入DLL失败 更多...

const Int32 MV_E_NOOUTBUF = unchecked((Int32)0x8000000D)

没有可输出的缓存 更多...

const Int32 MV_E_ENCRYPT = unchecked((Int32)0x8000000E)

加密错误 更多...

const Int32 MV_E_UNKNOW = unchecked((Int32)0x800000FF)

未知的错误 更多...

const Int32 MV_E_GC_GENERIC = unchecked((Int32)0x80000100)

通用错误 更多...

const Int32 MV_E_GC_ARGUMENT = unchecked((Int32)0x80000101)

参数非法 更多...

const Int32 MV_E_GC_RANGE = unchecked((Int32)0x80000102)

值超出范围 更多...

const Int32 MV_E_GC_PROPERTY = unchecked((Int32)0x80000103)

属性 更多...

const Int32 MV_E_GC_RUNTIME = unchecked((Int32)0x80000104)

运行环境有问题 更多...

const Int32 MV_E_GC_LOGICAL = unchecked((Int32)0x80000105)

逻辑错误 更多...

const Int32 MV_E_GC_ACCESS = unchecked((Int32)0x80000106)

节点访问条件有误 更多...

const Int32 MV_E_GC_TIMEOUT = unchecked((Int32)0x80000107)

超时 更多...

const Int32 MV_E_GC_DYNAMICCAST = unchecked((Int32)0x80000108)

转换异常 更多...

const Int32 MV_E_GC_UNKNOW = unchecked((Int32)0x800001FF)

GenICam未知错误 更多...

const Int32 MV_E_NOT_IMPLEMENTED = unchecked((Int32)0x80000200)

命令不被设备支持 更多...

const Int32 MV_E_INVALID_ADDRESS = unchecked((Int32)0x80000201)

访问的目标地址不存在 更多...

const Int32 MV_E_WRITE_PROTECT = unchecked((Int32)0x80000202)

目标地址不可写 更多...

const Int32 MV_E_ACCESS_DENIED = unchecked((Int32)0x80000203)

设备无访问权限 更多...

const Int32 MV_E_BUSY = unchecked((Int32)0x80000204)

设备忙，或网络断开 更多...

const Int32 MV_E_PACKET = unchecked((Int32)0x80000205)

网络包数据错误 更多...

const Int32 MV_E_NETER = unchecked((Int32)0x80000206)

网络相关错误 更多...

const Int32 MV_E_IP_CONFLICT = unchecked((Int32)0x80000221)

设备IP冲突 更多...

const Int32 MV_E_USB_READ = unchecked((Int32)0x80000300)

读usb出错 更多...

const Int32 MV_E_USB_WRITE = unchecked((Int32)0x80000301)

写usb出错 更多...

const Int32 MV_E_USB_DEVICE = unchecked((Int32)0x80000302)

设备异常 更多...

const Int32 MV_E_USB_GENICAM = unchecked((Int32)0x80000303)

GenICam相关错误 更多...

const Int32 MV_E_USB_BANDWIDTH = unchecked((Int32)0x80000304)

带宽不足 更多...

const Int32 MV_E_USB_DRIVER = unchecked((Int32)0x80000305)

驱动不匹配或者未装驱动 更多...

const Int32 MV_E_USB_UNKNOW = unchecked((Int32)0x800003FF)

USB未知的错误 更多...

const Int32 MV_E_UPG_FILE_MISMATCH = unchecked((Int32)0x80000400)

升级固件不匹配 更多...

const Int32 MV_E_UPG_LANGUSGE_MISMATCH = unchecked((Int32)0x80000401)

升级固件语言不匹配 更多...

const Int32 MV_E_UPG_CONFLICT = unchecked((Int32)0x80000402)

升级冲突（设备已经在升级了再次请求升级即返回此错误） 更多...

const Int32 MV_E_UPG_INNER_ERR = unchecked((Int32)0x80000403)

升级时设备内部出现错误 更多...

const Int32 MV_E_UPG_UNKNOW = unchecked((Int32)0x800004FF)

升级时未知错误 更多...

const Int32 MV_ALG_OK = unchecked((Int32)0x00000000)

处理正确 更多...

const Int32 MV_ALG_ERR = unchecked((Int32)0x10000000)

不确定类型错误 更多...

const Int32 MV_ALG_E_ABILITY_ARG = unchecked((Int32)0x10000001)

能力集中存在无效参数 更多...

const Int32 MV_ALG_E_MEM_NULL = unchecked((Int32)0x10000002)

内存地址为空 更多...

const Int32 MV_ALG_E_MEM_ALIGN = unchecked((Int32)0x10000003)

内存对齐不满足要求 更多...

const Int32 MV_ALG_E_MEM_LACK = unchecked((Int32)0x10000004)

内存空间大小不够 更多...

const Int32 MV_ALG_E_MEM_SIZE_ALIGN = unchecked((Int32)0x10000005)

内存空间大小不满足对齐要求 更多...

const Int32 MV_ALG_E_MEM_ADDR_ALIGN = unchecked((Int32)0x10000006)

内存地址不满足对齐要求 更多...

const Int32 MV_ALG_E_IMG_FORMAT = unchecked((Int32)0x10000007)

图像格式不正确或者不支持 更多...

const Int32 MV_ALG_E_IMG_SIZE = unchecked((Int32)0x10000008)

图像宽高不正确或者超出范围 更多...

const Int32 MV_ALG_E_IMG_STEP = unchecked((Int32)0x10000009)

图像宽高与step参数不匹配 更多...

const Int32 MV_ALG_E_IMG_DATA_NULL = unchecked((Int32)0x1000000A)

图像数据存储地址为空 更多...

const Int32 MV_ALG_E_CFG_TYPE = unchecked((Int32)0x1000000B)

设置或者获取参数类型不正确 更多...

const Int32 MV_ALG_E_CFG_SIZE = unchecked((Int32)0x1000000C)

设置或者获取参数的输入、输出结构体大小不正确 更多...

const Int32 MV_ALG_E_PRC_TYPE = unchecked((Int32)0x1000000D)

处理类型不正确 更多...

const Int32 MV_ALG_E_PRC_SIZE = unchecked((Int32)0x1000000E)

处理时输入、输出参数大小不正确 更多...

const Int32 MV_ALG_E_FUNC_TYPE = unchecked((Int32)0x1000000F)

子处理类型不正确 更多...

const Int32 MV_ALG_E_FUNC_SIZE = unchecked((Int32)0x10000010)

子处理时输入、输出参数大小不正确 更多...

const Int32 MV_ALG_E_PARAM_INDEX = unchecked((Int32)0x10000011)

index参数不正确 更多...

const Int32 MV_ALG_E_PARAM_VALUE = unchecked((Int32)0x10000012)

value参数不正确或者超出范围 更多...

const Int32 MV_ALG_E_PARAM_NUM = unchecked((Int32)0x10000013)

param_num参数不正确 更多...

const Int32 MV_ALG_E_NULL_PTR = unchecked((Int32)0x10000014)

函数参数指针为空 更多...

const Int32 MV_ALG_E_OVER_MAX_MEM = unchecked((Int32)0x10000015)

超过限定的最大内存 更多...

const Int32 MV_ALG_E_CALL_BACK = unchecked((Int32)0x10000016)

回调函数出错 更多...

const Int32 MV_ALG_E_ENCRYPT = unchecked((Int32)0x10000017)

加密错误 更多...

const Int32 MV_ALG_E_EXPIRE = unchecked((Int32)0x10000018)

算法库使用期限错误 更多...

const Int32 MV_ALG_E_BAD_ARG = unchecked((Int32)0x10000019)

参数范围不正确 更多...

const Int32 MV_ALG_E_DATA_SIZE = unchecked((Int32)0x1000001A)

数据大小不正确 更多...

const Int32 MV_ALG_E_STEP = unchecked((Int32)0x1000001B)

数据step不正确 更多...

const Int32 MV_ALG_E_CPUID = unchecked((Int32)0x1000001C)

cpu不支持优化代码中的指令集 更多...

const Int32 MV_ALG_WARNING = unchecked((Int32)0x1000001D)

警告 更多...

const Int32 MV_ALG_E_TIME_OUT = unchecked((Int32)0x1000001E)

算法库超时 更多...

const Int32 MV_ALG_E_LIB_VERSION = unchecked((Int32)0x1000001F)

算法版本号出错 更多...

const Int32 MV_ALG_E_MODEL_VERSION = unchecked((Int32)0x10000020)

模型版本号出错 更多...

const Int32 MV_ALG_E_GPU_MEM_ALLOC = unchecked((Int32)0x10000021)

GPU内存分配错误 更多...

const Int32 MV_ALG_E_FILE_NON_EXIST = unchecked((Int32)0x10000022)

文件不存在 更多...

const Int32 MV_ALG_E_NONE_STRING = unchecked((Int32)0x10000023)

字符串为空 更多...

const Int32 MV_ALG_E_IMAGE_CODEC = unchecked((Int32)0x10000024)

图像解码器错误 更多...

const Int32 MV_ALG_E_FILE_OPEN = unchecked((Int32)0x10000025)

打开文件错误 更多...

const Int32 MV_ALG_E_FILE_READ = unchecked((Int32)0x10000026)

文件读取错误 更多...

const Int32 MV_ALG_E_FILE_WRITE = unchecked((Int32)0x10000027)

文件写错误 更多...

const Int32 MV_ALG_E_FILE_READ_SIZE = unchecked((Int32)0x10000028)

文件读取大小错误 更多...

const Int32 MV_ALG_E_FILE_TYPE = unchecked((Int32)0x10000029)

文件类型错误 更多...

const Int32 MV_ALG_E_MODEL_TYPE = unchecked((Int32)0x1000002A)

模型类型错误 更多...

const Int32 MV_ALG_E_MALLOC_MEM = unchecked((Int32)0x1000002B)

分配内存错误 更多...

const Int32 MV_ALG_E_BIND_CORE_FAILED = unchecked((Int32)0x1000002C)

线程绑核失败 更多...

const Int32 MV_ALG_E_DENOISE_NE_IMG_FORMAT = unchecked((Int32)0x10402001)

噪声特性图像格式错误 更多...

const Int32 MV_ALG_E_DENOISE_NE_FEATURE_TYPE = unchecked((Int32)0x10402002)

噪声特性类型错误 更多...

const Int32 MV_ALG_E_DENOISE_NE_PROFILE_NUM = unchecked((Int32)0x10402003)

噪声特性个数错误 更多...

const Int32 MV_ALG_E_DENOISE_NE_GAIN_NUM = unchecked((Int32)0x10402004)

噪声特性增益个数错误 更多...

const Int32 MV_ALG_E_DENOISE_NE_GAIN_VAL = unchecked((Int32)0x10402005)

噪声曲线增益值输入错误 更多...

const Int32 MV_ALG_E_DENOISE_NE_BIN_NUM = unchecked((Int32)0x10402006)

噪声曲线柱数错误 更多...

const Int32 MV_ALG_E_DENOISE_NE_INIT_GAIN = unchecked((Int32)0x10402007)

噪声估计初始化增益设置错误 更多...

const Int32 MV_ALG_E_DENOISE_NE_NOT_INIT = unchecked((Int32)0x10402008)

噪声估计未初始化 更多...

const Int32 MV_ALG_E_DENOISE_COLOR_MODE = unchecked((Int32)0x10402009)

颜色空间模式错误 更多...

const Int32 MV_ALG_E_DENOISE_ROI_NUM = unchecked((Int32)0x1040200a)

图像ROI个数错误 更多...

const Int32 MV_ALG_E_DENOISE_ROI_ORI_PT = unchecked((Int32)0x1040200b)

图像ROI原点错误 更多...

const Int32 MV_ALG_E_DENOISE_ROI_SIZE = unchecked((Int32)0x1040200c)

图像ROI大小错误 更多...

const Int32 MV_ALG_E_DENOISE_GAIN_NOT_EXIST = unchecked((Int32)0x1040200d)

输入的相机增益不存在(增益个数已达上限) 更多...

const Int32 MV_ALG_E_DENOISE_GAIN_BEYOND_RANGE = unchecked((Int32)0x1040200e)

输入的相机增益不在范围内 更多...

const Int32 MV_ALG_E_DENOISE_NP_BUF_SIZE = unchecked((Int32)0x1040200f)

输入的噪声特性内存大小错误 更多...

详细描述

错误码定义

类成员变量说明

◆ MV_OK

const Int32 MvError.MV_OK = unchecked((Int32)0x00000000)

成功，无错误

◆ MV_E_HANDLE

const Int32 MvError.MV_E_HANDLE = unchecked((Int32)0x80000000)

错误或无效的句柄

◆ MV_E_SUPPORT

const Int32 MvError.MV_E_SUPPORT = unchecked((Int32)0x80000001)

不支持的功能

◆ MV_E_BUFOVER

const Int32 MvError.MV_E_BUFOVER = unchecked((Int32)0x80000002)

缓存已满

◆ MV_E_CALLORDER

const Int32 MvError.MV_E_CALLORDER = unchecked((Int32)0x80000003)

函数调用顺序错误

◆ MV_E_PARAMETER

const Int32 MvError.MV_E_PARAMETER = unchecked((Int32)0x80000004)

错误的参数

◆ MV_E_RESOURCE

const Int32 MvError.MV_E_RESOURCE = unchecked((Int32)0x80000006)

资源申请失败

◆ MV_E_NODATA

const Int32 MvError.MV_E_NODATA = unchecked((Int32)0x80000007)

无数据

◆ MV_E_PRECONDITION

const Int32 MvError.MV_E_PRECONDITION = unchecked((Int32)0x80000008)

前置条件有误，或运行环境已发生变化

◆ MV_E_VERSION

const Int32 MvError.MV_E_VERSION = unchecked((Int32)0x80000009)

版本不匹配

◆ MV_E_NOENOUGH_BUF

const Int32 MvError.MV_E_NOENOUGH_BUF = unchecked((Int32)0x8000000A)

传入的内存空间不足

◆ MV_E_ABNORMAL_IMAGE

const Int32 MvError.MV_E_ABNORMAL_IMAGE = unchecked((Int32)0x8000000B)

异常图像，可能是丢包导致图像不完整

◆ MV_E_LOAD_LIBRARY

const Int32 MvError.MV_E_LOAD_LIBRARY = unchecked((Int32)0x8000000C)

动态导入DLL失败

◆ MV_E_NOOUTBUF

const Int32 MvError.MV_E_NOOUTBUF = unchecked((Int32)0x8000000D)

没有可输出的缓存

◆ MV_E_ENCRYPT

const Int32 MvError.MV_E_ENCRYPT = unchecked((Int32)0x8000000E)

加密错误

◆ MV_E_UNKNOW

const Int32 MvError.MV_E_UNKNOW = unchecked((Int32)0x800000FF)

未知的错误

◆ MV_E_GC_GENERIC

const Int32 MvError.MV_E_GC_GENERIC = unchecked((Int32)0x80000100)

通用错误

◆ MV_E_GC_ARGUMENT

const Int32 MvError.MV_E_GC_ARGUMENT = unchecked((Int32)0x80000101)

参数非法

◆ MV_E_GC_RANGE

const Int32 MvError.MV_E_GC_RANGE = unchecked((Int32)0x80000102)

值超出范围

◆ MV_E_GC_PROPERTY

const Int32 MvError.MV_E_GC_PROPERTY = unchecked((Int32)0x80000103)

属性

◆ MV_E_GC_RUNTIME

const Int32 MvError.MV_E_GC_RUNTIME = unchecked((Int32)0x80000104)

运行环境有问题

◆ MV_E_GC_LOGICAL

const Int32 MvError.MV_E_GC_LOGICAL = unchecked((Int32)0x80000105)

逻辑错误

◆ MV_E_GC_ACCESS

const Int32 MvError.MV_E_GC_ACCESS = unchecked((Int32)0x80000106)

节点访问条件有误

◆ MV_E_GC_TIMEOUT

const Int32 MvError.MV_E_GC_TIMEOUT = unchecked((Int32)0x80000107)

超时

◆ MV_E_GC_DYNAMICCAST

const Int32 MvError.MV_E_GC_DYNAMICCAST = unchecked((Int32)0x80000108)

转换异常

◆ MV_E_GC_UNKNOW

const Int32 MvError.MV_E_GC_UNKNOW = unchecked((Int32)0x800001FF)

GenICam未知错误

◆ MV_E_NOT_IMPLEMENTED

const Int32 MvError.MV_E_NOT_IMPLEMENTED = unchecked((Int32)0x80000200)

命令不被设备支持

◆ MV_E_INVALID_ADDRESS

const Int32 MvError.MV_E_INVALID_ADDRESS = unchecked((Int32)0x80000201)

访问的目标地址不存在

◆ MV_E_WRITE_PROTECT

const Int32 MvError.MV_E_WRITE_PROTECT = unchecked((Int32)0x80000202)

目标地址不可写

◆ MV_E_ACCESS_DENIED

const Int32 MvError.MV_E_ACCESS_DENIED = unchecked((Int32)0x80000203)

设备无访问权限

◆ MV_E_BUSY

const Int32 MvError.MV_E_BUSY = unchecked((Int32)0x80000204)

设备忙，或网络断开

◆ MV_E_PACKET

const Int32 MvError.MV_E_PACKET = unchecked((Int32)0x80000205)

网络包数据错误

◆ MV_E_NETER

const Int32 MvError.MV_E_NETER = unchecked((Int32)0x80000206)

网络相关错误

◆ MV_E_IP_CONFLICT

const Int32 MvError.MV_E_IP_CONFLICT = unchecked((Int32)0x80000221)

设备IP冲突

◆ MV_E_USB_READ

const Int32 MvError.MV_E_USB_READ = unchecked((Int32)0x80000300)

读usb出错

◆ MV_E_USB_WRITE

const Int32 MvError.MV_E_USB_WRITE = unchecked((Int32)0x80000301)

写usb出错

◆ MV_E_USB_DEVICE

const Int32 MvError.MV_E_USB_DEVICE = unchecked((Int32)0x80000302)

设备异常

◆ MV_E_USB_GENICAM

const Int32 MvError.MV_E_USB_GENICAM = unchecked((Int32)0x80000303)

GenICam相关错误

◆ MV_E_USB_BANDWIDTH

const Int32 MvError.MV_E_USB_BANDWIDTH = unchecked((Int32)0x80000304)

带宽不足

◆ MV_E_USB_DRIVER

const Int32 MvError.MV_E_USB_DRIVER = unchecked((Int32)0x80000305)

驱动不匹配或者未装驱动

◆ MV_E_USB_UNKNOW

const Int32 MvError.MV_E_USB_UNKNOW = unchecked((Int32)0x800003FF)

USB未知的错误

◆ MV_E_UPG_FILE_MISMATCH

const Int32 MvError.MV_E_UPG_FILE_MISMATCH = unchecked((Int32)0x80000400)

升级固件不匹配

◆ MV_E_UPG_LANGUSGE_MISMATCH

const Int32 MvError.MV_E_UPG_LANGUSGE_MISMATCH = unchecked((Int32)0x80000401)

升级固件语言不匹配

◆ MV_E_UPG_CONFLICT

const Int32 MvError.MV_E_UPG_CONFLICT = unchecked((Int32)0x80000402)

升级冲突（设备已经在升级了再次请求升级即返回此错误）

◆ MV_E_UPG_INNER_ERR

const Int32 MvError.MV_E_UPG_INNER_ERR = unchecked((Int32)0x80000403)

升级时设备内部出现错误

◆ MV_E_UPG_UNKNOW

const Int32 MvError.MV_E_UPG_UNKNOW = unchecked((Int32)0x800004FF)

升级时未知错误

◆ MV_ALG_OK

const Int32 MvError.MV_ALG_OK = unchecked((Int32)0x00000000)

处理正确

◆ MV_ALG_ERR

const Int32 MvError.MV_ALG_ERR = unchecked((Int32)0x10000000)

不确定类型错误

◆ MV_ALG_E_ABILITY_ARG

const Int32 MvError.MV_ALG_E_ABILITY_ARG = unchecked((Int32)0x10000001)

能力集中存在无效参数

◆ MV_ALG_E_MEM_NULL

const Int32 MvError.MV_ALG_E_MEM_NULL = unchecked((Int32)0x10000002)

内存地址为空

◆ MV_ALG_E_MEM_ALIGN

const Int32 MvError.MV_ALG_E_MEM_ALIGN = unchecked((Int32)0x10000003)

内存对齐不满足要求

◆ MV_ALG_E_MEM_LACK

const Int32 MvError.MV_ALG_E_MEM_LACK = unchecked((Int32)0x10000004)

内存空间大小不够

◆ MV_ALG_E_MEM_SIZE_ALIGN

const Int32 MvError.MV_ALG_E_MEM_SIZE_ALIGN = unchecked((Int32)0x10000005)

内存空间大小不满足对齐要求

◆ MV_ALG_E_MEM_ADDR_ALIGN

const Int32 MvError.MV_ALG_E_MEM_ADDR_ALIGN = unchecked((Int32)0x10000006)

内存地址不满足对齐要求

◆ MV_ALG_E_IMG_FORMAT

const Int32 MvError.MV_ALG_E_IMG_FORMAT = unchecked((Int32)0x10000007)

图像格式不正确或者不支持

◆ MV_ALG_E_IMG_SIZE

const Int32 MvError.MV_ALG_E_IMG_SIZE = unchecked((Int32)0x10000008)

图像宽高不正确或者超出范围

◆ MV_ALG_E_IMG_STEP

const Int32 MvError.MV_ALG_E_IMG_STEP = unchecked((Int32)0x10000009)

图像宽高与step参数不匹配

◆ MV_ALG_E_IMG_DATA_NULL

const Int32 MvError.MV_ALG_E_IMG_DATA_NULL = unchecked((Int32)0x1000000A)

图像数据存储地址为空

◆ MV_ALG_E_CFG_TYPE

const Int32 MvError.MV_ALG_E_CFG_TYPE = unchecked((Int32)0x1000000B)

设置或者获取参数类型不正确

◆ MV_ALG_E_CFG_SIZE

const Int32 MvError.MV_ALG_E_CFG_SIZE = unchecked((Int32)0x1000000C)

设置或者获取参数的输入、输出结构体大小不正确

◆ MV_ALG_E_PRC_TYPE

const Int32 MvError.MV_ALG_E_PRC_TYPE = unchecked((Int32)0x1000000D)

处理类型不正确

◆ MV_ALG_E_PRC_SIZE

const Int32 MvError.MV_ALG_E_PRC_SIZE = unchecked((Int32)0x1000000E)

处理时输入、输出参数大小不正确

◆ MV_ALG_E_FUNC_TYPE

const Int32 MvError.MV_ALG_E_FUNC_TYPE = unchecked((Int32)0x1000000F)

子处理类型不正确

◆ MV_ALG_E_FUNC_SIZE

const Int32 MvError.MV_ALG_E_FUNC_SIZE = unchecked((Int32)0x10000010)

子处理时输入、输出参数大小不正确

◆ MV_ALG_E_PARAM_INDEX

const Int32 MvError.MV_ALG_E_PARAM_INDEX = unchecked((Int32)0x10000011)

index参数不正确

◆ MV_ALG_E_PARAM_VALUE

const Int32 MvError.MV_ALG_E_PARAM_VALUE = unchecked((Int32)0x10000012)

value参数不正确或者超出范围

◆ MV_ALG_E_PARAM_NUM

const Int32 MvError.MV_ALG_E_PARAM_NUM = unchecked((Int32)0x10000013)

param_num参数不正确

◆ MV_ALG_E_NULL_PTR

const Int32 MvError.MV_ALG_E_NULL_PTR = unchecked((Int32)0x10000014)

函数参数指针为空

◆ MV_ALG_E_OVER_MAX_MEM

const Int32 MvError.MV_ALG_E_OVER_MAX_MEM = unchecked((Int32)0x10000015)

超过限定的最大内存

◆ MV_ALG_E_CALL_BACK

const Int32 MvError.MV_ALG_E_CALL_BACK = unchecked((Int32)0x10000016)

回调函数出错

◆ MV_ALG_E_ENCRYPT

const Int32 MvError.MV_ALG_E_ENCRYPT = unchecked((Int32)0x10000017)

加密错误

◆ MV_ALG_E_EXPIRE

const Int32 MvError.MV_ALG_E_EXPIRE = unchecked((Int32)0x10000018)

算法库使用期限错误

◆ MV_ALG_E_BAD_ARG

const Int32 MvError.MV_ALG_E_BAD_ARG = unchecked((Int32)0x10000019)

参数范围不正确

◆ MV_ALG_E_DATA_SIZE

const Int32 MvError.MV_ALG_E_DATA_SIZE = unchecked((Int32)0x1000001A)

数据大小不正确

◆ MV_ALG_E_STEP

const Int32 MvError.MV_ALG_E_STEP = unchecked((Int32)0x1000001B)

数据step不正确

◆ MV_ALG_E_CPUID

const Int32 MvError.MV_ALG_E_CPUID = unchecked((Int32)0x1000001C)

cpu不支持优化代码中的指令集

◆ MV_ALG_WARNING

const Int32 MvError.MV_ALG_WARNING = unchecked((Int32)0x1000001D)

警告

◆ MV_ALG_E_TIME_OUT

const Int32 MvError.MV_ALG_E_TIME_OUT = unchecked((Int32)0x1000001E)

算法库超时

◆ MV_ALG_E_LIB_VERSION

const Int32 MvError.MV_ALG_E_LIB_VERSION = unchecked((Int32)0x1000001F)

算法版本号出错

◆ MV_ALG_E_MODEL_VERSION

const Int32 MvError.MV_ALG_E_MODEL_VERSION = unchecked((Int32)0x10000020)

模型版本号出错

◆ MV_ALG_E_GPU_MEM_ALLOC

const Int32 MvError.MV_ALG_E_GPU_MEM_ALLOC = unchecked((Int32)0x10000021)

GPU内存分配错误

◆ MV_ALG_E_FILE_NON_EXIST

const Int32 MvError.MV_ALG_E_FILE_NON_EXIST = unchecked((Int32)0x10000022)

文件不存在

◆ MV_ALG_E_NONE_STRING

const Int32 MvError.MV_ALG_E_NONE_STRING = unchecked((Int32)0x10000023)

字符串为空

◆ MV_ALG_E_IMAGE_CODEC

const Int32 MvError.MV_ALG_E_IMAGE_CODEC = unchecked((Int32)0x10000024)

图像解码器错误

◆ MV_ALG_E_FILE_OPEN

const Int32 MvError.MV_ALG_E_FILE_OPEN = unchecked((Int32)0x10000025)

打开文件错误

◆ MV_ALG_E_FILE_READ

const Int32 MvError.MV_ALG_E_FILE_READ = unchecked((Int32)0x10000026)

文件读取错误

◆ MV_ALG_E_FILE_WRITE

const Int32 MvError.MV_ALG_E_FILE_WRITE = unchecked((Int32)0x10000027)

文件写错误

◆ MV_ALG_E_FILE_READ_SIZE

const Int32 MvError.MV_ALG_E_FILE_READ_SIZE = unchecked((Int32)0x10000028)

文件读取大小错误

◆ MV_ALG_E_FILE_TYPE

const Int32 MvError.MV_ALG_E_FILE_TYPE = unchecked((Int32)0x10000029)

文件类型错误

◆ MV_ALG_E_MODEL_TYPE

const Int32 MvError.MV_ALG_E_MODEL_TYPE = unchecked((Int32)0x1000002A)

模型类型错误

◆ MV_ALG_E_MALLOC_MEM

const Int32 MvError.MV_ALG_E_MALLOC_MEM = unchecked((Int32)0x1000002B)

分配内存错误

◆ MV_ALG_E_BIND_CORE_FAILED

const Int32 MvError.MV_ALG_E_BIND_CORE_FAILED = unchecked((Int32)0x1000002C)

线程绑核失败

◆ MV_ALG_E_DENOISE_NE_IMG_FORMAT

const Int32 MvError.MV_ALG_E_DENOISE_NE_IMG_FORMAT = unchecked((Int32)0x10402001)

噪声特性图像格式错误

◆ MV_ALG_E_DENOISE_NE_FEATURE_TYPE

const Int32 MvError.MV_ALG_E_DENOISE_NE_FEATURE_TYPE = unchecked((Int32)0x10402002)

噪声特性类型错误

◆ MV_ALG_E_DENOISE_NE_PROFILE_NUM

const Int32 MvError.MV_ALG_E_DENOISE_NE_PROFILE_NUM = unchecked((Int32)0x10402003)

噪声特性个数错误

◆ MV_ALG_E_DENOISE_NE_GAIN_NUM

const Int32 MvError.MV_ALG_E_DENOISE_NE_GAIN_NUM = unchecked((Int32)0x10402004)

噪声特性增益个数错误

◆ MV_ALG_E_DENOISE_NE_GAIN_VAL

const Int32 MvError.MV_ALG_E_DENOISE_NE_GAIN_VAL = unchecked((Int32)0x10402005)

噪声曲线增益值输入错误

◆ MV_ALG_E_DENOISE_NE_BIN_NUM

const Int32 MvError.MV_ALG_E_DENOISE_NE_BIN_NUM = unchecked((Int32)0x10402006)

噪声曲线柱数错误

◆ MV_ALG_E_DENOISE_NE_INIT_GAIN

const Int32 MvError.MV_ALG_E_DENOISE_NE_INIT_GAIN = unchecked((Int32)0x10402007)

噪声估计初始化增益设置错误

◆ MV_ALG_E_DENOISE_NE_NOT_INIT

const Int32 MvError.MV_ALG_E_DENOISE_NE_NOT_INIT = unchecked((Int32)0x10402008)

噪声估计未初始化

◆ MV_ALG_E_DENOISE_COLOR_MODE

const Int32 MvError.MV_ALG_E_DENOISE_COLOR_MODE = unchecked((Int32)0x10402009)

颜色空间模式错误

◆ MV_ALG_E_DENOISE_ROI_NUM

const Int32 MvError.MV_ALG_E_DENOISE_ROI_NUM = unchecked((Int32)0x1040200a)

图像ROI个数错误

◆ MV_ALG_E_DENOISE_ROI_ORI_PT

const Int32 MvError.MV_ALG_E_DENOISE_ROI_ORI_PT = unchecked((Int32)0x1040200b)

图像ROI原点错误

◆ MV_ALG_E_DENOISE_ROI_SIZE

const Int32 MvError.MV_ALG_E_DENOISE_ROI_SIZE = unchecked((Int32)0x1040200c)

图像ROI大小错误

◆ MV_ALG_E_DENOISE_GAIN_NOT_EXIST

const Int32 MvError.MV_ALG_E_DENOISE_GAIN_NOT_EXIST = unchecked((Int32)0x1040200d)

输入的相机增益不存在(增益个数已达上限)

◆ MV_ALG_E_DENOISE_GAIN_BEYOND_RANGE

const Int32 MvError.MV_ALG_E_DENOISE_GAIN_BEYOND_RANGE = unchecked((Int32)0x1040200e)

输入的相机增益不在范围内

◆ MV_ALG_E_DENOISE_NP_BUF_SIZE

const Int32 MvError.MV_ALG_E_DENOISE_NP_BUF_SIZE = unchecked((Int32)0x1040200f)

输入的噪声特性内存大小错误

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

属性 | 所有成员列表

MvException类 参考 状态码及异常

异常信息 更多...

继承自 Exception .

属性

Int32 ErrorCode [get]

错误码 更多...

详细描述

异常信息

属性说明

◆ ErrorCode

Int32 MvException.ErrorCode

get

错误码

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

示例程序概览

相机程序基础示例

采集卡程序基础示例

CameraLink采集卡参数配置

CoaXPress采集卡参数配置

网口采集卡参数配置

XoFlink采集卡参数配置

GenTL基础示例

线阵相机程序基础示例

采集卡枚举相机

红外相机基础功能

红外相机温度显示区域配置

红外相机温度报警参数配置

WPF程序调用SDK

配置线阵相机IO

通过IP地址连接GigE相机

重连相机

接收相机事件

接收采集卡事件

通过回调取图

轮询取图

通过ActionCommand触发取图

组播

配置取图策略

分时频闪

线阵相机分时曝光

深拷贝

保存图像数据

调节图像对比度

转换图像格式

无损解码

录像

获取相机配置文件

导入/导出相机配置文件

示例程序

示例程序概览

相机程序基础示例

采集卡程序基础示例

CameraLink采集卡参数配置

CoaXPress采集卡参数配置

网口采集卡参数配置

XoFlink采集卡参数配置

GenTL基础示例

线阵相机程序基础示例

采集卡枚举相机

红外相机基础功能

红外相机温度显示区域配置

红外相机温度报警参数配置

WPF程序调用SDK

配置线阵相机IO

通过IP地址连接GigE相机

重连相机

接收相机事件

接收采集卡事件

通过回调取图

轮询取图

通过ActionCommand触发取图

组播

配置取图策略

分时频闪

线阵相机分时曝光

深拷贝

保存图像数据

调节图像对比度

转换图像格式

无损解码

录像

获取相机配置文件

导入/导出相机配置文件

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

示例程序概览

以下为当前版本所有示例程序文件的简要说明。

注解

可从客户端安装路径下的 ..Development\Samples\C#\MvCameraControlNet_New 中获取对应的示例程序文件。

基础示例

以下为相机基础示例。

文件 示例 描述

BasicDemo.cs 相机程序基础示例 演示如何调用SDK接口实现机器视觉程序的常用功能，包括枚举、连接相机、配置参数、取图、保存图像等。

BasicDemoByGenTL.cs GenTL基础示例 演示如何基于GenTL模块实现第三方设备（包括相机和采集卡）连接、配置和取图等常用功能。

BasicDemoLineScan.cs 线阵相机程序基础示例 演示如何调用SDK接口实现线阵相机连接和配置。

InfraredDemo.cs 红外相机基础功能 演示如何实现红外相机的基本功能。

FormRegionSetting.cs 红外相机温度显示区域配置 演示如何配置红外相机的温度显示区域。

FormAlarmSetting.cs 红外相机温度报警参数配置 演示如何配置红外相机的温度报警参数。

以下为采集卡基础示例。

文件 示例 描述

InterfaceBasicDemo.cs 采集卡程序基础示例 演示如何调用SDK接口实现采集卡连接和配置。

CMLConfigForm.cs CameraLink采集卡参数配置 演示如何配置CameraLink采集卡的常用参数。

CXPConfigForm.cs CoaXPress采集卡参数配置 演示如何配置CoaXPress采集卡的常用参数。

GeVConfigForm.cs 网口采集卡参数配置 演示如何配置GigE Vision采集卡的常用参数。

XOFConfigForm.cs XoFlink采集卡参数配置 演示如何配置XoFlink采集卡的常用参数。

以下为WPF基础示例

文件 示例 描述

BasicDemoWindow.xaml.cs WPF程序调用SDK 演示如何在WPF程序中调用SDK。

相机连接示例

文件 示例 描述

GigE_ConnectCameraByIP.cs 通过IP地址连接GigE相机 演示如何基于GigE相机IP地址实现将该类相机连接至您的程序。

Reconnect.cs 重连相机 演示如何实现在相机异常断连时重连。

InterfaceAndDevices.cs 采集卡枚举相机 演示如何在打开采集卡后，通过采集卡枚举相机并取流。

事件接收示例

文件 示例 描述

Events_Camera.cs 接收相机事件 演示如何实现相机事件接收。

Events_Interface.cs 接收采集卡事件 演示如何实现采集卡事件接收。

图像采集示例

文件 示例 描述

Grab_Callback.cs 通过回调取图 演示如何通过回调方式取图（ FrameGrabedEvent ）。回调方式下，SDK内部开启取流线程，并通过event方式将相机采集的图像回调给您的程序。

ParameterCamera_LineScanIOSettings.cs 配置线阵相机IO 演示如何配置线阵相机帧触发和行触发相关节点IO，并通过回调方式取图。回调方式下，SDK内部开启取流线程，并通过event方式将相机采集的图像回调给您的程序。

Grab_GetImageBuffer.cs 轮询取图 演示如何创建取图线程，并轮询调用 IStreamGrabber.GetImageBuffer() / IStreamGrabber.FreeImageBuffer() 获取和释放相机所采集的图像。

Grab_Strategy.cs 配置取图策略 演示如何实现取图策略功能。

Grab_ActionCommand.cs 通过ActionCommand触发取图 演示如何实现通过GigE Vision相机的ActionCommand属性，触发该类相机采集图像。

Grab_GigEMultiCast.cs 组播 演示如何在您的程序实现GigE Vision相机的组播（MultiCast）功能。

MultiLightCtrl.cs 分时频闪 演示如何实现从支持分时频闪或多重曝光功能的相机中获取图像和重建图像。

MultiLightCtrl_ImageStitching.cs 线阵相机分时曝光 演示如何实现从支持分时曝光功能的线阵相机中获取图像和重建图像。

Grab_ImageClone.cs 深拷贝 演示如何实现在取图时深拷贝图像，并将图像放入队列，进行异步处理。

图像处理示例

文件 示例 描述

Image_Contrast.cs 调节图像对比度 演示如何实现图像对比度调节功能。

Image_ConvertPixelType.cs 转换图像格式 演示如何实现图像格式转换功能。

Image_Save.cs 格式转换 演示如何使用格式转换功能。

Image_HBDecode.cs 无损解码 演示如何实现图像无损解码。

Image_Recording.cs 录像 演示如何实现录像功能。

设备参数配置示例

文件 示例 描述

ParameterCamera_FileAccess.cs 获取相机配置文件 演示如何实现“相机配置文件获取”功能。

ParameterCamera_LoadAndSave.cs 导入/导出相机配置文件 演示如何实现“相机配置文件导入/导出”功能。

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

相机程序基础示例（BasicDemo.cs）

该示例演示如何调用SDK接口实现机器视觉程序的常用功能，包括枚举、连接相机、配置参数、取图、保存图像等。 using MvCameraControl; using System; using System.Collections.Generic; using System.Drawing; using System.Threading; using System.Windows.Forms;

namespace BasicDemo {

public partial class Form1 : Form {

readonly DeviceTLayerType enumTLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLGigEDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLXoFDevice;

List<IDeviceInfo> deviceInfoList = new List<IDeviceInfo>(); IDevice device = null;

bool isGrabbing = false; // ch:是否正在取图 | en: Grabbing flag bool isRecord = false; // ch:是否正在录像 | en: Video record flag Thread receiveThread = null; // ch:接收图像线程 | en: Receive image thread

private IFrameOut frameForSave; // ch:获取到的帧信息, 用于保存图像 | en:Frame for save image private readonly object saveImageLock = new object();

public Form1() {

InitializeComponent();

SDKSystem.Initialize();

RefreshDeviceList(); Control.CheckForIllegalCrossThreadCalls = false; }

// ch:显示错误信息 | en:Show error message private void ShowErrorMsg(string message, int errorCode) {

string errorMsg; if (errorCode == 0) {

errorMsg = message; }

else {

errorMsg = message + ": Error =" + String.Format("{0:X}", errorCode); }

switch (errorCode) {

case MvError.MV_E_HANDLE: errorMsg += " Error or invalid handle "; break; case MvError.MV_E_SUPPORT: errorMsg += " Not supported function "; break; case MvError.MV_E_BUFOVER: errorMsg += " Cache is full "; break; case MvError.MV_E_CALLORDER: errorMsg += " Function calling order error "; break; case MvError.MV_E_PARAMETER: errorMsg += " Incorrect parameter "; break; case MvError.MV_E_RESOURCE: errorMsg += " Applying resource failed "; break; case MvError.MV_E_NODATA: errorMsg += " No data "; break; case MvError.MV_E_PRECONDITION: errorMsg += " Precondition error, or running environment changed "; break; case MvError.MV_E_VERSION: errorMsg += " Version mismatches "; break; case MvError.MV_E_NOENOUGH_BUF: errorMsg += " Insufficient memory "; break; case MvError.MV_E_UNKNOW: errorMsg += " Unknown error "; break; case MvError.MV_E_GC_GENERIC: errorMsg += " General error "; break; case MvError.MV_E_GC_ACCESS: errorMsg += " Node accessing condition error "; break; case MvError.MV_E_ACCESS_DENIED: errorMsg += " No permission "; break; case MvError.MV_E_BUSY: errorMsg += " Device is busy, or network disconnected "; break; case MvError.MV_E_NETER: errorMsg += " Network error "; break; }

MessageBox.Show(errorMsg, "PROMPT"); }

private void bnEnum_Click(object sender, EventArgs e) {

RefreshDeviceList(); }

private void RefreshDeviceList() {

// ch:创建设备列表 | en:Create Device List cbDeviceList.Items.Clear(); int nRet = DeviceEnumerator.EnumDevices(enumTLayerType, out deviceInfoList); if (nRet != MvError.MV_OK) {

ShowErrorMsg("Enumerate devices fail!", nRet); return; }

// ch:在窗体列表中显示设备名 | en:Display device name in the form list for (int i = 0; i < deviceInfoList.Count; i++) {

IDeviceInfo deviceInfo = deviceInfoList[i]; if (deviceInfo.UserDefinedName != "") {

cbDeviceList.Items.Add(deviceInfo.TLayerType.ToString() + ": " + deviceInfo.UserDefinedName + " (" + deviceInfo.SerialNumber + ")"); }

else {

cbDeviceList.Items.Add(deviceInfo.TLayerType.ToString() + ": " + deviceInfo.ManufacturerName + " " + deviceInfo.ModelName + " (" + deviceInfo.SerialNumber + ")"); }

}

// ch:选择第一项 | en:Select the first item if (deviceInfoList.Count != 0) {

cbDeviceList.SelectedIndex = 0; }

}

private void SetCtrlWhenOpen() {

bnOpen.Enabled = false;

bnClose.Enabled = true; bnStartGrab.Enabled = true; bnStopGrab.Enabled = false; bnContinuesMode.Enabled = true; bnContinuesMode.Checked = true; bnTriggerMode.Enabled = true; cbSoftTrigger.Enabled = false; bnTriggerExec.Enabled = false;

tbExposure.Enabled = true; tbGain.Enabled = true; tbFrameRate.Enabled = true; cbPixelFormat.Enabled = true; bnGetParam.Enabled = true; bnSetParam.Enabled = true; }

private void bnOpen_Click(object sender, EventArgs e) {

if (deviceInfoList.Count == 0 || cbDeviceList.SelectedIndex == -1) {

ShowErrorMsg("No device, please select", 0); return; }

// ch:获取选择的设备信息 | en:Get selected device information IDeviceInfo deviceInfo = deviceInfoList[cbDeviceList.SelectedIndex];

try {

// ch:打开设备 | en:Open device device = DeviceFactory.CreateDevice(deviceInfo); }

catch (Exception ex) {

MessageBox.Show("Create Device fail!" + ex.Message); return; }

int result = device.Open(); if (result != MvError.MV_OK) {

ShowErrorMsg("Open Device fail!", result); return; }

//ch: 判断是否为gige设备 | en: Determine whether it is a GigE device if (device is IGigEDevice) {

//ch: 转换为gigE设备 | en: Convert to Gige device IGigEDevice gigEDevice = device as IGigEDevice;

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) int optionPacketSize; result = gigEDevice.GetOptimalPacketSize(out optionPacketSize); if (result != MvError.MV_OK) {

ShowErrorMsg("Warning: Get Packet Size failed!", result); }

else {

result = device.Parameters.SetIntValue("GevSCPSPacketSize", (long)optionPacketSize); if (result != MvError.MV_OK) {

ShowErrorMsg("Warning: Set Packet Size failed!", result); }

}

}

// ch:设置采集连续模式 | en:Set Continues Aquisition Mode device.Parameters.SetEnumValueByString("AcquisitionMode", "Continuous"); device.Parameters.SetEnumValueByString("TriggerMode", "Off");

// ch:控件操作 | en:Control operation SetCtrlWhenOpen();

// ch:获取参数 | en:Get parameters bnGetParam_Click(null, null); }

private void SetCtrlWhenClose() {

bnOpen.Enabled = true;

bnClose.Enabled = false; bnStartGrab.Enabled = false; bnStopGrab.Enabled = false; bnContinuesMode.Enabled = false; bnTriggerMode.Enabled = false; cbSoftTrigger.Enabled = false; bnTriggerExec.Enabled = false;

bnSaveBmp.Enabled = false; bnSaveJpg.Enabled = false; bnSaveTiff.Enabled = false; bnSavePng.Enabled = false; tbExposure.Enabled = false; tbGain.Enabled = false; tbFrameRate.Enabled = false; bnGetParam.Enabled = false; bnSetParam.Enabled = false; cbPixelFormat.Enabled = false; bnStartRecord.Enabled = false; bnStopRecord.Enabled = false; }

private void bnClose_Click(object sender, EventArgs e) {

// ch:取流标志位清零 | en:Reset flow flag bit if (isGrabbing == true) {

bnStopGrab_Click(sender, e); }

// ch:关闭设备 | en:Close Device if (device != null) {

device.Close(); device.Dispose();

}

// ch:控件操作 | en:Control Operation SetCtrlWhenClose(); }

private void bnContinuesMode_CheckedChanged(object sender, EventArgs e) {

if (bnContinuesMode.Checked) {

device.Parameters.SetEnumValueByString("TriggerMode", "Off"); cbSoftTrigger.Enabled = false; bnTriggerExec.Enabled = false; }

}

private void bnTriggerMode_CheckedChanged(object sender, EventArgs e) {

// ch:打开触发模式 | en:Open Trigger Mode if (bnTriggerMode.Checked) {

device.Parameters.SetEnumValueByString("TriggerMode", "On");

// ch:触发源选择:0 - Line0; | en:Trigger source select:0 - Line0; // 1 - Line1; // 2 - Line2; // 3 - Line3; // 4 - Counter; // 7 - Software; if (cbSoftTrigger.Checked) {

device.Parameters.SetEnumValueByString("TriggerSource", "Software"); if (isGrabbing) {

bnTriggerExec.Enabled = true; }

}

else {

device.Parameters.SetEnumValueByString("TriggerSource", "Line0"); }

cbSoftTrigger.Enabled = true; }

}

private void SetCtrlWhenStartGrab() {

bnStartGrab.Enabled = false; cbPixelFormat.Enabled = false; bnStopGrab.Enabled = true;

if (bnTriggerMode.Checked && cbSoftTrigger.Checked) {

bnTriggerExec.Enabled = true; }

bnSaveBmp.Enabled = true; bnSaveJpg.Enabled = true; bnSaveTiff.Enabled = true; bnSavePng.Enabled = true; bnStartRecord.Enabled = true; bnStopRecord.Enabled = false; }

public void ReceiveThreadProcess() {

int nRet;

Graphics graphics; // ch:使用GDI在pictureBox上绘制图像 | en:Display frame using a graphics

while (isGrabbing) {

IFrameOut frameOut;

nRet = device.StreamGrabber.GetImageBuffer(1000, out frameOut); if (MvError.MV_OK == nRet) {

if (isRecord) {

device.VideoRecorder.InputOneFrame(frameOut.Image); }

lock (saveImageLock) {

frameForSave = frameOut.Clone() as IFrameOut; }

#if !GDI_RENDER

device.ImageRender.DisplayOneFrame(pictureBox1.Handle, frameOut.Image); #else // 使用GDI绘制图像

try {

using (Bitmap bitmap = frameOut.Image.ToBitmap()) {

if (graphics == null) {

graphics = pictureBox1.CreateGraphics(); }

Rectangle srcRect = new Rectangle(0, 0, bitmap.Width, bitmap.Height); Rectangle dstRect = new Rectangle(0, 0, pictureBox1.Width, pictureBox1.Height); graphics.DrawImage(bitmap, dstRect, srcRect, GraphicsUnit.Pixel); }

}

catch (Exception e) {

device.StreamGrabber.FreeImageBuffer(frameOut); MessageBox.Show(e.Message); return; }

#endif

device.StreamGrabber.FreeImageBuffer(frameOut); }

else {

if (bnTriggerMode.Checked) {

Thread.Sleep(5);

}

}

}

}

private void bnStartGrab_Click(object sender, EventArgs e) {

try {

// ch:标志位置位true | en:Set position bit true isGrabbing = true;

receiveThread = new Thread(ReceiveThreadProcess); receiveThread.Start(); }

catch (Exception ex) {

MessageBox.Show("Start thread failed!, " + ex.Message); throw; }

// ch:开始采集 | en:Start Grabbing int result = device.StreamGrabber.StartGrabbing(); if (result != MvError.MV_OK) {

isGrabbing = false; receiveThread.Join(); ShowErrorMsg("Start Grabbing Fail!", result); return; }

// ch:控件操作 | en:Control Operation SetCtrlWhenStartGrab(); }

private void cbSoftTrigger_CheckedChanged(object sender, EventArgs e) {

if (cbSoftTrigger.Checked) {

// ch:触发源设为软触发 | en:Set trigger source as Software device.Parameters.SetEnumValueByString("TriggerSource", "Software"); if (isGrabbing) {

bnTriggerExec.Enabled = true; }

}

else {

device.Parameters.SetEnumValueByString("TriggerSource", "Line0"); bnTriggerExec.Enabled = false; }

}

private void bnTriggerExec_Click(object sender, EventArgs e) {

// ch:触发命令 | en:Trigger command int result = device.Parameters.SetCommandValue("TriggerSoftware"); if (result != MvError.MV_OK) {

ShowErrorMsg("Trigger Software Fail!", result); }

}

private void SetCtrlWhenStopGrab() {

bnStartGrab.Enabled = true; cbPixelFormat.Enabled = true; bnStopGrab.Enabled = false; bnTriggerExec.Enabled = false;

bnSaveBmp.Enabled = false; bnSaveJpg.Enabled = false; bnSaveTiff.Enabled = false; bnSavePng.Enabled = false; bnStartRecord.Enabled = false; bnStopRecord.Enabled = false; }

private void bnStopGrab_Click(object sender, EventArgs e) {

// ch:标志位设为false | en:Set flag bit false isGrabbing = false; receiveThread.Join();

// ch:停止采集 | en:Stop Grabbing int result = device.StreamGrabber.StopGrabbing(); if (result != MvError.MV_OK) {

ShowErrorMsg("Stop Grabbing Fail!", result); }

// ch:控件操作 | en:Control Operation SetCtrlWhenStopGrab(); }

private int SaveImage(ImageFormatInfo imageFormatInfo) {

if (frameForSave == null) {

throw new Exception("No vaild image"); }

string imagePath = "Image_w" + frameForSave.Image.Width.ToString() + "_h" + frameForSave.Image.Height.ToString() + "_fn" + frameForSave.FrameNum.ToString() + "." + imageFormatInfo.FormatType.ToString();

lock (saveImageLock) {

return device.ImageSaver.SaveImageToFile(imagePath, frameForSave.Image, imageFormatInfo, CFAMethod.Optimal); }

}

private void bnSaveBmp_Click(object sender, EventArgs e) {

int result;

try {

ImageFormatInfo imageFormatInfo = new ImageFormatInfo(); imageFormatInfo.FormatType = ImageFormatType.Bmp;

result = SaveImage(imageFormatInfo); if (result != MvError.MV_OK) {

ShowErrorMsg("Save Image Fail!", result); return; }

else {

ShowErrorMsg("Save Image Succeed!", 0); }

}

catch (Exception ex) {

MessageBox.Show("Save Image Failed, " + ex.Message); return; }

}

private void bnSaveJpg_Click(object sender, EventArgs e) {

int result;

try {

ImageFormatInfo imageFormatInfo; imageFormatInfo.FormatType = ImageFormatType.Jpeg; imageFormatInfo.JpegQuality = 80;

result = SaveImage(imageFormatInfo); if (result != MvError.MV_OK) {

ShowErrorMsg("Save Image Fail!", result); return; }

else {

ShowErrorMsg("Save Image Succeed!", 0); }

}

catch (Exception ex) {

MessageBox.Show("Save Image Failed, " + ex.Message); return; }

}

private void bnSavePng_Click(object sender, EventArgs e) {

int result;

try {

ImageFormatInfo imageFormatInfo = new ImageFormatInfo(); imageFormatInfo.FormatType = ImageFormatType.Png;

result = SaveImage(imageFormatInfo); if (result != MvError.MV_OK) {

ShowErrorMsg("Save Image Fail!", result); return; }

else {

ShowErrorMsg("Save Image Succeed!", 0); }

}

catch (Exception ex) {

MessageBox.Show("Save Image Failed, " + ex.Message); return; }

}

private void bnSaveTiff_Click(object sender, EventArgs e) {

int result; try {

ImageFormatInfo imageFormatInfo = new ImageFormatInfo(); imageFormatInfo.FormatType = ImageFormatType.Tiff;

result = SaveImage(imageFormatInfo); if (result != MvError.MV_OK) {

ShowErrorMsg("Save Image Fail!", result); return; }

else {

ShowErrorMsg("Save Image Succeed!", 0); }

}

catch (Exception ex) {

MessageBox.Show("Save Image Failed, " + ex.Message); return; }

}

private void GetTriggerMode() {

IEnumValue enumValue; int result = device.Parameters.GetEnumValue("TriggerMode", out enumValue); if (result == MvError.MV_OK) {

if (enumValue.CurEnumEntry.Symbolic == "On") {

bnTriggerMode.Checked = true; bnContinuesMode.Checked = false;

result = device.Parameters.GetEnumValue("TriggerSource", out enumValue); if (result == MvError.MV_OK) {

if (enumValue.CurEnumEntry.Symbolic == "TriggerSoftware") {

cbSoftTrigger.Enabled = true; cbSoftTrigger.Checked = true; if (isGrabbing) {

bnTriggerExec.Enabled = true; }

}

}

}

else {

bnContinuesMode.Checked = true; bnTriggerMode.Checked = false; }

}

}

private void bnGetParam_Click(object sender, EventArgs e) {

GetTriggerMode();

IFloatValue floatValue; int result = device.Parameters.GetFloatValue("ExposureTime", out floatValue); if (result == MvError.MV_OK) {

tbExposure.Text = floatValue.CurValue.ToString("F1"); }

result = device.Parameters.GetFloatValue("Gain", out floatValue); if (result == MvError.MV_OK) {

tbGain.Text = floatValue.CurValue.ToString("F1"); }

result = device.Parameters.GetFloatValue("ResultingFrameRate", out floatValue); if (result == MvError.MV_OK) {

tbFrameRate.Text = floatValue.CurValue.ToString("F1"); }

cbPixelFormat.Items.Clear(); IEnumValue enumValue; result = device.Parameters.GetEnumValue("PixelFormat", out enumValue); if (result == MvError.MV_OK) {

foreach (var item in enumValue.SupportEnumEntries) {

cbPixelFormat.Items.Add(item.Symbolic); if (item.Symbolic == enumValue.CurEnumEntry.Symbolic) {

cbPixelFormat.SelectedIndex = cbPixelFormat.Items.Count - 1; }

}

}

}

private void bnSetParam_Click(object sender, EventArgs e) {

try {

float.Parse(tbExposure.Text); float.Parse(tbGain.Text); float.Parse(tbFrameRate.Text); }

catch {

ShowErrorMsg("Please enter correct type!", 0); return; }

device.Parameters.SetEnumValue("ExposureAuto", 0); int result = device.Parameters.SetFloatValue("ExposureTime", float.Parse(tbExposure.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set Exposure Time Fail!", result); }

device.Parameters.SetEnumValue("GainAuto", 0); result = device.Parameters.SetFloatValue("Gain", float.Parse(tbGain.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set Gain Fail!", result); }

result = device.Parameters.SetFloatValue("AcquisitionFrameRate", float.Parse(tbFrameRate.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set Frame Rate Fail!", result); }

}

private void Form1_FormClosing(object sender, FormClosingEventArgs e) {

bnClose_Click(sender, e);

SDKSystem.Finalize(); }

private void SetCtrlWhenStartRecord() {

bnStartRecord.Enabled = false; bnStopRecord.Enabled = true; }

private void bnStartRecord_Click(object sender, EventArgs e) {

if (false == isGrabbing) {

ShowErrorMsg("Not Start Grabbing", 0); return; }

IIntValue intValue; IEnumValue enumValue;

uint width;

uint height;

MvGvspPixelType pixelType;

int result;

result = device.Parameters.GetIntValue("Width", out intValue); if (result != MvError.MV_OK) {

ShowErrorMsg("Get Width failed!", result); return; }

width = (uint)intValue.CurValue;

result = device.Parameters.GetIntValue("Height", out intValue); if (result != MvError.MV_OK) {

ShowErrorMsg("Get Height failed!", result); return; }

height = (uint)intValue.CurValue;

result = device.Parameters.GetEnumValue("PixelFormat", out enumValue); if (result != MvError.MV_OK) {

ShowErrorMsg("Get PixelFormat failed!", result); return; }

pixelType = (MvGvspPixelType)enumValue.CurEnumEntry.Value;

// ch:开始录像 | en:Start record RecordParam recordParam; recordParam.Width = width; recordParam.Height = height; recordParam.PixelType = pixelType; recordParam.FrameRate = float.Parse(tbFrameRate.Text); recordParam.BitRate = 1000; recordParam.FormatType = VideoFormatType.AVI;

result = device.VideoRecorder.StartRecord("./Record.avi", recordParam); if (result != MvError.MV_OK) {

ShowErrorMsg("Start Record Fail!", result); return; }

isRecord = true;

SetCtrlWhenStartRecord(); }

private void SetCtrlWhenStopRecord() {

bnStartRecord.Enabled = true; bnStopRecord.Enabled = false; }

private void bnStopRecord_Click(object sender, EventArgs e) {

if (false == isGrabbing) {

ShowErrorMsg("Not Start Grabbing", 0); return; }

int result = device.VideoRecorder.StopRecord(); if (result != MvError.MV_OK) {

ShowErrorMsg("Stop Record Fail!", result); }

isRecord = false; SetCtrlWhenStopRecord(); }

private void cbPixelFormat_SelectionChangeCommitted(object sender, EventArgs e) {

int result = device.Parameters.SetEnumValueByString("PixelFormat", cbPixelFormat.Text); if (result != MvError.MV_OK) {

ShowErrorMsg("Set PixelFormat failed!", result); }

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

采集卡程序基础示例（InterfaceBasicDemo.cs）

该示例演示如何调用SDK接口实现采集卡连接和配置。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using System.Runtime.InteropServices; using System.Threading; using System.IO;

using System.Drawing.Imaging; using System.Diagnostics; using System.Collections.ObjectModel; using MvCameraControl;

namespace InterfaceBasicDemo {

public partial class InterfaceBasicDemo : Form {

List<IInterfaceInfo> _interfaceInfoList = new List<IInterfaceInfo>(); int iInterfaceTypeIndex = 0; int iInterfaceIndex = 0; int nRet = MvError.MV_OK;

IInterface _ifInstance = null; bool m_bOpenInterface; // ch:是否打开采集卡 | en:Whether to open Interface

public static CXPConfigForm CXPCfgForm = null; public static CMLConfigForm CMLCfgForm = null; public static XOFConfigForm XOFCfgForm = null; public static GEVConfigForm GEVCfgForm = null;

public InterfaceBasicDemo() {

InitializeComponent(); m_bOpenInterface = false; cbInterfaceType.Items.Clear(); cbInterfaceType.Items.Add("GIGE_INTERFACE"); cbInterfaceType.Items.Add("CAMERALINK_INTERFACE"); cbInterfaceType.Items.Add("CXP_INTERFACE"); cbInterfaceType.Items.Add("XOF_INTERFACE"); cbInterfaceType.SelectedIndex = 0;

EnableControls(false); this.Load += new EventHandler(this.InterfaceBasicDemo_Load); }

private void InterfaceBasicDemo_Load(object sender, EventArgs e) {

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize(); }

// ch:显示错误信息 | en:Show error message private void ShowErrorMsg(string csMessage, int nErrorNum) {

string errorMsg; if (nErrorNum == 0) {

errorMsg = csMessage; }

else {

errorMsg = csMessage + ": Error =" + String.Format("{0:X}", nErrorNum); }

switch (nErrorNum) {

case MvError.MV_E_HANDLE: errorMsg += "Error or invalid handle "; break; case MvError.MV_E_SUPPORT: errorMsg += "Not supported function "; break; case MvError.MV_E_BUFOVER: errorMsg += "Cache is full "; break; case MvError.MV_E_CALLORDER: errorMsg += "Function calling order error "; break; case MvError.MV_E_PARAMETER: errorMsg += "Incorrect parameter "; break; case MvError.MV_E_RESOURCE: errorMsg += "Applying resource failed "; break; case MvError.MV_E_NODATA: errorMsg += "No data "; break; case MvError.MV_E_PRECONDITION: errorMsg += "Precondition error, or running environment changed "; break; case MvError.MV_E_VERSION: errorMsg += "Version mismatches "; break; case MvError.MV_E_NOENOUGH_BUF: errorMsg += "Insufficient memory "; break; case MvError.MV_E_ABNORMAL_IMAGE: errorMsg += "Abnormal image, maybe incomplete image because of lost packet "; break; case MvError.MV_E_UNKNOW: errorMsg += "Unknown error "; break; case MvError.MV_E_GC_GENERIC: errorMsg += "General error "; break; case MvError.MV_E_GC_ACCESS: errorMsg += "Node accessing condition error "; break; case MvError.MV_E_ACCESS_DENIED: errorMsg += "No permission "; break; case MvError.MV_E_BUSY: errorMsg += "Device is busy, or network disconnected "; break; case MvError.MV_E_NETER: errorMsg += "Network error "; break; }

MessageBox.Show(errorMsg, "PROMPT"); }

private void EnableControls(bool bIsCameraReady) {

bnOpen.Enabled = (bIsCameraReady ? true : false); bnClose.Enabled = ((m_bOpenInterface && bIsCameraReady) ? true : false); bnConfig.Enabled = ((m_bOpenInterface && bIsCameraReady) ? true : false); }

private void cbInterfaceType_SelectedIndexChanged(object sender, EventArgs e) {

bnClose_Click(sender, e); iInterfaceTypeIndex = cbInterfaceType.SelectedIndex; cbInterfaceList.Items.Clear(); cbInterfaceList.Text = ""; }

private void bnEnum_Click(object sender, EventArgs e) {

cbInterfaceList.Items.Clear(); cbInterfaceList.Text = "";

switch (iInterfaceTypeIndex) {

case 0: {

nRet = InterfaceEnumerator.EnumInterfaces(InterfaceTLayerType.MvGigEInterface, out _interfaceInfoList); break; }

case 1: {

nRet = InterfaceEnumerator.EnumInterfaces(InterfaceTLayerType.MvCameraLinkInterface, out _interfaceInfoList); break; }

case 2: {

nRet = InterfaceEnumerator.EnumInterfaces(InterfaceTLayerType.MvCXPInterface, out _interfaceInfoList); break; }

case 3: {

nRet = InterfaceEnumerator.EnumInterfaces(InterfaceTLayerType.MvXoFInterface, out _interfaceInfoList); break; }

}

// ch:在窗体列表中显示设备名 | en:Display device name in the form list for (int i = 0; i < _interfaceInfoList.Count; i++) {

string strShowIfInfo = null; strShowIfInfo += "[" + i.ToString() + "]: " + _interfaceInfoList[i].DisplayName + " | " + _interfaceInfoList[i].InterfaceID + " | " + _interfaceInfoList[i].SerialNumber; cbInterfaceList.Items.Add(strShowIfInfo); }

// ch:选择第一项 | en:Select the first item if (_interfaceInfoList.Count != 0) {

cbInterfaceList.SelectedIndex = 0; EnableControls(true); }

}

private void bnOpen_Click(object sender, EventArgs e) {

if (_interfaceInfoList.Count == 0 || cbInterfaceList.SelectedIndex == -1) {

ShowErrorMsg("No device, please select", 0); return; }

// ch:获取选择的设备信息 | en:Get selected device information

try {

_ifInstance = InterfaceFactory.CreateInterface(_interfaceInfoList[iInterfaceIndex]); }

catch (MvException ex) {

ShowErrorMsg("Create Interface fail!", nRet); return; }

// ch:打开设备 | en:Open device

nRet = _ifInstance.Open(); if (MvError.MV_OK != nRet) {

_ifInstance.Dispose(); _ifInstance = null; ShowErrorMsg("Interface open fail!", nRet); return; }

m_bOpenInterface = true; EnableControls(true); }

private void bnClose_Click(object sender, EventArgs e) {

if (_ifInstance != null) {

_ifInstance.Close(); _ifInstance.Dispose(); }

m_bOpenInterface = false; EnableControls(true); }

private void bnConfig_Click(object sender, EventArgs e) {

switch (iInterfaceTypeIndex) {

case 0: {

InterfaceBasicDemo.GEVCfgForm = null; GEVCfgForm = new GEVConfigForm(_ifInstance); GEVCfgForm.ShowDialog(); break; }

case 1: {

InterfaceBasicDemo.CMLCfgForm = null; CMLCfgForm = new CMLConfigForm(_ifInstance); CMLCfgForm.ShowDialog(); break; }

case 2: {

InterfaceBasicDemo.CXPCfgForm = null; CXPCfgForm = new CXPConfigForm(_ifInstance); CXPCfgForm.ShowDialog(); break; }

case 3: {

InterfaceBasicDemo.XOFCfgForm = null; XOFCfgForm = new XOFConfigForm(_ifInstance); XOFCfgForm.ShowDialog(); break; }

}

}

private void Form1_FormClosing(object sender, FormClosingEventArgs e) {

bnClose_Click(sender, e);

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize(); }

private void cbInterfaceList_SelectedIndexChanged(object sender, EventArgs e) {

bnClose_Click(sender, e); iInterfaceIndex = cbInterfaceList.SelectedIndex; }

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

CameraLink采集卡参数配置 （CMLConfigForm.cs）

该示例演示如何配置CameraLink采集卡的常用参数。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using MvCameraControl;

namespace InterfaceBasicDemo {

public partial class CMLConfigForm : Form {

IInterface _ifInstance;

bool bIni = false;

private int ReadEnumIntoCombo(string strKey, ref ComboBox ctrlComboBox) {

IEnumValue enumValue; int ret = _ifInstance.Parameters.GetEnumValue(strKey, out enumValue); if (ret != MvError.MV_OK) {

return ret; }

ctrlComboBox.Items.Clear(); for (int i = 0; i < enumValue.SupportedNum; ++i) {

ctrlComboBox.Items.Add(enumValue.SupportEnumEntries[i].Symbolic); }

int nIndex = ctrlComboBox.FindString(enumValue.CurEnumEntry.Symbolic); if (nIndex >= 0) {

ctrlComboBox.SelectedIndex = nIndex; }

return MvError.MV_OK; }

// ch:显示错误信息 | en:Show error message private void ShowErrorMsg(string csMessage, int nErrorNum) {

string errorMsg; if (nErrorNum == 0) {

errorMsg = csMessage; }

else {

errorMsg = csMessage + ": Error =" + String.Format("{0:X}", nErrorNum); }

switch (nErrorNum) {

case MvError.MV_E_HANDLE: errorMsg += "Error or invalid handle "; break; case MvError.MV_E_SUPPORT: errorMsg += "Not supported function "; break; case MvError.MV_E_BUFOVER: errorMsg += "Cache is full "; break; case MvError.MV_E_CALLORDER: errorMsg += "Function calling order error "; break; case MvError.MV_E_PARAMETER: errorMsg += "Incorrect parameter "; break; case MvError.MV_E_RESOURCE: errorMsg += "Applying resource failed "; break; case MvError.MV_E_NODATA: errorMsg += "No data "; break; case MvError.MV_E_PRECONDITION: errorMsg += "Precondition error, or running environment changed "; break; case MvError.MV_E_VERSION: errorMsg += "Version mismatches "; break; case MvError.MV_E_NOENOUGH_BUF: errorMsg += "Insufficient memory "; break; case MvError.MV_E_ABNORMAL_IMAGE: errorMsg += "Abnormal image, maybe incomplete image because of lost packet "; break; case MvError.MV_E_UNKNOW: errorMsg += "Unknown error "; break; case MvError.MV_E_GC_GENERIC: errorMsg += "General error "; break; case MvError.MV_E_GC_ACCESS: errorMsg += "Node accessing condition error "; break; case MvError.MV_E_ACCESS_DENIED: errorMsg += "No permission "; break; case MvError.MV_E_BUSY: errorMsg += "Device is busy, or network disconnected "; break; case MvError.MV_E_NETER: errorMsg += "Network error "; break; }

MessageBox.Show(errorMsg, "PROMPT"); }

public int SetEnumIntoCombo(string strKey, ref ComboBox ctrlComboBox) {

string str = ctrlComboBox.SelectedItem.ToString(); IEnumValue enumValue; int ret = _ifInstance.Parameters.GetEnumValue(strKey, out enumValue); if (ret != MvError.MV_OK) {

return ret; }

for (int i = 0; i < enumValue.SupportedNum; ++i) {

if (str.Equals(enumValue.SupportEnumEntries[i].Symbolic, StringComparison.OrdinalIgnoreCase)) {

ret = _ifInstance.Parameters.SetEnumValue(strKey, enumValue.SupportEnumEntries[i].Value); if (ret != MvError.MV_OK) {

return ret; }

break; }

}

return ret; }

public void InitParameter() {

if (null == _ifInstance) {

return; }

teImageHeight.Enabled = true; teFrameTimeoutTime.Enabled = true; ReadEnumIntoCombo("StreamSelector", ref cbStreamSelector);

ReadEnumIntoCombo("CameraType", ref cbCameraType);

IIntValue intValue; _ifInstance.Parameters.GetIntValue("ImageHeight", out intValue); teImageHeight.Text = intValue.CurValue.ToString(); _ifInstance.Parameters.GetIntValue("FrameTimeoutTime", out intValue); teFrameTimeoutTime.Text = intValue.CurValue.ToString();

ReadEnumIntoCombo("StreamPartialImageControl", ref cbStreamPartialImageControl);

bIni = true; }

public CMLConfigForm() {

InitializeComponent(); }

public CMLConfigForm(IInterface ifInstance) : this()

{

_ifInstance = ifInstance;

InitParameter(); }

private void cbStreamSelector_SelectedIndexChanged(object sender, EventArgs e) {

if (false == bIni) {

return; }

int ret = SetEnumIntoCombo("StreamSelector", ref cbStreamSelector); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set StreamSelector Fail!", ret); }

}

private void cbCameraType_SelectedIndexChanged(object sender, EventArgs e) {

if (false == bIni) {

return; }

int ret = SetEnumIntoCombo("CameraType", ref cbCameraType); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set CameraType Fail!", ret); }

}

private void cbStreamPartialImageControl_SelectedIndexChanged(object sender, EventArgs e) {

if (false == bIni) {

return; }

int ret = SetEnumIntoCombo("StreamPartialImageControl", ref cbStreamPartialImageControl); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set StreamPartialImageControl Fail!", ret); }

}

private void bnGetParameter_Click(object sender, EventArgs e) {

InitParameter(); }

private void bnSetParameter_Click(object sender, EventArgs e) {

try {

int.Parse(teImageHeight.Text); int.Parse(teFrameTimeoutTime.Text); }

catch {

ShowErrorMsg("Please enter correct type!", 0); return; }

int ret = _ifInstance.Parameters.SetIntValue("ImageHeight", int.Parse(teImageHeight.Text)); if (MvError.MV_OK != ret) {

ShowErrorMsg("Set ImageHeight Fail!", ret); }

ret = _ifInstance.Parameters.SetIntValue("FrameTimeoutTime", int.Parse(teFrameTimeoutTime.Text)); if (MvError.MV_OK != ret) {

ShowErrorMsg("Set FrameTimeoutTime Fail!", ret); }

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

CoaXPress采集卡参数配置 （CXPConfigForm.cs）

该示例演示如何配置CoaXPress采集卡的常用参数。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using MvCameraControl;

namespace InterfaceBasicDemo {

public partial class CXPConfigForm : Form {

IInterface _ifInstance;

bool bIni = false;

private int ReadEnumIntoCombo(string strKey, ref ComboBox ctrlComboBox) {

IEnumValue enumValue; int ret = _ifInstance.Parameters.GetEnumValue(strKey, out enumValue); if (ret != MvError.MV_OK) {

return ret; }

ctrlComboBox.Items.Clear(); for (int i = 0; i < enumValue.SupportedNum; ++i) {

ctrlComboBox.Items.Add(enumValue.SupportEnumEntries[i].Symbolic); }

int nIndex = ctrlComboBox.FindString(enumValue.CurEnumEntry.Symbolic); if (nIndex >= 0) {

ctrlComboBox.SelectedIndex = nIndex; }

return MvError.MV_OK; }

// ch:显示错误信息 | en:Show error message private void ShowErrorMsg(string csMessage, int nErrorNum) {

string errorMsg; if (nErrorNum == 0) {

errorMsg = csMessage; }

else {

errorMsg = csMessage + ": Error =" + String.Format("{0:X}", nErrorNum); }

switch (nErrorNum) {

case MvError.MV_E_HANDLE: errorMsg += "Error or invalid handle "; break; case MvError.MV_E_SUPPORT: errorMsg += "Not supported function "; break; case MvError.MV_E_BUFOVER: errorMsg += "Cache is full "; break; case MvError.MV_E_CALLORDER: errorMsg += "Function calling order error "; break; case MvError.MV_E_PARAMETER: errorMsg += "Incorrect parameter "; break; case MvError.MV_E_RESOURCE: errorMsg += "Applying resource failed "; break; case MvError.MV_E_NODATA: errorMsg += "No data "; break; case MvError.MV_E_PRECONDITION: errorMsg += "Precondition error, or running environment changed "; break; case MvError.MV_E_VERSION: errorMsg += "Version mismatches "; break; case MvError.MV_E_NOENOUGH_BUF: errorMsg += "Insufficient memory "; break; case MvError.MV_E_ABNORMAL_IMAGE: errorMsg += "Abnormal image, maybe incomplete image because of lost packet "; break; case MvError.MV_E_UNKNOW: errorMsg += "Unknown error "; break; case MvError.MV_E_GC_GENERIC: errorMsg += "General error "; break; case MvError.MV_E_GC_ACCESS: errorMsg += "Node accessing condition error "; break; case MvError.MV_E_ACCESS_DENIED: errorMsg += "No permission "; break; case MvError.MV_E_BUSY: errorMsg += "Device is busy, or network disconnected "; break; case MvError.MV_E_NETER: errorMsg += "Network error "; break; }

MessageBox.Show(errorMsg, "PROMPT"); }

public int SetEnumIntoCombo(string strKey, ref ComboBox ctrlComboBox) {

string str = ctrlComboBox.SelectedItem.ToString(); IEnumValue enumValue; int ret = _ifInstance.Parameters.GetEnumValue(strKey, out enumValue); if (ret != MvError.MV_OK) {

return ret; }

for (int i = 0; i < enumValue.SupportedNum; ++i) {

if (str.Equals(enumValue.SupportEnumEntries[i].Symbolic, StringComparison.OrdinalIgnoreCase)) {

ret = _ifInstance.Parameters.SetEnumValue(strKey, enumValue.SupportEnumEntries[i].Value); if (ret != MvError.MV_OK) {

return ret; }

break; }

}

return ret; }

public void InitParameter() {

if (null == _ifInstance) {

return; }

teIspGamma.Enabled = true;

ReadEnumIntoCombo("StreamSelector", ref cbStreamSelector);

IStringValue stringValue; _ifInstance.Parameters.GetStringValue("CurrentStreamDevice", out stringValue); teCurrentStreamDevice.Text = stringValue.CurValue;

IIntValue intValue; _ifInstance.Parameters.GetIntValue("StreamEnableStatus", out intValue); teStreamEnableStatus.Text = intValue.CurValue.ToString();

bool bValue = false; _ifInstance.Parameters.GetBoolValue("BayerCFAEnable", out bValue); cbBayerCFAEnable.Checked = bValue;

_ifInstance.Parameters.GetBoolValue("IspGammaEnable", out bValue); cbIspGammaEnable.Checked = bValue;

IFloatValue floatValue; _ifInstance.Parameters.GetFloatValue("IspGamma", out floatValue); teIspGamma.Text = floatValue.CurValue.ToString();

bIni = true; }

public CXPConfigForm() {

InitializeComponent(); }

public CXPConfigForm(IInterface ifInstance) : this()

{

_ifInstance = ifInstance;

InitParameter(); }

private void cbStreamSelector_SelectedIndexChanged(object sender, EventArgs e) {

if (false == bIni) {

return; }

int ret = SetEnumIntoCombo("StreamSelector", ref cbStreamSelector); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set StreamSelector Fail!", ret); }

}

private void cbBayerCFAEnable_CheckedChanged(object sender, EventArgs e) {

bool bCheck = cbBayerCFAEnable.Checked;

int ret = _ifInstance.Parameters.SetBoolValue("BayerCFAEnable", bCheck); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set BayerCFAEnable Fail!", ret); return; }

}

private void cbIspGammaEnable_CheckedChanged(object sender, EventArgs e) {

bool bCheck = cbIspGammaEnable.Checked;

int ret =_ifInstance.Parameters.SetBoolValue("IspGammaEnable", bCheck); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set IspGammaEnable Fail!", ret); return; }

}

private void bnSetParameter_Click(object sender, EventArgs e) {

try {

float.Parse(teIspGamma.Text); }

catch {

ShowErrorMsg("Please enter correct type!", 0); return; }

int ret = _ifInstance.Parameters.SetFloatValue("IspGamma", float.Parse(teIspGamma.Text)); if (MvError.MV_OK != ret) {

ShowErrorMsg("Set IspGamma Fail!", ret); }

}

private void bnGetParameter_Click(object sender, EventArgs e) {

InitParameter(); }

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

网口采集卡参数配置 （GEVConfigForm.cs）

该示例演示如何配置GigE Vision采集卡的常用参数。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using System.Runtime.InteropServices; using System.Threading; using System.IO;

using System.Drawing.Imaging; using System.Diagnostics; using System.Collections.ObjectModel;

using MvCameraControl;

namespace InterfaceBasicDemo {

public partial class GEVConfigForm : Form {

IInterface _ifInstance;

bool bIni = false;

private int ReadEnumIntoCombo(string strKey, ref ComboBox ctrlComboBox) {

IEnumValue enumValue; int ret = _ifInstance.Parameters.GetEnumValue(strKey, out enumValue); if (ret != MvError.MV_OK) {

return ret; }

ctrlComboBox.Items.Clear(); for (int i = 0; i < enumValue.SupportedNum; ++i) {

ctrlComboBox.Items.Add(enumValue.SupportEnumEntries[i].Symbolic); }

int nIndex = ctrlComboBox.FindString(enumValue.CurEnumEntry.Symbolic); if (nIndex >= 0) {

ctrlComboBox.SelectedIndex = nIndex; }

return MvError.MV_OK; }

// ch:显示错误信息 | en:Show error message private void ShowErrorMsg(string csMessage, int nErrorNum) {

string errorMsg; if (nErrorNum == 0) {

errorMsg = csMessage; }

else {

errorMsg = csMessage + ": Error =" + String.Format("{0:X}", nErrorNum); }

switch (nErrorNum) {

case MvError.MV_E_HANDLE: errorMsg += "Error or invalid handle "; break; case MvError.MV_E_SUPPORT: errorMsg += "Not supported function "; break; case MvError.MV_E_BUFOVER: errorMsg += "Cache is full "; break; case MvError.MV_E_CALLORDER: errorMsg += "Function calling order error "; break; case MvError.MV_E_PARAMETER: errorMsg += "Incorrect parameter "; break; case MvError.MV_E_RESOURCE: errorMsg += "Applying resource failed "; break; case MvError.MV_E_NODATA: errorMsg += "No data "; break; case MvError.MV_E_PRECONDITION: errorMsg += "Precondition error, or running environment changed "; break; case MvError.MV_E_VERSION: errorMsg += "Version mismatches "; break; case MvError.MV_E_NOENOUGH_BUF: errorMsg += "Insufficient memory "; break; case MvError.MV_E_ABNORMAL_IMAGE: errorMsg += "Abnormal image, maybe incomplete image because of lost packet "; break; case MvError.MV_E_UNKNOW: errorMsg += "Unknown error "; break; case MvError.MV_E_GC_GENERIC: errorMsg += "General error "; break; case MvError.MV_E_GC_ACCESS: errorMsg += "Node accessing condition error "; break; case MvError.MV_E_ACCESS_DENIED: errorMsg += "No permission "; break; case MvError.MV_E_BUSY: errorMsg += "Device is busy, or network disconnected "; break; case MvError.MV_E_NETER: errorMsg += "Network error "; break; }

MessageBox.Show(errorMsg, "PROMPT"); }

public int SetEnumIntoCombo(string strKey, ref ComboBox ctrlComboBox) {

string str = ctrlComboBox.SelectedItem.ToString(); IEnumValue enumValue; int ret = _ifInstance.Parameters.GetEnumValue(strKey, out enumValue); if (ret != MvError.MV_OK) {

return ret; }

for (int i = 0; i < enumValue.SupportedNum; ++i) {

if (str.Equals(enumValue.SupportEnumEntries[i].Symbolic, StringComparison.OrdinalIgnoreCase)) {

ret = _ifInstance.Parameters.SetEnumValue(strKey, enumValue.SupportEnumEntries[i].Value); if (ret != MvError.MV_OK) {

return ret; }

break; }

}

return ret; }

public void InitParameter() {

teTimerDuration.Enabled = true; teTimerDelay.Enabled = true; teTimerFrequency.Enabled = true; ReadEnumIntoCombo("StreamSelector", ref cbStreamSelector); ReadEnumIntoCombo("TimerSelector", ref cbTimerSelector); ReadEnumIntoCombo("TimerTriggerSource", ref cbTimerTriggerSource); ReadEnumIntoCombo("TimerTriggerActivation", ref cbTimerTriggerActivation);

bool bValue = false; _ifInstance.Parameters.GetBoolValue("HBDecompression", out bValue); cbHBDecompression.Checked = bValue;

IIntValue intValue; _ifInstance.Parameters.GetIntValue("TimerDuration", out intValue); teTimerDuration.Text = intValue.CurValue.ToString();

_ifInstance.Parameters.GetIntValue("TimerDelay", out intValue); teTimerDelay.Text = intValue.CurValue.ToString();

_ifInstance.Parameters.GetIntValue("TimerFrequency", out intValue); teTimerFrequency.Text = intValue.CurValue.ToString();

bIni = true; }

public GEVConfigForm(IInterface ifInstance) : this()

{

_ifInstance = ifInstance;

InitParameter(); }

public GEVConfigForm() {

InitializeComponent(); }

private void bnGetParameter_Click(object sender, EventArgs e) {

InitParameter(); }

private void bnSetParameter_Click(object sender, EventArgs e) {

try {

int.Parse(teTimerDuration.Text); int.Parse(teTimerDelay.Text); int.Parse(teTimerFrequency.Text); }

catch {

ShowErrorMsg("Please enter correct type!", 0); return; }

int ret = _ifInstance.Parameters.SetIntValue("TimerDuration", int.Parse(teTimerDuration.Text)); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set TimerDuration Fail!", ret); }

ret = _ifInstance.Parameters.SetIntValue("TimerDelay", int.Parse(teTimerDelay.Text)); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set TimerDelay Fail!", ret); }

ret = _ifInstance.Parameters.SetIntValue("TimerFrequency", int.Parse(teTimerFrequency.Text)); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set TimerFrequency Fail!", ret); }

}

private void bnTimerReset_Click(object sender, EventArgs e) {

int ret = _ifInstance.Parameters.SetCommandValue("TimerReset"); if (ret != MvError.MV_OK) {

ShowErrorMsg("TimerReset Fail!", ret); }

}

private void bnTimerTriggerSoftware_Click(object sender, EventArgs e) {

int ret = _ifInstance.Parameters.SetCommandValue("TimerTriggerSoftware"); if (ret != MvError.MV_OK) {

ShowErrorMsg("TimerTriggerSoftware Fail!", ret); }

}

private void cbStreamSelector_SelectedIndexChanged(object sender, EventArgs e) {

if (false == bIni) {

return; }

int ret = SetEnumIntoCombo("StreamSelector", ref cbStreamSelector); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set StreamSelector Fail!", ret); }

}

private void cbTimerSelector_SelectedIndexChanged(object sender, EventArgs e) {

if (false == bIni) {

return; }

int ret = SetEnumIntoCombo("TimerSelector", ref cbTimerSelector); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set TimerSelector Fail!", ret); }

}

private void cbTimerTriggerSource_SelectedIndexChanged(object sender, EventArgs e) {

if (false == bIni) {

return; }

int ret = SetEnumIntoCombo("TimerTriggerSource", ref cbTimerTriggerSource); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set TimerTriggerSource Fail!", ret); }

}

private void cbTimerTriggerActivation_SelectedIndexChanged(object sender, EventArgs e) {

if (false == bIni) {

return; }

int ret = SetEnumIntoCombo("TimerTriggerActivation", ref cbTimerTriggerActivation); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set TimerTriggerActivation Fail!", ret); }

}

private void cbHBDecompression_CheckedChanged(object sender, EventArgs e) {

bool bCheck = cbHBDecompression.Checked;

int ret = _ifInstance.Parameters.SetBoolValue("HBDecompression", bCheck); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set HBDecompression Fail!", ret); return; }

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

XoFlink采集卡参数配置（XOFConfigForm.cs）

该示例演示如何配置XoFlink采集卡的常用参数。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using System.Runtime.InteropServices; using System.Threading; using System.IO;

using System.Drawing.Imaging; using System.Diagnostics; using System.Collections.ObjectModel;

using MvCameraControl;

namespace InterfaceBasicDemo {

public partial class XOFConfigForm : Form {

IInterface _ifInstance;

bool bIni = false;

private int ReadEnumIntoCombo(string strKey, ref ComboBox ctrlComboBox) {

IEnumValue enumValue; int ret = _ifInstance.Parameters.GetEnumValue(strKey, out enumValue); if (ret != MvError.MV_OK) {

return ret; }

ctrlComboBox.Items.Clear(); for (int i = 0; i < enumValue.SupportedNum; ++i) {

ctrlComboBox.Items.Add(enumValue.SupportEnumEntries[i].Symbolic); }

int nIndex = ctrlComboBox.FindString(enumValue.CurEnumEntry.Symbolic); if (nIndex >= 0) {

ctrlComboBox.SelectedIndex = nIndex; }

return MvError.MV_OK; }

// ch:显示错误信息 | en:Show error message private void ShowErrorMsg(string csMessage, int nErrorNum) {

string errorMsg; if (nErrorNum == 0) {

errorMsg = csMessage; }

else {

errorMsg = csMessage + ": Error =" + String.Format("{0:X}", nErrorNum); }

switch (nErrorNum) {

case MvError.MV_E_HANDLE: errorMsg += "Error or invalid handle "; break; case MvError.MV_E_SUPPORT: errorMsg += "Not supported function "; break; case MvError.MV_E_BUFOVER: errorMsg += "Cache is full "; break; case MvError.MV_E_CALLORDER: errorMsg += "Function calling order error "; break; case MvError.MV_E_PARAMETER: errorMsg += "Incorrect parameter "; break; case MvError.MV_E_RESOURCE: errorMsg += "Applying resource failed "; break; case MvError.MV_E_NODATA: errorMsg += "No data "; break; case MvError.MV_E_PRECONDITION: errorMsg += "Precondition error, or running environment changed "; break; case MvError.MV_E_VERSION: errorMsg += "Version mismatches "; break; case MvError.MV_E_NOENOUGH_BUF: errorMsg += "Insufficient memory "; break; case MvError.MV_E_ABNORMAL_IMAGE: errorMsg += "Abnormal image, maybe incomplete image because of lost packet "; break; case MvError.MV_E_UNKNOW: errorMsg += "Unknown error "; break; case MvError.MV_E_GC_GENERIC: errorMsg += "General error "; break; case MvError.MV_E_GC_ACCESS: errorMsg += "Node accessing condition error "; break; case MvError.MV_E_ACCESS_DENIED: errorMsg += "No permission "; break; case MvError.MV_E_BUSY: errorMsg += "Device is busy, or network disconnected "; break; case MvError.MV_E_NETER: errorMsg += "Network error "; break; }

MessageBox.Show(errorMsg, "PROMPT"); }

public int SetEnumIntoCombo(string strKey, ref ComboBox ctrlComboBox) {

string str = ctrlComboBox.SelectedItem.ToString(); IEnumValue enumValue; int ret = _ifInstance.Parameters.GetEnumValue(strKey, out enumValue); if (ret != MvError.MV_OK) {

return ret; }

for (int i = 0; i < enumValue.SupportedNum; ++i) {

if (str.Equals(enumValue.SupportEnumEntries[i].Symbolic, StringComparison.OrdinalIgnoreCase)) {

ret = _ifInstance.Parameters.SetEnumValue(strKey, enumValue.SupportEnumEntries[i].Value); if (ret != MvError.MV_OK) {

return ret; }

break; }

}

return ret; }

public void InitParameter() {

teImageHeight.Enabled = true; ReadEnumIntoCombo("StreamSelector", ref cbStreamSelector);

IStringValue stringValue; _ifInstance.Parameters.GetStringValue("CurrentStreamDevice", out stringValue); teCurrentStreamDevice.Text = stringValue.CurValue;

bool bValue = false; _ifInstance.Parameters.GetBoolValue("MinFrameDelay", out bValue); cbMinFrameDelay.Checked = bValue;

ReadEnumIntoCombo("CameraType", ref cbCameraType);

IIntValue intValue; _ifInstance.Parameters.GetIntValue("ImageHeight", out intValue); teImageHeight.Text = intValue.CurValue.ToString(); _ifInstance.Parameters.GetIntValue("FrameTimeoutTime", out intValue); teFrameTimeoutTime.Text = intValue.CurValue.ToString();

ReadEnumIntoCombo("PartialImageOutputMode", ref cbPartialImageOutputMode);

bIni = true; }

public XOFConfigForm() {

InitializeComponent(); }

public XOFConfigForm(IInterface ifInstance) : this()

{

_ifInstance = ifInstance;

InitParameter(); }

private void bnGetParameter_Click(object sender, EventArgs e) {

InitParameter(); }

private void bnSetParameter_Click(object sender, EventArgs e) {

try {

int.Parse(teImageHeight.Text); }

catch {

ShowErrorMsg("Please enter correct type!", 0); return; }

int ret = _ifInstance.Parameters.SetIntValue("ImageHeight", int.Parse(teImageHeight.Text)); if (MvError.MV_OK != ret) {

ShowErrorMsg("Set ImageHeight Fail!", ret); }

}

private void cbStreamSelector_SelectedIndexChanged(object sender, EventArgs e) {

if (false == bIni) {

return; }

int ret = SetEnumIntoCombo("StreamSelector", ref cbStreamSelector); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set StreamSelector Fail!", ret); }

}

private void cbMinFrameDelay_CheckedChanged(object sender, EventArgs e) {

if (false == bIni) {

return; }

bool bCheck = cbMinFrameDelay.Checked;

int ret = _ifInstance.Parameters.SetBoolValue("MinFrameDelay", bCheck); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set MinFrameDelay Fail!", ret); return; }

}

private void cbCameraType_SelectedIndexChanged(object sender, EventArgs e) {

if (false == bIni) {

return; }

int ret = SetEnumIntoCombo("CameraType", ref cbCameraType); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set CameraType Fail!", ret); }

}

private void cbPartialImageOutputMode_SelectedIndexChanged(object sender, EventArgs e) {

if (false == bIni) {

return; }

int ret = SetEnumIntoCombo("PartialImageOutputMode", ref cbPartialImageOutputMode); if (ret != MvError.MV_OK) {

ShowErrorMsg("Set PartialImageOutputMode Fail!", ret); }

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

GenTL基础示例（BasicDemoByGenTL.cs）

该示例演示如何基于GenTL模块实现第三方设备（包括相机和采集卡）连接、配置和取图等常用功能。 using MvCameraControl; using System; using System.Collections.Generic; using System.Threading; using System.Windows.Forms;

namespace BasicDemoByGenTL

{

public partial class Form1 : Form {

List<IGenTLIFInfo> interfaceInfos = new List<IGenTLIFInfo>(); List<IGenTLDevInfo> deviceInfos = new List<IGenTLDevInfo>(); private IDevice device = null; bool isGrabbing = false; Thread receiveThread = null;

public Form1() {

InitializeComponent();

SDKSystem.Initialize();

Control.CheckForIllegalCrossThreadCalls = false; }

// ch:显示错误信息 | en:Show error message private void ShowErrorMsg(string message, int errorCode) {

string errorMsg; if (errorCode == 0) {

errorMsg = message; }

else {

errorMsg = message + ": Error =" + String.Format("{0:X}", errorCode); }

switch (errorCode) {

case MvError.MV_E_HANDLE: errorMsg += " Error or invalid handle "; break; case MvError.MV_E_SUPPORT: errorMsg += " Not supported function "; break; case MvError.MV_E_BUFOVER: errorMsg += " Cache is full "; break; case MvError.MV_E_CALLORDER: errorMsg += " Function calling order error "; break; case MvError.MV_E_PARAMETER: errorMsg += " Incorrect parameter "; break; case MvError.MV_E_RESOURCE: errorMsg += " Applying resource failed "; break; case MvError.MV_E_NODATA: errorMsg += " No data "; break; case MvError.MV_E_PRECONDITION: errorMsg += " Precondition error, or running environment changed "; break; case MvError.MV_E_VERSION: errorMsg += " Version mismatches "; break; case MvError.MV_E_NOENOUGH_BUF: errorMsg += " Insufficient memory "; break; case MvError.MV_E_UNKNOW: errorMsg += " Unknown error "; break; case MvError.MV_E_GC_GENERIC: errorMsg += " General error "; break; case MvError.MV_E_GC_ACCESS: errorMsg += " Node accessing condition error "; break; case MvError.MV_E_ACCESS_DENIED: errorMsg += " No permission "; break; case MvError.MV_E_BUSY: errorMsg += " Device is busy, or network disconnected "; break; case MvError.MV_E_NETER: errorMsg += " Network error "; break; }

MessageBox.Show(errorMsg, "PROMPT"); }

private void btnEnumInterface_Click(object sender, EventArgs e) {

cmbDeviceList.Items.Clear(); cmbInterfaceList.Items.Clear(); cmbDeviceList.Text = ""; cmbInterfaceList.Text = ""; OpenFileDialog fileDialog = new OpenFileDialog(); if (null == fileDialog) {

ShowErrorMsg("Open File Dialog Fail!", MvError.MV_E_RESOURCE); return; }

//ch:选择要导入的Cti文件 | en:Select a cti file fileDialog.Filter = "Cti文件(*.cti)|*.cti"; fileDialog.ShowDialog();

int result = GenTLManager.EnumInterfacesByGenTL(fileDialog.FileName, out interfaceInfos); if (0 != result) {

ShowErrorMsg("Enumerate interfaces fail!", result); return; }

if(interfaceInfos.Count <= 0) {

ShowErrorMsg("No interfaces!", 0); return; }

for (Int32 i = 0; i < interfaceInfos.Count; i++ ) {

cmbInterfaceList.Items.Add("TLType:" + interfaceInfos[i].TLType + " " + interfaceInfos[i].InterfaceID + " " + interfaceInfos[i].DisplayName); }

cmbInterfaceList.SelectedIndex = 0; btnEnumDevice.Enabled = true; }

private void btnEnumDevice_Click(object sender, EventArgs e) {

DeviceListAcq();

bnOpen.Enabled = true; }

private void DeviceListAcq() {

cmbDeviceList.Items.Clear();

IGenTLIFInfo ifInfo = interfaceInfos[cmbInterfaceList.SelectedIndex];

// ch:枚举设备列表 | en:Enumerate Device List int result = GenTLManager.EnumDevicesByGenTL(ifInfo, out deviceInfos); if (result != MvError.MV_OK) {

ShowErrorMsg("Enumerate devices fail!", 0); return; }

// ch:在窗体列表中显示设备名 | en:Display device name in the form list for (int i = 0; i < deviceInfos.Count; i++) {

IGenTLDevInfo deviceInfo = deviceInfos[i];

if (deviceInfo.UserDefinedName != "") {

cmbDeviceList.Items.Add("Dev: " + deviceInfo.UserDefinedName + " (" + deviceInfo.SerialNumber + ")"); }

else {

cmbDeviceList.Items.Add("Dev: " + deviceInfo.VendorName + " " + deviceInfo.ModelName + " (" + deviceInfo.SerialNumber + ")"); }

}

// ch:选择第一项 | en:Select the first item if (deviceInfos.Count != 0) {

cmbDeviceList.SelectedIndex = 0; }

}

private void SetCtrlWhenOpen() {

btnEnumInterface.Enabled = false; btnEnumDevice.Enabled = false; bnOpen.Enabled = false;

bnClose.Enabled = true; bnStartGrab.Enabled = true; bnStopGrab.Enabled = false; bnContinuesMode.Enabled = true; bnContinuesMode.Checked = true; bnTriggerMode.Enabled = true; cbSoftTrigger.Enabled = false; bnTriggerExec.Enabled = false; }

private void bnOpen_Click(object sender, EventArgs e) {

if (deviceInfos.Count == 0 || cmbDeviceList.SelectedIndex == -1) {

ShowErrorMsg("No device, please select", 0); return; }

// ch:获取选择的设备信息 | en:Get selected device information IGenTLDevInfo deviceInfo = deviceInfos[cmbDeviceList.SelectedIndex];

try {

// ch:创建设备 | en:Create device device = DeviceFactory.CreateDeviceByGenTL(deviceInfo); }

catch (Exception ex) {

MessageBox.Show("Create Device fail!" + ex.Message); return; }

int result = device.Open(); if (result != MvError.MV_OK) {

device.Dispose();

ShowErrorMsg("Device open fail!", result); return; }

// ch:设置采集连续模式 | en:Set Continues Aquisition Mode device.Parameters.SetEnumValueByString("AcquisitionMode", "Continuous"); device.Parameters.SetEnumValueByString("TriggerMode", "Off");

// ch:控件操作 | en:Control operation SetCtrlWhenOpen(); }

private void SetCtrlWhenClose() {

btnEnumInterface.Enabled = true; btnEnumDevice.Enabled = true;

bnOpen.Enabled = true;

bnClose.Enabled = false; bnStartGrab.Enabled = false; bnStopGrab.Enabled = false; bnContinuesMode.Enabled = false; bnTriggerMode.Enabled = false; cbSoftTrigger.Enabled = false; bnTriggerExec.Enabled = false; }

private void bnClose_Click(object sender, EventArgs e) {

// ch:取流标志位清零 | en:Reset flow flag bit if (isGrabbing == true) {

isGrabbing = false; receiveThread.Join(); }

// ch:关闭设备 | en:Close Device if (device != null) {

device.Close(); device.Dispose(); }

// ch:控件操作 | en:Control Operation SetCtrlWhenClose(); }

private void bnContinuesMode_CheckedChanged(object sender, EventArgs e) {

if (bnContinuesMode.Checked) {

device.Parameters.SetEnumValueByString("TriggerMode", "Off"); cbSoftTrigger.Enabled = false; bnTriggerExec.Enabled = false; }

}

private void bnTriggerMode_CheckedChanged(object sender, EventArgs e) {

// ch:打开触发模式 | en:Open Trigger Mode if (bnTriggerMode.Checked) {

device.Parameters.SetEnumValueByString("TriggerMode", "On");

// ch:触发源选择:0 - Line0; | en:Trigger source select:0 - Line0; // 1 - Line1; // 2 - Line2; // 3 - Line3; // 4 - Counter; // 7 - Software; if (cbSoftTrigger.Checked) {

device.Parameters.SetEnumValueByString("TriggerMode", "On"); device.Parameters.SetEnumValueByString("TriggerSource", "Software"); if (isGrabbing) {

bnTriggerExec.Enabled = true; }

}

else {

device.Parameters.SetEnumValueByString("TriggerSource", "Line0"); }

cbSoftTrigger.Enabled = true; }

}

private void SetCtrlWhenStartGrab() {

bnStartGrab.Enabled = false; bnStopGrab.Enabled = true;

if (bnTriggerMode.Checked && cbSoftTrigger.Checked) {

bnTriggerExec.Enabled = true; }

}

public void ReceiveThreadProcess() {

IFrameOut frameOut; int result = MvError.MV_OK;

while (isGrabbing) {

result = device.StreamGrabber.GetImageBuffer(1000, out frameOut); if (result == MvError.MV_OK) {

device.ImageRender.DisplayOneFrame(pictureBox1.Handle, frameOut.Image);

device.StreamGrabber.FreeImageBuffer(frameOut); }

else {

if (bnTriggerMode.Checked) {

Thread.Sleep(5);

}

}

}

}

private void bnStartGrab_Click(object sender, EventArgs e) {

// ch:标志位置位true | en:Set position bit true isGrabbing = true;

receiveThread = new Thread(ReceiveThreadProcess); receiveThread.Start();

// ch:开始采集 | en:Start Grabbing int result = device.StreamGrabber.StartGrabbing(); if (result != MvError.MV_OK) {

isGrabbing = false; receiveThread.Join(); ShowErrorMsg("Start Grabbing Fail!", result); return; }

// ch:控件操作 | en:Control Operation SetCtrlWhenStartGrab(); }

private void cbSoftTrigger_CheckedChanged(object sender, EventArgs e) {

if (cbSoftTrigger.Checked) {

// ch:触发源设为软触发 | en:Set trigger source as Software device.Parameters.SetEnumValueByString("TriggerSource", "Software"); if (isGrabbing) {

bnTriggerExec.Enabled = true; }

}

else {

device.Parameters.SetEnumValueByString("TriggerSource", "Line0"); bnTriggerExec.Enabled = false; }

}

private void bnTriggerExec_Click(object sender, EventArgs e) {

// ch:触发命令 | en:Trigger command int result = device.Parameters.SetCommandValue("TriggerSoftware"); if (result != MvError.MV_OK) {

ShowErrorMsg("Trigger Software Fail!", result); }

}

private void SetCtrlWhenStopGrab() {

bnStartGrab.Enabled = true; bnStopGrab.Enabled = false;

bnTriggerExec.Enabled = false; }

private void bnStopGrab_Click(object sender, EventArgs e) {

// ch:标志位设为false | en:Set flag bit false isGrabbing = false; receiveThread.Join();

// ch:停止采集 | en:Stop Grabbing int result = device.StreamGrabber.StopGrabbing(); if (result != MvError.MV_OK) {

ShowErrorMsg("Stop Grabbing Fail!", result); }

// ch:控件操作 | en:Control Operation SetCtrlWhenStopGrab(); }

private void Form1_FormClosing(object sender, FormClosingEventArgs e) {

bnClose_Click(sender, e);

SDKSystem.Finalize(); }

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

线阵相机程序基础示例（BasicDemoLineScan.cs）

该示例演示如何调用SDK接口实现线阵相机连接和配置。 using MvCameraControl; using System; using System.Collections.Generic; using System.Threading; using System.Windows.Forms;

namespace BasicDemoLineScan {

public partial class Form1 : Form {

readonly DeviceTLayerType enumTLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLGigEDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLXoFDevice;

IDevice device = null; List<IDeviceInfo> deviceInfos = new List<IDeviceInfo>();

bool isGrabbing = false; Thread receiveThread = null;

// ch:用于从驱动获取到的帧信息 | en:Frame info that getting image from driver IFrameOut frameForSave = null; private readonly Object lockForSaveImage = new Object();

IEnumValue triggerSelector = null; // 触发选项

IEnumValue triggerMode = null; // 触发模式

IEnumValue triggerSource = null; // 触发源

IEnumValue pixelFormat = null; // 像素格式

IEnumValue imgCompressMode = null; // HB模式

IEnumValue preampGain = null; // 模拟增益

public Form1() {

InitializeComponent();

SDKSystem.Initialize();

UpdateDeviceList();

CheckForIllegalCrossThreadCalls = false; }

private void ShowErrorMsg(string message, int errorCode) {

string errorMsg; if (errorCode == 0) {

errorMsg = message;

}

else {

errorMsg = message + ": Error =" + String.Format("{0:X}", errorCode); }

switch (errorCode) {

case MvError.MV_E_HANDLE: errorMsg += " Error or invalid handle "; break; case MvError.MV_E_SUPPORT: errorMsg += " Not supported function "; break; case MvError.MV_E_BUFOVER: errorMsg += " Cache is full "; break; case MvError.MV_E_CALLORDER: errorMsg += " Function calling order error "; break; case MvError.MV_E_PARAMETER: errorMsg += " Incorrect parameter "; break; case MvError.MV_E_RESOURCE: errorMsg += " Applying resource failed "; break; case MvError.MV_E_NODATA: errorMsg += " No data "; break; case MvError.MV_E_PRECONDITION: errorMsg += " Precondition error, or running environment changed "; break; case MvError.MV_E_VERSION: errorMsg += " Version mismatches "; break; case MvError.MV_E_NOENOUGH_BUF: errorMsg += " Insufficient memory "; break; case MvError.MV_E_UNKNOW: errorMsg += " Unknown error "; break; case MvError.MV_E_GC_GENERIC: errorMsg += " General error "; break; case MvError.MV_E_GC_ACCESS: errorMsg += " Node accessing condition error "; break; case MvError.MV_E_ACCESS_DENIED: errorMsg += " No permission "; break; case MvError.MV_E_BUSY: errorMsg += " Device is busy, or network disconnected "; break; case MvError.MV_E_NETER: errorMsg += " Network error "; break; }

MessageBox.Show(errorMsg, "PROMPT"); }

private void bnEnum_Click(object sender, EventArgs e) {

UpdateDeviceList();

}

private void UpdateDeviceList() {

// ch:枚举设备列表 | en:Enumerate Device List cmbDeviceList.Items.Clear();

int result = DeviceEnumerator.EnumDevices(enumTLayerType, out deviceInfos); if (result != MvError.MV_OK) {

ShowErrorMsg("Enumerate devices fail!", result); return; }

// ch:在窗体列表中显示设备名 | en:Display device name in the form list for (int i = 0; i < deviceInfos.Count; i++) {

IDeviceInfo deviceInfo = deviceInfos[i]; if (deviceInfo.UserDefinedName != "") {

cmbDeviceList.Items.Add(deviceInfo.TLayerType.ToString() + ": " + deviceInfo.UserDefinedName + " (" + deviceInfo.SerialNumber + ")"); }

else {

cmbDeviceList.Items.Add(deviceInfo.TLayerType.ToString() + ": " + deviceInfo.ManufacturerName + " " + deviceInfo.ModelName + " (" + deviceInfo.SerialNumber + ")"); }

}

// ch:选择第一项 | en:Select the first item if (deviceInfos.Count > 0) {

cmbDeviceList.SelectedIndex = 0; }

else {

ShowErrorMsg("No device", 0); }

return; }

private void bnOpen_Click(object sender, System.EventArgs e) {

if (0 == deviceInfos.Count || -1 == cmbDeviceList.SelectedIndex) {

ShowErrorMsg("No device, please enumerate device", 0); return; }

// ch:获取选择的设备信息 | en:Get selected device information IDeviceInfo deviceInfo = deviceInfos[cmbDeviceList.SelectedIndex];

try {

// ch:打开设备 | en:Open device device = DeviceFactory.CreateDevice(deviceInfo); }

catch (Exception ex) {

MessageBox.Show("Create Device fail!" + ex.Message); return; }

int result = device.Open(); if (result != MvError.MV_OK) {

device.Dispose();

device = null;

ShowErrorMsg("Open Device fail!", result); return; }

//ch: 判断是否为gige设备 | en: Determine whether it is a GigE device if (device is IGigEDevice) {

//ch: 转换为gigE设备 | en: Convert to Gige device IGigEDevice gigEDevice = device as IGigEDevice;

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) int optionPacketSize; result = gigEDevice.GetOptimalPacketSize(out optionPacketSize); if (result != MvError.MV_OK) {

ShowErrorMsg("Warning: Get Packet Size failed!", result); }

else {

result = device.Parameters.SetIntValue("GevSCPSPacketSize", (long)optionPacketSize); if (result != MvError.MV_OK) {

ShowErrorMsg("Warning: Set Packet Size failed!", result); }

}

}

// ch:设置采集连续模式 | en:Set Continues Aquisition Mode device.Parameters.SetEnumValueByString("AcquisitionMode", "Continuous"); device.Parameters.SetEnumValueByString("TriggerMode", "Off");

// ch:获取参数 | en:Get parameters GetImageCompressionMode(); GetPreampGain();

GetTriggerMode();

GetTriggerSelector(); GetTriggerSource();

GetPixelFormat();

bnGetParam_Click(null, null);

// ch:控件操作 | en:Control operation btnOpen.Enabled = false; btnClose.Enabled = true; btnStartGrab.Enabled = true; btnStopGrab.Enabled = false; btnTriggerExec.Enabled = false; btnGetParam.Enabled = true; btnSetParam.Enabled = true; cmbDeviceList.Enabled = false; }

private void GetPreampGain() {

cmbPreampGain.Items.Clear();

int result = device.Parameters.GetEnumValue("PreampGain", out preampGain); if (result == MvError.MV_OK) {

for (int i = 0; i < preampGain.SupportedNum; i++) {

cmbPreampGain.Items.Add(preampGain.SupportEnumEntries[i].Symbolic); if (preampGain.SupportEnumEntries[i].Symbolic == preampGain.CurEnumEntry.Symbolic) {

cmbPreampGain.SelectedIndex = i; }

}

cmbPreampGain.Enabled = true; }

}

private void GetImageCompressionMode() {

cmbHBMode.Items.Clear();

int result = device.Parameters.GetEnumValue("ImageCompressionMode", out imgCompressMode); if (result == MvError.MV_OK) {

for (int i = 0; i < imgCompressMode.SupportedNum; i++) {

cmbHBMode.Items.Add(imgCompressMode.SupportEnumEntries[i].Symbolic); if (imgCompressMode.SupportEnumEntries[i].Symbolic == imgCompressMode.CurEnumEntry.Symbolic) {

cmbHBMode.SelectedIndex = i; }

}

cmbHBMode.Enabled = true; }

else {

cmbHBMode.Enabled = false; }

}

private void GetPixelFormat() {

cmbPixelFormat.Items.Clear();

int result = device.Parameters.GetEnumValue("PixelFormat", out pixelFormat); if (result == MvError.MV_OK) {

for (int i = 0; i < pixelFormat.SupportedNum; i++) {

cmbPixelFormat.Items.Add(pixelFormat.SupportEnumEntries[i].Symbolic); if (pixelFormat.SupportEnumEntries[i].Symbolic == pixelFormat.CurEnumEntry.Symbolic) {

cmbPixelFormat.SelectedIndex = i; }

}

cmbPixelFormat.Enabled = true; }

}

private void GetTriggerSelector() {

cmbTriggerSelector.Items.Clear(); int result = device.Parameters.GetEnumValue("TriggerSelector", out triggerSelector); if (result == MvError.MV_OK) {

for (int i = 0; i < triggerSelector.SupportedNum; i++) {

cmbTriggerSelector.Items.Add(triggerSelector.SupportEnumEntries[i].Symbolic); if (triggerSelector.SupportEnumEntries[i].Symbolic == triggerSelector.CurEnumEntry.Symbolic) {

cmbTriggerSelector.SelectedIndex = i; }

}

cmbTriggerSelector.Enabled = true; }

}

private void GetTriggerMode() {

cmbTriggerMode.Items.Clear(); int result = device.Parameters.GetEnumValue("TriggerMode", out triggerMode); if (result == MvError.MV_OK) {

for (int i = 0; i < triggerMode.SupportedNum; i++) {

cmbTriggerMode.Items.Add(triggerMode.SupportEnumEntries[i].Symbolic); if (triggerMode.SupportEnumEntries[i].Symbolic == triggerMode.CurEnumEntry.Symbolic) {

cmbTriggerMode.SelectedIndex = i; }

}

cmbTriggerMode.Enabled = true; }

}

private void GetTriggerSource() {

cmbTriggerSource.Items.Clear(); int result = device.Parameters.GetEnumValue("TriggerSource", out triggerSource); if (result == MvError.MV_OK) {

for (int i = 0; i < triggerSource.SupportedNum; i++) {

cmbTriggerSource.Items.Add(triggerSource.SupportEnumEntries[i].Symbolic); if (triggerSource.SupportEnumEntries[i].Value == triggerSource.CurEnumEntry.Value) {

cmbTriggerSource.SelectedIndex = i; }

}

cmbTriggerSource.Enabled = true; }

}

private void bnClose_Click(object sender, System.EventArgs e) {

// ch:取流标志位清零 | en:Reset flow flag bit if (isGrabbing == true) {

isGrabbing = false; receiveThread.Join(); }

// ch:关闭设备 | en:Close Device if (device != null) {

device.Close(); device.Dispose();

}

// ch:控件操作 | en:Control Operation SetCtrlWhenClose();

}

private void SetCtrlWhenClose() {

btnOpen.Enabled = true; btnClose.Enabled = false; btnStartGrab.Enabled = false; btnStopGrab.Enabled = false; btnTriggerExec.Enabled = false; cmbDeviceList.Enabled = true;

btnSaveBmp.Enabled = false; btnSaveJpg.Enabled = false; btnSaveTiff.Enabled = false; btnSavePng.Enabled = false; tbExposure.Enabled = false; btnGetParam.Enabled = false; btnSetParam.Enabled = false; cmbPixelFormat.Enabled = false; cmbHBMode.Enabled = false; cmbPreampGain.Enabled = false; cmbTriggerSource.Enabled = false; cmbTriggerSelector.Enabled = false; cmbTriggerMode.Enabled = false; tbExposure.Enabled = false; tbDigitalShift.Enabled = false; tbAcqLineRate.Enabled = false; chkLineRateEnable.Enabled = false; }

public void ReceiveThreadProcess() {

IFrameOut frameOut = null; int result = MvError.MV_OK;

while (isGrabbing) {

result = device.StreamGrabber.GetImageBuffer(1000, out frameOut); if (result == MvError.MV_OK) {

// ch:保存图像数据用于保存图像文件 | en:Save frame info for save image lock (lockForSaveImage) {

frameForSave = frameOut.Clone() as IFrameOut; }

// ch:渲染图像数据 | en:Display frame device.ImageRender.DisplayOneFrame(pictureBox1.Handle, frameOut.Image);

// ch:释放帧信息 | en:Free frame info device.StreamGrabber.FreeImageBuffer(frameOut); }

else {

if (cmbTriggerMode.SelectedText == "On") {

Thread.Sleep(5);

}

}

}

}

private void bnStartGrab_Click(object sender, System.EventArgs e) {

// ch:标志位置位 true | en:Set position bit true isGrabbing = true;

receiveThread = new Thread(ReceiveThreadProcess); receiveThread.Start();

// ch:开始采集 | en:Start Grabbing int result = device.StreamGrabber.StartGrabbing(); if (result != MvError.MV_OK) {

isGrabbing = false; receiveThread.Join(); ShowErrorMsg("Start Grabbing Fail!", result); return; }

// ch:控件操作 | en:Control Operation SetCtrlWhenStartGrab(); }

private void SetCtrlWhenStartGrab() {

btnStartGrab.Enabled = false; btnStopGrab.Enabled = true;

if ((cmbTriggerMode.Text == "On") && (cmbTriggerSource.Text == "Software") && isGrabbing) {

btnTriggerExec.Enabled = true; }

btnSaveBmp.Enabled = true; btnSaveJpg.Enabled = true; btnSaveTiff.Enabled = true; btnSavePng.Enabled = true; cmbPixelFormat.Enabled = false; cmbHBMode.Enabled = false; }

private void bnTriggerExec_Click(object sender, System.EventArgs e) {

// ch:触发命令 | en:Trigger command int result = device.Parameters.SetCommandValue("TriggerSoftware"); if (result != MvError.MV_OK) {

ShowErrorMsg("Trigger Software Fail!", result); }

}

private void bnStopGrab_Click(object sender, System.EventArgs e) {

// ch:标志位设为false | en:Set flag bit false isGrabbing = false; receiveThread.Join();

// ch:停止采集 | en:Stop Grabbing int result = device.StreamGrabber.StopGrabbing(); if (result != MvError.MV_OK) {

ShowErrorMsg("Stop Grabbing Fail!", result); }

// ch:控件操作 | en:Control Operation SetCtrlWhenStopGrab(); }

private void SetCtrlWhenStopGrab() {

btnStartGrab.Enabled = true; btnStopGrab.Enabled = false; btnTriggerExec.Enabled = false; btnSaveBmp.Enabled = false; btnSaveJpg.Enabled = false; btnSaveTiff.Enabled = false; btnSavePng.Enabled = false; cmbPixelFormat.Enabled = true; cmbHBMode.Enabled = true; }

private int SaveImage(ImageFormatInfo imageFormatInfo) {

if (frameForSave == null) {

throw new Exception("No vaild image"); }

string imagePath = "Image_w" + frameForSave.Image.Width.ToString() + "_h" + frameForSave.Image.Height.ToString() + "_fn" + frameForSave.FrameNum.ToString() + "." + imageFormatInfo.FormatType.ToString();

lock (lockForSaveImage) {

return device.ImageSaver.SaveImageToFile(imagePath, frameForSave.Image, imageFormatInfo, CFAMethod.Optimal); }

}

private void bnSaveBmp_Click(object sender, System.EventArgs e) {

int result;

try {

ImageFormatInfo imageFormatInfo = new ImageFormatInfo(); imageFormatInfo.FormatType = ImageFormatType.Bmp;

result = SaveImage(imageFormatInfo); if (result != MvError.MV_OK) {

ShowErrorMsg("Save Image Fail!", result); return; }

else {

ShowErrorMsg("Save Image Succeed!", 0); }

}

catch (Exception ex) {

MessageBox.Show("Save Image Failed, " + ex.Message); return; }

}

private void bnSaveJpg_Click(object sender, System.EventArgs e) {

int result;

try {

ImageFormatInfo imageFormatInfo = new ImageFormatInfo(); imageFormatInfo.FormatType = ImageFormatType.Jpeg; imageFormatInfo.JpegQuality = 80;

result = SaveImage(imageFormatInfo); if (result != MvError.MV_OK) {

ShowErrorMsg("Save Image Fail!", result); return; }

else {

ShowErrorMsg("Save Image Succeed!", 0); }

}

catch (Exception ex) {

MessageBox.Show("Save Image Failed, " + ex.Message); return; }

}

private void bnSaveTiff_Click(object sender, System.EventArgs e) {

int result; try {

ImageFormatInfo imageFormatInfo = new ImageFormatInfo(); imageFormatInfo.FormatType = ImageFormatType.Tiff;

result = SaveImage(imageFormatInfo); if (result != MvError.MV_OK) {

ShowErrorMsg("Save Image Fail!", result); return; }

else {

ShowErrorMsg("Save Image Succeed!", 0); }

}

catch (Exception ex) {

MessageBox.Show("Save Image Failed, " + ex.Message); return; }

}

private void bnSavePng_Click(object sender, System.EventArgs e) {

int result;

try {

ImageFormatInfo imageFormatInfo = new ImageFormatInfo(); imageFormatInfo.FormatType = ImageFormatType.Png;

result = SaveImage(imageFormatInfo); if (result != MvError.MV_OK) {

ShowErrorMsg("Save Image Fail!", result); return; }

else {

ShowErrorMsg("Save Image Succeed!", 0); }

}

catch (Exception ex) {

MessageBox.Show("Save Image Failed, " + ex.Message); return; }

}

private void bnSetParam_Click(object sender, System.EventArgs e) {

int result = MvError.MV_OK;

// ch:设置曝光 | en:Set ExposureTime if (tbExposure.Enabled) {

try {

float.Parse(tbExposure.Text); device.Parameters.SetEnumValue("ExposureAuto", 0); result = device.Parameters.SetFloatValue("ExposureTime", float.Parse(tbExposure.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set Exposure Time Fail!", result); }

}

catch {

ShowErrorMsg("Please enter ExposureTime correct", 0); }

}

// ch:设置数字增益 | en:Set DigitalShift if (tbDigitalShift.Enabled) {

try {

float.Parse(tbDigitalShift.Text); device.Parameters.SetBoolValue("DigitalShiftEnable", true); result = device.Parameters.SetFloatValue("DigitalShift", float.Parse(tbDigitalShift.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set Digital Shift Fail!", result); }

}

catch {

ShowErrorMsg("Please enter DigitalShift correct", 0); }

}

// ch:设置行频设定值 | en:Set AcquisitionLineRate if (tbAcqLineRate.Enabled) {

try {

int.Parse(tbAcqLineRate.Text); result = device.Parameters.SetIntValue("AcquisitionLineRate", int.Parse(tbAcqLineRate.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set Acquisition Line Rate Fail!", result); }

}

catch {

ShowErrorMsg("Please enter AcquisitionLineRate correct", 0); }

}

}

private void bnGetParam_Click(object sender, System.EventArgs e) {

// ch:获取曝光参数 | en:Get ExposureTime IFloatValue exposureTime = null; int result = device.Parameters.GetFloatValue("ExposureTime", out exposureTime); if (result == MvError.MV_OK) {

tbExposure.Text = exposureTime.CurValue.ToString("F2"); tbExposure.Enabled = true; }

// ch:获取数字增益参数 | en:Get DigitalShift IFloatValue digitalShift = null; result = device.Parameters.GetFloatValue("DigitalShift", out digitalShift); if (result == MvError.MV_OK) {

tbDigitalShift.Text = digitalShift.CurValue.ToString("F2"); tbDigitalShift.Enabled = true; }

// ch:获取行频使能开关 | en:Get AcquisitionLineRateEnable bool acqLineRateEnable = false; result = device.Parameters.GetBoolValue("AcquisitionLineRateEnable", out acqLineRateEnable); if (result == MvError.MV_OK) {

chkLineRateEnable.Enabled = true; chkLineRateEnable.Checked = acqLineRateEnable; }

// ch:获取行频设置值 | en:Get AcquisitionLineRate IIntValue acqLineRate = null; result = device.Parameters.GetIntValue("AcquisitionLineRate", out acqLineRate); if (result == MvError.MV_OK) {

tbAcqLineRate.Text = acqLineRate.CurValue.ToString(); tbAcqLineRate.Enabled = true; }

// ch:获取行频实际值 | en:Get ResultingLineRate IIntValue resultLineRate = null; result = device.Parameters.GetIntValue("ResultingLineRate", out resultLineRate); if (result == MvError.MV_OK) {

tbResLineRate.Text = resultLineRate.CurValue.ToString(); tbResLineRate.Enabled = true; }

}

private void cbTriggerSelector_SelectedIndexChanged(object sender, EventArgs e) {

int result = device.Parameters.SetEnumValue("TriggerSelector", triggerSelector.SupportEnumEntries[cmbTriggerSelector.SelectedIndex].Value); if (result != MvError.MV_OK) {

ShowErrorMsg("Set Trigger Selector Failed", result); for (int i = 0; i < triggerSelector.SupportedNum; i++) {

if (triggerSelector.SupportEnumEntries[i].Value == triggerSelector.CurEnumEntry.Value) {

cmbTriggerSelector.SelectedIndex = i; return; }

}

}

GetTriggerMode();

GetTriggerSource();

}

private void cbTiggerMode_SelectedIndexChanged(object sender, EventArgs e) {

int result = device.Parameters.SetEnumValue("TriggerMode", (uint)triggerMode.SupportEnumEntries[cmbTriggerMode.SelectedIndex].Value); if (result != MvError.MV_OK) {

ShowErrorMsg("Set Trigger Mode Failed", result); for (int i = 0; i < triggerMode.SupportedNum; i++) {

if (triggerMode.SupportEnumEntries[i].Value == triggerMode.CurEnumEntry.Value) {

cmbTriggerMode.SelectedIndex = i; return; }

}

}

GetTriggerSource();

if ((cmbTriggerMode.Text == "On" && cmbTriggerSource.Text == "Software") && isGrabbing) {

btnTriggerExec.Enabled = true; }

else {

btnTriggerExec.Enabled = false; }

}

private void cbTriggerSource_SelectedIndexChanged(object sender, EventArgs e) {

int result = device.Parameters.SetEnumValue("TriggerSource", triggerSource.SupportEnumEntries[cmbTriggerSource.SelectedIndex].Value); if (result != MvError.MV_OK) {

ShowErrorMsg("Set Trigger Source Failed", result); for (int i = 0; i < triggerSource.SupportedNum; i++) {

if (triggerSource.SupportEnumEntries[i].Value == triggerSource.CurEnumEntry.Value) {

cmbTriggerSource.SelectedIndex = i; return; }

}

}

if ((cmbTriggerMode.Text == "On" && cmbTriggerSource.Text == "Software") && isGrabbing) {

btnTriggerExec.Enabled = true; }

else {

btnTriggerExec.Enabled = false; }

}

private void cbPixelFormat_SelectedIndexChanged(object sender, EventArgs e) {

// ch:设置像素格式 | en:Set PixelFormat int result = device.Parameters.SetEnumValue("PixelFormat", pixelFormat.SupportEnumEntries[cmbPixelFormat.SelectedIndex].Value); if (result != MvError.MV_OK) {

ShowErrorMsg("Set PixelFormat Fail!", result); for (int i = 0; i < pixelFormat.SupportedNum; i++) {

if (pixelFormat.SupportEnumEntries[i].Value == pixelFormat.CurEnumEntry.Value) {

cmbPixelFormat.SelectedIndex = i; return; }

}

}

GetImageCompressionMode(); }

private void cbHBMode_SelectedIndexChanged(object sender, EventArgs e) {

// ch:设置无损压缩模式 | en:Set ImageCompressionMode int result = device.Parameters.SetEnumValue("ImageCompressionMode", imgCompressMode.SupportEnumEntries[cmbHBMode.SelectedIndex].Value); if (result != MvError.MV_OK) {

ShowErrorMsg("Set ImageCompressionMode Fail!", result); for (int i = 0; i < imgCompressMode.SupportedNum; i++) {

if (imgCompressMode.SupportEnumEntries[i].Value == imgCompressMode.CurEnumEntry.Value) {

cmbHBMode.SelectedIndex = i; return; }

}

}

}

private void cbPreampGain_SelectedIndexChanged(object sender, EventArgs e) {

int result = device.Parameters.SetEnumValue("PreampGain", preampGain.SupportEnumEntries[cmbPreampGain.SelectedIndex].Value); if (result != MvError.MV_OK) {

ShowErrorMsg("Set PreampGain Fail!", result); for (int i = 0; i < preampGain.SupportedNum; i++) {

if (preampGain.SupportEnumEntries[i].Value == preampGain.CurEnumEntry.Value) {

cmbPreampGain.SelectedIndex = i; return; }

}

}

}

private void chkLineRateEnable_CheckedChanged(object sender, EventArgs e) {

if (chkLineRateEnable.Checked) {

device.Parameters.SetBoolValue("AcquisitionLineRateEnable", true); }

else {

device.Parameters.SetBoolValue("AcquisitionLineRateEnable", false); }

}

private void Form1_FormClosing(object sender, FormClosingEventArgs e) {

bnClose_Click(sender, e);

SDKSystem.Finalize(); }

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

采集卡枚举相机（InterfaceAndDevices.cs）

该示例演示如何实现先枚举采集卡，打开采集，然后通过采集卡实例枚举相机、从相机取流。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using MvCameraControl;

namespace InterfaceAndDevice {

class InterfaceAndDevice {

private const InterfaceTLayerType IFLayerType = InterfaceTLayerType.MvGigEInterface | InterfaceTLayerType.MvCameraLinkInterface | InterfaceTLayerType.MvCXPInterface | InterfaceTLayerType.MvXoFInterface;

static void FrameGrabedEventHandler(object sender, FrameGrabbedEventArgs e) {

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , FrameNum[{2}]", e.FrameOut.Image.Width, e.FrameOut.Image.Height, e.FrameOut.FrameNum); }

public void Run() {

IInterface ifInstance = null; IDevice devInstance = null; try {

// ch: 枚举采集卡 | en: Enumerate interfaces(frame grabber) List<IInterfaceInfo> IFInfoList; Int32 ret = InterfaceEnumerator.EnumInterfaces(IFLayerType, out IFInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("Enum interface failed:{0:x8}", ret); return; }

if (0 == IFInfoList.Count) {

Console.WriteLine("No interface found"); return; }

// ch:显示采集卡信息 | en:Show interface info PrintInterfaceInfo(IFInfoList);

// ch:选择采集卡 | en:Select interface Console.Write("Please input index(0-{0:d}):", IFInfoList.Count - 1);

Int32 ifIndex = Convert.ToInt32(Console.ReadLine()); if (ifIndex < 0 || ifIndex >= IFInfoList.Count) {

Console.WriteLine("Error Index!"); return; }

ifInstance = InterfaceFactory.CreateInterface(IFInfoList[ifIndex]);

// ch:打开采集卡 | en:Open interface ret = ifInstance.Open(); if (ret != MvError.MV_OK) {

Console.WriteLine("Open Interface failed:{0:x8}", ret); return; }

Console.WriteLine("Open Interface success");

// ch: 枚举采集卡上的相机 | en：Enumerate devices of interface List<IDeviceInfo> devInfoList; ret = ifInstance.EnumDevices(out devInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("EnumDevices failed:{0:x8}", ret); return; }

PrintDeviceInfo(devInfoList);

Console.Write("Please input device index(0-{0:d}):", devInfoList.Count - 1);

Int32 devIndex = Convert.ToInt32(Console.ReadLine()); if (devIndex > devInfoList.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

// ch:创建设备 | en:Create device devInstance = DeviceFactory.CreateDevice(devInfoList[devIndex]);

// ch:打开设备 | en:Open device ret = devInstance.Open(); if (ret != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", ret); return; }

Console.WriteLine("Open device success");

// ch:设置触发模式为off || en:set trigger mode as off ret = devInstance.Parameters.SetEnumValue("TriggerMode", 0); if (ret != MvError.MV_OK) {

Console.WriteLine("Set TriggerMode failed:{0:x8}", ret); return; }

//ch: 设置合适的缓存节点数量 | en: Setting the appropriate number of image nodes devInstance.StreamGrabber.SetImageNodeNum(5);

// ch:注册回调函数 | en:Register image callback devInstance.StreamGrabber.FrameGrabedEvent += FrameGrabedEventHandler; // ch:开启抓图 | en: start grab image ret = devInstance.StreamGrabber.StartGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); return; }

Console.WriteLine("Start grabbing success");

Console.WriteLine("Press enter to stop grabbing"); Console.ReadLine();

// ch:停止抓图 | en:Stop grabbing devInstance.StreamGrabber.StopGrabbing(); Console.WriteLine("Stop grabbing success");

//ch: 关闭相机 | en: Close device devInstance.Close(); Console.WriteLine("Close device success");

//ch：关闭采集卡 | en: Close interface ifInstance.Close(); Console.WriteLine("Close inerface success"); }

catch (Exception e) {

Console.WriteLine("Exception: " + e.Message); }

finally {

//ch：释放相机资源 | en：Release the resources of device if (devInstance != null) {

devInstance.Dispose(); }

//ch： 释放采集卡资源 | en: Release the resources of interface if (ifInstance != null) {

ifInstance.Dispose(); }

}

}

//ch: 打印采集卡信息 | en: print interface informations private void PrintInterfaceInfo(List<IInterfaceInfo> ifInfoList) {

int IFIndex = 0; foreach (var ifInfo in ifInfoList) {

Console.WriteLine("[Interface {0}]: ", IFIndex); Console.WriteLine("TLayerType: " + ifInfo.TLayerType.ToString()); Console.WriteLine("DisplayName: " + ifInfo.DisplayName); Console.WriteLine("InterfaceID: " + ifInfo.InterfaceID); Console.WriteLine("SerialNumber: " + ifInfo.SerialNumber); Console.WriteLine();

IFIndex++;

}

}

//ch: 打印设备信息 | en: print device informations private void PrintDeviceInfo(List<IDeviceInfo> devInfoList) {

int devIndex = 0; foreach (var devInfo in devInfoList) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine();

devIndex++;

}

}

static void Main(string[] args) {

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize();

InterfaceAndDevice program = new InterfaceAndDevice(); program.Run();

Console.WriteLine("Press enter to exit"); Console.ReadKey();

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize(); }

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

红外相机基础功能（InfraredDemo.cs）

该示例演示如何实现红外相机的基本功能。 using MvCameraControl; using System; using System.Collections.Generic; using System.Collections.ObjectModel; using System.ComponentModel; using System.Data; using System.Diagnostics; using System.Drawing; using System.Drawing.Imaging; using System.IO; using System.Linq; using System.Runtime.InteropServices; using System.Text; using System.Threading; using System.Windows.Forms;

namespace InfraredDemo {

public partial class InfraredDemo : Form {

List<IDeviceInfo> deviceInfoList = new List<IDeviceInfo>(); IDevice device = null;

bool isOpen = false; // ch:是否打开设备 | en:Whether to open device bool isGrabbing = false; // ch:是否开始抓图 | en:Whether to start grabbing IntPtr displayHandle = IntPtr.Zero; // ch:用于显示图像的控件句柄 | en:Handle of the image display control Thread m_hReceiveThread = null;

public InfraredDemo() {

InitializeComponent(); EnableControls(false); this.Load += new EventHandler(this.InfraredDemo_Load); displayHandle = pbDisplay.Handle; }

private void InfraredDemo_Load(object sender, EventArgs e) {

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize(); }

public static FormRegionSetting RegionSettingForm = null; // 区域设置界面

public static FormAlarmSetting AlarmSettingForm = null; // 告警设置界面

// ch:显示错误信息 | en:Show error message private void ShowErrorMsg(string csMessage, int nErrorNum) {

string errorMsg; if (nErrorNum == 0) {

errorMsg = csMessage; }

else {

errorMsg = csMessage + ": Error =" + String.Format("{0:X}", nErrorNum); }

switch (nErrorNum) {

case MvError.MV_E_HANDLE: errorMsg += "Error or invalid handle "; break; case MvError.MV_E_SUPPORT: errorMsg += "Not supported function "; break; case MvError.MV_E_BUFOVER: errorMsg += "Cache is full "; break; case MvError.MV_E_CALLORDER: errorMsg += "Function calling order error "; break; case MvError.MV_E_PARAMETER: errorMsg += "Incorrect parameter "; break; case MvError.MV_E_RESOURCE: errorMsg += "Applying resource failed "; break; case MvError.MV_E_NODATA: errorMsg += "No data "; break; case MvError.MV_E_PRECONDITION: errorMsg += "Precondition error, or running environment changed "; break; case MvError.MV_E_VERSION: errorMsg += "Version mismatches "; break; case MvError.MV_E_NOENOUGH_BUF: errorMsg += "Insufficient memory "; break; case MvError.MV_E_ABNORMAL_IMAGE: errorMsg += "Abnormal image, maybe incomplete image because of lost packet "; break; case MvError.MV_E_UNKNOW: errorMsg += "Unknown error "; break; case MvError.MV_E_GC_GENERIC: errorMsg += "General error "; break; case MvError.MV_E_GC_ACCESS: errorMsg += "Node accessing condition error "; break; case MvError.MV_E_ACCESS_DENIED: errorMsg += "No permission "; break; case MvError.MV_E_BUSY: errorMsg += "Device is busy, or network disconnected "; break; case MvError.MV_E_NETER: errorMsg += "Network error "; break; }

MessageBox.Show(errorMsg, "PROMPT"); }

private void bnEnum_Click(object sender, EventArgs e) {

DeviceListAcq();

EnableControls(true); }

private void DeviceListAcq() {

// ch:创建设备列表 | en:Create Device List cbDeviceList.Items.Clear(); int result = DeviceEnumerator.EnumDevices(DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice, out deviceInfoList); if (0 != result) {

ShowErrorMsg("Enumerate devices fail!", 0); return; }

// ch:在窗体列表中显示设备名 | en:Display device name in the form list for (int i = 0; i < deviceInfoList.Count; i++) {

IDeviceInfo deviceInfo = deviceInfoList[i]; if (deviceInfo.UserDefinedName != "") {

cbDeviceList.Items.Add(deviceInfo.TLayerType.ToString() + ": " + deviceInfo.UserDefinedName + " (" + deviceInfo.SerialNumber + ")"); }

else {

cbDeviceList.Items.Add(deviceInfo.TLayerType.ToString() + ": " + deviceInfo.ManufacturerName + " " + deviceInfo.ModelName + " (" + deviceInfo.SerialNumber + ")"); }

}

// ch:选择第一项 | en:Select the first item if (deviceInfoList.Count != 0) {

cbDeviceList.SelectedIndex = 0; }

}

private void bnOpen_Click(object sender, EventArgs e) {

if (deviceInfoList.Count == 0 || cbDeviceList.SelectedIndex == -1) {

ShowErrorMsg("No device, please select", 0); return; }

// ch:获取选择的设备信息 | en:Get selected device information IDeviceInfo deviceInfo = deviceInfoList[cbDeviceList.SelectedIndex];

try {

// ch:打开设备 | en:Open device device = DeviceFactory.CreateDevice(deviceInfo); }

catch (Exception ex) {

MessageBox.Show("Create Device fail!" + ex.Message); return; }

int result = device.Open(); if (result != MvError.MV_OK) {

ShowErrorMsg("Open Device fail!", result); return; }

//ch: 判断是否为gige设备 | en: Determine whether it is a GigE device if (device is IGigEDevice) {

//ch: 转换为gigE设备 | en: Convert to Gige device IGigEDevice gigEDevice = device as IGigEDevice;

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) int optionPacketSize; result = gigEDevice.GetOptimalPacketSize(out optionPacketSize); if (result != MvError.MV_OK) {

ShowErrorMsg("Warning: Get Packet Size failed!", result); }

else {

result = device.Parameters.SetIntValue("GevSCPSPacketSize", (long)optionPacketSize); if (result != MvError.MV_OK) {

ShowErrorMsg("Warning: Set Packet Size failed!", result); }

}

}

// ch:设置采集连续模式 | en:Set Continues Aquisition Mode device.Parameters.SetEnumValueByString("AcquisitionMode", "Continuous"); device.Parameters.SetEnumValueByString("TriggerMode", "Off");

isOpen = true; EnableControls(true); bnGetParameter_Click(null, null); }

private void EnableControls(bool bIsCameraReady) {

bnOpen.Enabled = (isOpen ? false : (bIsCameraReady ? true : false)); bnClose.Enabled = ((isOpen && bIsCameraReady) ? true : false); bnStartGrab.Enabled = ((isGrabbing && bIsCameraReady) ? false : (isOpen ? true : false)); bnStopGrab.Enabled = (isGrabbing ? true : false); cbPixelFormat.Enabled = ((isGrabbing && bIsCameraReady) ? false : (isOpen ? true : false)); cbDisplaySource.Enabled = (isOpen ? true : false); cbLegendCheck.Enabled = (isOpen ? true : false); cbRegionSelect.Enabled = (isOpen ? true : false); bnRegionSetting.Enabled = (isOpen ? true : false); bnWarningSetting.Enabled = (isOpen ? true : false); teTransmissivity.Enabled = (isOpen ? true : false); teTargetDistance.Enabled = (isOpen ? true : false); teEmissivity.Enabled = (isOpen ? true : false); cbMeasureRange.Enabled = (isOpen ? true : false); bnGetParameter.Enabled = (isOpen ? true : false); bnSetParameter.Enabled = (isOpen ? true : false); cbPaletteMode.Enabled = (isOpen ? true : false); cbExportModeCheck.Enabled = (isOpen ? true : false); }

private int ReadEnumIntoCombo(string strKey, ref ComboBox ctrlComboBox) {

IEnumValue enumValue; int result = device.Parameters.GetEnumValue(strKey, out enumValue); if (MvError.MV_OK != result) {

return result; }

ctrlComboBox.Items.Clear(); for (int i = 0; i < enumValue.SupportedNum; ++i) {

ctrlComboBox.Items.Add(enumValue.SupportEnumEntries[i].Symbolic); if (enumValue.CurEnumEntry.Value == enumValue.SupportEnumEntries[i].Value) {

ctrlComboBox.SelectedIndex = i; }

}

return MvError.MV_OK; }

private void bnGetParameter_Click(object sender, EventArgs e) {

int result = ReadEnumIntoCombo("PixelFormat", ref cbPixelFormat); if (MvError.MV_OK != result) {

ShowErrorMsg("Get PixelFormat Fail!", result); return; }

result = ReadEnumIntoCombo("OverScreenDisplayProcessor", ref cbDisplaySource); if (MvError.MV_OK != result) {

ShowErrorMsg("Get OverScreenDisplayProcessor Fail!", result); return; }

result = ReadEnumIntoCombo("PalettesMode", ref cbPaletteMode); if (MvError.MV_OK != result) {

ShowErrorMsg("Get PalettesMode Fail!", result); return; }

bool boolValue = false; result = device.Parameters.GetBoolValue("LegendDisplayEnable", out boolValue); if (MvError.MV_OK != result) {

ShowErrorMsg("Get LegendDisplayEnable Fail!", result); return; }

else {

cbLegendCheck.Checked = boolValue; }

result = device.Parameters.GetBoolValue("MtExpertMode", out boolValue); if (MvError.MV_OK != result) {

ShowErrorMsg("Get MtExpertMode Fail!", result); return; }

else {

cbExportModeCheck.Checked = boolValue; }

result = ReadEnumIntoCombo("TempRegionSelector", ref cbRegionSelect); if (MvError.MV_OK != result) {

ShowErrorMsg("Get TempRegionSelector Fail!", result); return; }

result = ReadEnumIntoCombo("TempMeasurementRange", ref cbMeasureRange); if (MvError.MV_OK != result) {

ShowErrorMsg("Get TempMeasurementRange Fail!", result); return; }

IIntValue intValue; result = device.Parameters.GetIntValue("AtmosphericTransmissivity", out intValue); if (MvError.MV_OK != result) {

ShowErrorMsg("Get AtmosphericTransmissivity Fail!", result); }

else {

teTransmissivity.Text = intValue.CurValue.ToString(); }

IFloatValue floatValue; result = device.Parameters.GetFloatValue("TargetDistance", out floatValue); if (MvError.MV_OK != result) {

ShowErrorMsg("Get TargetDistance Fail!", result); return; }

else {

teTargetDistance.Text = floatValue.CurValue.ToString(); }

result = device.Parameters.GetFloatValue("FullScreenEmissivity", out floatValue); if (MvError.MV_OK != result) {

ShowErrorMsg("Get FullScreenEmissivity!", result); return; }

else {

teEmissivity.Text = floatValue.CurValue.ToString(); }

}

private void ReceiveThreadProcess() {

IFrameOut frameOut; int result = MvError.MV_OK;

while (isGrabbing) {

// ch:获取图像 | en:Get image result = device.StreamGrabber.GetImageBuffer(1000, out frameOut); if (result == MvError.MV_OK) {

// ch:显示图像 | en:Display image device.ImageRender.DisplayOneFrame(displayHandle, frameOut.Image);

// ch:释放图像 | en:Free image device.StreamGrabber.FreeImageBuffer(frameOut); }

}

}

private void bnStartGrab_Click(object sender, EventArgs e) {

if (false == isOpen || true == isGrabbing || null == device) {

return; }

// ch:标志位置true | en:Set position bit true isGrabbing = true;

m_hReceiveThread = new Thread(ReceiveThreadProcess); m_hReceiveThread.Start();

// ch:开始采集 | en:Start Grabbing int result = device.StreamGrabber.StartGrabbing(); if (MvError.MV_OK != result) {

isGrabbing = false; m_hReceiveThread.Join(); ShowErrorMsg("Start Grabbing Fail!", result); return; }

isGrabbing = true; EnableControls(true); }

private void bnClose_Click(object sender, EventArgs e) {

// ch:取流标志位清零 | en:Reset flow flag bit if (isGrabbing == true) {

isGrabbing = false; m_hReceiveThread.Join(); }

// ch:关闭设备 | en:Close Device if (device != null) {

device.Close(); device.Dispose();

}

isGrabbing = false; isOpen = false;

// ch:控件操作 | en:Control Operation EnableControls(true); }

private void bnStopGrab_Click(object sender, EventArgs e) {

if (false == isOpen || false == isGrabbing || null == device) {

return; }

// ch:标志位设为false | en:Set flag bit false isGrabbing = false; m_hReceiveThread.Join();

// ch:停止采集 | en:Stop Grabbing int result = device.StreamGrabber.StopGrabbing(); if (result != MvError.MV_OK) {

ShowErrorMsg("Stop Grabbing Fail!", result); }

isGrabbing = false; // ch:控件操作 | en:Control Operation EnableControls(true); }

private void cbPixelFormat_SelectedIndexChanged(object sender, EventArgs e) {

if (false == isGrabbing) {

int result = device.Parameters.SetEnumValueByString("PixelFormat", cbPixelFormat.SelectedItem.ToString()); if (result != MvError.MV_OK) {

ShowErrorMsg("Set PixelFormat Fail!", result); }

}

}

private void cbDisplaySource_SelectedIndexChanged(object sender, EventArgs e) {

int result = device.Parameters.SetEnumValueByString("OverScreenDisplayProcessor", cbDisplaySource.SelectedItem.ToString()); if (result != MvError.MV_OK) {

ShowErrorMsg("Set OverScreenDisplayProcessor Fail!", result); }

}

private void cbPaletteMode_SelectedIndexChanged(object sender, EventArgs e) {

int result = device.Parameters.SetEnumValueByString("PalettesMode", cbPaletteMode.SelectedItem.ToString()); if (result != MvError.MV_OK) {

ShowErrorMsg("Set PalettesMode Fail!", result); }

}

private void cbLegendCheck_CheckedChanged(object sender, EventArgs e) {

bool bLegendCheck = cbLegendCheck.Checked;

int result = device.Parameters.SetBoolValue("LegendDisplayEnable", bLegendCheck); if (result != MvError.MV_OK) {

ShowErrorMsg("Set LegendDisplayEnable Fail!", result); return; }

result = device.Parameters.SetCommandValue("TempControlLoad"); if (result != MvError.MV_OK) {

ShowErrorMsg("Exec TempControlLoad Fail!", result); }

}

private void cbExportModeCheck_CheckedChanged(object sender, EventArgs e) {

bool bExportModeCheck = cbExportModeCheck.Checked;

int result = device.Parameters.SetBoolValue("MtExpertMode", bExportModeCheck); if (result != MvError.MV_OK) {

ShowErrorMsg("Set ExpertMode Fail!", result); return; }

result = device.Parameters.SetCommandValue("TempControlLoad"); if (result != MvError.MV_OK) {

ShowErrorMsg("Exec TempControlLoad Fail!", result); }

}

private void cbRegionSelect_SelectedIndexChanged(object sender, EventArgs e) {

int result = device.Parameters.SetEnumValueByString("TempRegionSelector", cbRegionSelect.SelectedItem.ToString()); if (result != MvError.MV_OK) {

ShowErrorMsg("Set TempRegionSelector Fail!", result); }

}

private void cbMeasureRange_SelectedIndexChanged(object sender, EventArgs e) {

int result = device.Parameters.SetEnumValueByString("TempMeasurementRange", cbMeasureRange.SelectedItem.ToString()); if (result != MvError.MV_OK) {

ShowErrorMsg("Set TempMeasurementRange Fail!", result); }

}

private void bnSetParameter_Click(object sender, EventArgs e) {

try {

int.Parse(teTransmissivity.Text); float.Parse(teTargetDistance.Text); float.Parse(teEmissivity.Text); }

catch {

ShowErrorMsg("Please enter correct type!", 0); return; }

int result = device.Parameters.SetIntValue("AtmosphericTransmissivity", long.Parse(teTransmissivity.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set AtmosphericTransmissivity Fail!", result); }

result = device.Parameters.SetFloatValue("TargetDistance", float.Parse(teTargetDistance.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set TargetDistance Fail!", result); }

result = device.Parameters.SetFloatValue("FullScreenEmissivity", float.Parse(teEmissivity.Text) + 0.000001F); if (result != MvError.MV_OK) {

ShowErrorMsg("Set FullScreenEmissivity Fail!", result); }

}

private void bnRegionSetting_Click(object sender, EventArgs e) {

if (cbRegionSelect.SelectedIndex < 0) {

ShowErrorMsg("No Region is selected", MvError.MV_OK); return; }

bool bExportModeCheck = cbExportModeCheck.Checked; InfraredDemo.RegionSettingForm = new FormRegionSetting(ref device, ref cbRegionSelect, ref bExportModeCheck);

InfraredDemo.RegionSettingForm.Show(); RegionSettingForm.Show(); }

private void bnWarningSetting_Click(object sender, EventArgs e) {

if (cbRegionSelect.SelectedIndex < 0) {

ShowErrorMsg("No Region is selected", MvError.MV_OK); return; }

InfraredDemo.AlarmSettingForm = new FormAlarmSetting(ref device, ref cbRegionSelect); InfraredDemo.AlarmSettingForm.Show(); AlarmSettingForm.Show(); }

private void InfraredDemo_Closing(object sender, FormClosingEventArgs e) {

bnClose_Click(sender, null);

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize(); }

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

红外相机温度显示区域配置 （FormRegionSetting.cs）

该示例演示如何配置红外相机的温度显示区域。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using MvCameraControl;

namespace InfraredDemo {

public partial class FormRegionSetting : Form {

public enum RegionType {

Region_Point = 0, Region_Polygon = 1, Region_Line = 2, Region_Circle = 3, };

public void InitParameter() {

string strType = ctrlRegionSelectComboBox.SelectedItem.ToString().Substring(0, 4);

if (true == strType.Equals("Line", StringComparison.OrdinalIgnoreCase)) {

regionType = RegionType.Region_Line; }

else if (true == strType.Equals("Poly", StringComparison.OrdinalIgnoreCase)) {

regionType = RegionType.Region_Polygon; }

else if (true == strType.Equals("Circ", StringComparison.OrdinalIgnoreCase)) {

regionType = RegionType.Region_Circle; }

if (null == device) {

return; }

lbCurrentRegion.Text = ctrlRegionSelectComboBox.SelectedItem.ToString();

bool boolValue; device.Parameters.GetBoolValue("TempRegionEnable", out boolValue); cbSetEnableCheck.Checked = boolValue;

if (boolValue) {

int result = device.Parameters.SetEnumValue("RegionDisplaySelector", (uint)ctrlRegionSelectComboBox.SelectedIndex); if (result == MvError.MV_OK) {

device.Parameters.GetBoolValue("RegionDisplayMaxTempEnable", out boolValue); cbSetMaxCheck.Checked = boolValue;

device.Parameters.GetBoolValue("RegionDisplayMinTempEnable", out boolValue); cbSetMinCheck.Checked = boolValue;

device.Parameters.GetBoolValue("RegionDisplayAvgTempEnable", out boolValue); cbSetAvgCheck.Checked = boolValue; }

}

if (m_bExportMode) {

device.Parameters.GetBoolValue("TempRegionReflectEnable", out boolValue); cbSetReflectCheck.Checked = boolValue;

IFloatValue floatValue; device.Parameters.GetFloatValue("TempRegionReflectance", out floatValue); teSetReflectance.Text = floatValue.CurValue.ToString();

device.Parameters.GetFloatValue("TempRegionTargetDistance", out floatValue); teSetTargetDistance.Text = floatValue.CurValue.ToString();

device.Parameters.GetFloatValue("TempRegionEmissivity", out floatValue); teSetEmissivity.Text = floatValue.CurValue.ToString(); }

IIntValue intValue; device.Parameters.GetIntValue("TempRegionPointNum", out intValue); teSetPointNum.Text = intValue.CurValue.ToString();

device.Parameters.GetIntValue("TempRegionPointPositionX", out intValue); teSetPointX.Text = intValue.CurValue.ToString();

device.Parameters.GetIntValue("TempRegionPointPositionY", out intValue); teSetPointY.Text = intValue.CurValue.ToString();

device.Parameters.GetIntValue("TempRegionCenterPointPositionX", out intValue); teSetCenterX.Text = intValue.CurValue.ToString();

device.Parameters.GetIntValue("TempRegionCenterPointPositionY", out intValue); teSetCenterY.Text = intValue.CurValue.ToString();

device.Parameters.GetIntValue("TempRegionRadius", out intValue); teSetRadius.Text = intValue.CurValue.ToString();

ReadEnumIntoCombo("TempRegionPointSelector", ref cbSetPointInfrx);

switch (regionType) {

case RegionType.Region_Point: cbSetPointInfrx.Enabled = false; teSetPointNum.Enabled = false; teSetCenterX.Enabled = false; teSetCenterY.Enabled = false; teSetRadius.Enabled = false; break; case RegionType.Region_Polygon: teSetCenterX.Enabled = false; teSetCenterY.Enabled = false; teSetRadius.Enabled = false; break; case RegionType.Region_Line: teSetPointNum.Enabled = false; teSetCenterX.Enabled = false; teSetCenterY.Enabled = false; teSetRadius.Enabled = false; break; case RegionType.Region_Circle: cbSetPointInfrx.Enabled = false; teSetPointNum.Enabled = false; teSetPointX.Enabled = false; teSetPointY.Enabled = false; break; default: break; }

}

private int ReadEnumIntoCombo(string strKey, ref ComboBox ctrlComboBox) {

IEnumValue enumValue; int result = device.Parameters.GetEnumValue(strKey, out enumValue); if (MvError.MV_OK != result) {

return result; }

ctrlComboBox.Items.Clear(); for (int i = 0; i < enumValue.SupportedNum; ++i) {

ctrlComboBox.Items.Add(enumValue.SupportEnumEntries[i].Symbolic); if (enumValue.CurEnumEntry.Value == enumValue.SupportEnumEntries[i].Value) {

ctrlComboBox.SelectedIndex = i; }

}

return MvError.MV_OK; }

IDevice device; RegionType regionType; ComboBox ctrlRegionSelectComboBox; bool m_bExportMode;

public FormRegionSetting() {

InitializeComponent(); }

public FormRegionSetting(ref IDevice device, ref ComboBox RegionSelectComboBox, ref bool bExportModeCheck) : this()

{

this.device = device; regionType = RegionType.Region_Point; ctrlRegionSelectComboBox = RegionSelectComboBox; m_bExportMode = bExportModeCheck;

InitParameter();

if (!m_bExportMode) {

cbSetReflectCheck.Hide(); teSetReflectance.Hide(); teSetEmissivity.Hide(); teSetTargetDistance.Hide();

lbSetReflectCheck.Hide(); lbSetReflectance.Hide(); lbSetEmissivity.Hide(); lbSetTargetDistance.Hide(); }

}

// ch:显示错误信息 | en:Show error message private void ShowErrorMsg(string csMessage, int nErrorNum) {

string errorMsg; if (nErrorNum == 0) {

errorMsg = csMessage; }

else {

errorMsg = csMessage + ": Error =" + String.Format("{0:X}", nErrorNum); }

switch (nErrorNum) {

case MvError.MV_E_HANDLE: errorMsg += "Error or invalid handle "; break; case MvError.MV_E_SUPPORT: errorMsg += "Not supported function "; break; case MvError.MV_E_BUFOVER: errorMsg += "Cache is full "; break; case MvError.MV_E_CALLORDER: errorMsg += "Function calling order error "; break; case MvError.MV_E_PARAMETER: errorMsg += "Incorrect parameter "; break; case MvError.MV_E_RESOURCE: errorMsg += "Applying resource failed "; break; case MvError.MV_E_NODATA: errorMsg += "No data "; break; case MvError.MV_E_PRECONDITION: errorMsg += "Precondition error, or running environment changed "; break; case MvError.MV_E_VERSION: errorMsg += "Version mismatches "; break; case MvError.MV_E_NOENOUGH_BUF: errorMsg += "Insufficient memory "; break; case MvError.MV_E_ABNORMAL_IMAGE: errorMsg += "Abnormal image, maybe incomplete image because of lost packet "; break; case MvError.MV_E_UNKNOW: errorMsg += "Unknown error "; break; case MvError.MV_E_GC_GENERIC: errorMsg += "General error "; break; case MvError.MV_E_GC_ACCESS: errorMsg += "Node accessing condition error "; break; case MvError.MV_E_ACCESS_DENIED: errorMsg += "No permission "; break; case MvError.MV_E_BUSY: errorMsg += "Device is busy, or network disconnected "; break; case MvError.MV_E_NETER: errorMsg += "Network error "; break; }

MessageBox.Show(errorMsg, "PROMPT"); }

private void cbSetPointInfrx_SelectedIndexChanged(object sender, EventArgs e) {

int result = device.Parameters.SetEnumValueByString("TempRegionPointSelector", cbSetPointInfrx.SelectedItem.ToString()); if (result != MvError.MV_OK) {

ShowErrorMsg("Set TempRegionPointSelector Fail!", result); }

IIntValue intValue; device.Parameters.GetIntValue("TempRegionPointPositionX", out intValue); teSetPointX.Text = intValue.CurValue.ToString();

device.Parameters.GetIntValue("TempRegionPointPositionY", out intValue); teSetPointY.Text = intValue.CurValue.ToString(); }

private void bnSetParam_Click(object sender, EventArgs e) {

bool regionEnable = cbSetEnableCheck.Checked; int result = device.Parameters.SetBoolValue("TempRegionEnable", regionEnable); if (MvError.MV_OK == result && regionEnable) {

result = device.Parameters.SetEnumValueByString("RegionDisplaySelector", ctrlRegionSelectComboBox.SelectedItem.ToString()); if (result != MvError.MV_OK) {

ShowErrorMsg("Set RegionDisplaySelector Fail!", result); return; }

device.Parameters.SetBoolValue("RegionDisplayEnable", true); device.Parameters.SetBoolValue("RegionDisplayMaxTempEnable", cbSetMaxCheck.Checked); device.Parameters.SetBoolValue("RegionDisplayMinTempEnable", cbSetMinCheck.Checked); device.Parameters.SetBoolValue("RegionDisplayAvgTempEnable", cbSetAvgCheck.Checked); }

else if (MvError.MV_OK != result) {

ShowErrorMsg("Set TempRegionEnable Fail!", result); return; }

if (m_bExportMode) {

try {

float.Parse(teSetReflectance.Text); float.Parse(teSetEmissivity.Text); float.Parse(teSetTargetDistance.Text); }

catch {

ShowErrorMsg("Please enter correct type!", 0); return; }

result = device.Parameters.SetBoolValue("TempRegionReflectEnable", cbSetReflectCheck.Checked); if (MvError.MV_OK != result) {

ShowErrorMsg("Set TempRegionReflectEnable Fail!", result); }

result = device.Parameters.SetFloatValue("TempRegionReflectance", float.Parse(teSetReflectance.Text)); if (MvError.MV_OK != result) {

ShowErrorMsg("Set TempRegionReflectance Fail!", result); }

result = device.Parameters.SetFloatValue("TempRegionEmissivity", float.Parse(teSetEmissivity.Text)); if (MvError.MV_OK != result) {

ShowErrorMsg("Set TempRegionEmissivity Fail!", result); }

result = device.Parameters.SetFloatValue("TempRegionTargetDistance", float.Parse(teSetTargetDistance.Text)); if (MvError.MV_OK != result) {

ShowErrorMsg("Set TempRegionTargetDistance Fail!", result); }

}

result = device.Parameters.SetCommandValue("TempControlLoad"); if (result != MvError.MV_OK) {

ShowErrorMsg("Exec TempControlLoad Fail!", result); }

}

private void bnSetPoint_Click(object sender, EventArgs e) {

try {

int.Parse(teSetPointNum.Text); int.Parse(teSetPointX.Text); int.Parse(teSetPointY.Text); int.Parse(teSetCenterX.Text); int.Parse(teSetCenterY.Text); int.Parse(teSetRadius.Text); }

catch {

ShowErrorMsg("Please enter correct type!", 0); return; }

int nPrePotNum = int.Parse(teSetPointNum.Text);

IIntValue intValue; device.Parameters.GetIntValue("TempRegionPointNum", out intValue);

int result = MvError.MV_OK; if (nPrePotNum != intValue.CurValue) {

result = device.Parameters.SetIntValue("TempRegionPointNum", int.Parse(teSetPointNum.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set TempRegionPointNum Fail!", result); return; }

result = device.Parameters.SetCommandValue("TempControlLoad"); if (result != MvError.MV_OK) {

ShowErrorMsg("Exec TempControlLoad Fail!", result); return; }

ReadEnumIntoCombo("TempRegionPointSelector", ref cbSetPointInfrx);

device.Parameters.GetIntValue("TempRegionPointPositionX", out intValue); teSetPointX.Text = intValue.CurValue.ToString();

device.Parameters.GetIntValue("TempRegionPointPositionY", out intValue); teSetPointY.Text = intValue.CurValue.ToString();

return; }

switch (regionType) {

case RegionType.Region_Point: case RegionType.Region_Polygon: case RegionType.Region_Line: {

result = device.Parameters.SetIntValue("TempRegionPointPositionX", int.Parse(teSetPointX.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set TempRegionPointPositionX Fail!", result); }

result = device.Parameters.SetIntValue("TempRegionPointPositionY", int.Parse(teSetPointY.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set TempRegionPointPositionY Fail!", result); }

break; }

case RegionType.Region_Circle: {

result = device.Parameters.SetIntValue("TempRegionCenterPointPositionX", int.Parse(teSetCenterX.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set TempRegionCenterPointPositionX Fail!", result); }

result = device.Parameters.SetIntValue("TempRegionCenterPointPositionY", int.Parse(teSetCenterY.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set TempRegionCenterPointPositionY Fail!", result); }

result = device.Parameters.SetIntValue("TempRegionRadius", int.Parse(teSetRadius.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set TempRegionRadius Fail!", result); }

break; }

default: break; }

result = device.Parameters.SetCommandValue("TempControlLoad"); if (result != MvError.MV_OK) {

ShowErrorMsg("Exec TempControlLoad Fail!", result); }

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

红外相机温度报警参数配置（FormAlarmSetting.cs）

该示例演示如何配置红外相机的温度报警参数。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using MvCameraControl;

namespace InfraredDemo {

public partial class FormAlarmSetting : Form {

IDevice device; ComboBox ctrlRegionSelectComboBox;

public void InitParameter() {

if (null == device) {

return; }

string currentRegion = ctrlRegionSelectComboBox.SelectedItem.ToString(); lbCurrentRegion.Text = currentRegion;

int result = device.Parameters.SetEnumValue("TempRegionAlarmRuleSelector", (uint)ctrlRegionSelectComboBox.SelectedIndex); if (result != MvError.MV_OK) {

ShowErrorMsg("Read TempRegionAlarmRuleSelector Fail!", result); return; }

bool boolValue; device.Parameters.GetBoolValue("TempRegionAlarmRuleEnable", out boolValue); cbSetAlarmEnableCheck.Checked = boolValue;

XmlAccessMode accessMode; device.Parameters.GetNodeAccessMode("TempRegionAlarmRuleEnable", out accessMode); if (accessMode != XmlAccessMode.RW) {

cbSetAlarmEnableCheck.Enabled = false; }

IFloatValue floatValue; device.Parameters.GetFloatValue("TempRegionAlarmReferenceValue", out floatValue); teSetAlarmReference.Text = floatValue.CurValue.ToString();

device.Parameters.GetFloatValue("TempRegionAlarmRecoveryABSValue", out floatValue); teSetAlarmAbs.Text = floatValue.CurValue.ToString();

ReadEnumIntoCombo("TempRegionAlarmRuleSource", ref cbSetAlarmSource); ReadEnumIntoCombo("TempRegionAlarmRuleCondition", ref cbSetAlarmCondition); }

public FormAlarmSetting() {

InitializeComponent(); }

public FormAlarmSetting(ref IDevice device, ref ComboBox RegionSelectComboBox) : this()

{

this.device = device; ctrlRegionSelectComboBox = RegionSelectComboBox; InitParameter(); }

// ch:显示错误信息 | en:Show error message private void ShowErrorMsg(string message, int errorCode) {

string errorMsg; if (errorCode == 0) {

errorMsg = message; }

else {

errorMsg = message + ": Error =" + String.Format("{0:X}", errorCode); }

switch (errorCode) {

case MvError.MV_E_HANDLE: errorMsg += "Error or invalid handle "; break; case MvError.MV_E_SUPPORT: errorMsg += "Not supported function "; break; case MvError.MV_E_BUFOVER: errorMsg += "Cache is full "; break; case MvError.MV_E_CALLORDER: errorMsg += "Function calling order error "; break; case MvError.MV_E_PARAMETER: errorMsg += "Incorrect parameter "; break; case MvError.MV_E_RESOURCE: errorMsg += "Applying resource failed "; break; case MvError.MV_E_NODATA: errorMsg += "No data "; break; case MvError.MV_E_PRECONDITION: errorMsg += "Precondition error, or running environment changed "; break; case MvError.MV_E_VERSION: errorMsg += "Version mismatches "; break; case MvError.MV_E_NOENOUGH_BUF: errorMsg += "Insufficient memory "; break; case MvError.MV_E_ABNORMAL_IMAGE: errorMsg += "Abnormal image, maybe incomplete image because of lost packet "; break; case MvError.MV_E_UNKNOW: errorMsg += "Unknown error "; break; case MvError.MV_E_GC_GENERIC: errorMsg += "General error "; break; case MvError.MV_E_GC_ACCESS: errorMsg += "Node accessing condition error "; break; case MvError.MV_E_ACCESS_DENIED: errorMsg += "No permission "; break; case MvError.MV_E_BUSY: errorMsg += "Device is busy, or network disconnected "; break; case MvError.MV_E_NETER: errorMsg += "Network error "; break; }

MessageBox.Show(errorMsg, "PROMPT"); }

private int ReadEnumIntoCombo(string strKey, ref ComboBox ctrlComboBox) {

IEnumValue enumValue; int result = device.Parameters.GetEnumValue(strKey, out enumValue); if (MvError.MV_OK != result) {

return result; }

ctrlComboBox.Items.Clear(); for (int i = 0; i < enumValue.SupportedNum; ++i) {

ctrlComboBox.Items.Add(enumValue.SupportEnumEntries[i].Symbolic); if (enumValue.CurEnumEntry.Value == enumValue.SupportEnumEntries[i].Value) {

ctrlComboBox.SelectedIndex = i; }

}

return MvError.MV_OK; }

private void bnOK_Click(object sender, EventArgs e) {

int result = MvError.MV_OK; if (cbSetAlarmEnableCheck.Enabled) {

device.Parameters.SetBoolValue("TempRegionAlarmRuleEnable", cbSetAlarmEnableCheck.Checked); if (result != MvError.MV_OK) {

ShowErrorMsg("Set TempRegionAlarmRuleEnable Fail!", result); return; }

if (cbSetAlarmEnableCheck.Checked) {

device.Parameters.SetBoolValue("RegionDisplayAlarmEnable", true); }

}

try {

float.Parse(teSetAlarmReference.Text); float.Parse(teSetAlarmAbs.Text); }

catch {

ShowErrorMsg("Please enter correct type!", 0); return; }

result = device.Parameters.SetEnumValueByString("TempRegionAlarmRuleSource", cbSetAlarmSource.SelectedItem.ToString()); if (result != MvError.MV_OK) {

ShowErrorMsg("Set TempRegionAlarmRuleSource Fail!", result); }

result = device.Parameters.SetEnumValueByString("TempRegionAlarmRuleCondition", cbSetAlarmCondition.SelectedItem.ToString()); if (result != MvError.MV_OK) {

ShowErrorMsg("Set TempRegionAlarmRuleCondition Fail!", result); }

result = device.Parameters.SetFloatValue("TempRegionAlarmReferenceValue", float.Parse(teSetAlarmReference.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set TempRegionAlarmReferenceValue Fail!", result); }

result = device.Parameters.SetFloatValue("TempRegionAlarmRecoveryABSValue", float.Parse(teSetAlarmAbs.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set TempRegionAlarmRecoveryABSValue Fail!", result); }

result = device.Parameters.SetCommandValue("TempControlLoad"); if (result != MvError.MV_OK) {

ShowErrorMsg("Exec TempControlLoad Fail!", result); }

this.Hide();

}

private void bnCancel_Click(object sender, EventArgs e) {

this.Hide();

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

WPF程序调用SDK（BasicDemoWindow.xaml.cs）

该示例演示如何在WPF程序中调用SDK。 using MvCameraControl; using System; using System.Collections.Generic; using System.Threading; using System.Windows;

namespace BasicDemoWPF

{

public partial class BasicDemoWindow : Window {

// ch:枚举的相机类型 | en:TLayerType for enumerate devices readonly DeviceTLayerType enumTLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLGigEDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLXoFDevice;

List<IDeviceInfo> deviceInfoList = new List<IDeviceInfo>(); IDevice device = null;

bool isGrabbing = false; // ch:是否正在取图 | en: Grabbing flag Thread receiveThread = null; // ch:接收图像线程 | en: Receive image thread

public BasicDemoWindow() {

InitializeComponent(); Closing += Window_Closing; Loaded += new RoutedEventHandler(BasicDemoWindow_Load); }

private void BasicDemoWindow_Load(object sender, RoutedEventArgs e) {

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize();

// ch: 枚举设备 | en: Enum Device List RefreshDeviceList(); }

private void ShowErrorMsg(string message, int errorCode) {

string errorMsg; if (errorCode == 0) {

errorMsg = message; }

else {

errorMsg = message + ": Error =" + String.Format("{0:X}", errorCode); }

switch (errorCode) {

case MvError.MV_E_HANDLE: errorMsg += " Error or invalid handle "; break; case MvError.MV_E_SUPPORT: errorMsg += " Not supported function "; break; case MvError.MV_E_BUFOVER: errorMsg += " Cache is full "; break; case MvError.MV_E_CALLORDER: errorMsg += " Function calling order error "; break; case MvError.MV_E_PARAMETER: errorMsg += " Incorrect parameter "; break; case MvError.MV_E_RESOURCE: errorMsg += " Applying resource failed "; break; case MvError.MV_E_NODATA: errorMsg += " No data "; break; case MvError.MV_E_PRECONDITION: errorMsg += " Precondition error, or running environment changed "; break; case MvError.MV_E_VERSION: errorMsg += " Version mismatches "; break; case MvError.MV_E_NOENOUGH_BUF: errorMsg += " Insufficient memory "; break; case MvError.MV_E_UNKNOW: errorMsg += " Unknown error "; break; case MvError.MV_E_GC_GENERIC: errorMsg += " General error "; break; case MvError.MV_E_GC_ACCESS: errorMsg += " Node accessing condition error "; break; case MvError.MV_E_ACCESS_DENIED: errorMsg += " No permission "; break; case MvError.MV_E_BUSY: errorMsg += " Device is busy, or network disconnected "; break; case MvError.MV_E_NETER: errorMsg += " Network error "; break; }

MessageBox.Show(errorMsg, "PROMPT"); }

private void RefreshDeviceList() {

// ch:创建设备列表 | en:Create Device List cbDeviceList.Items.Clear(); int nRet = DeviceEnumerator.EnumDevices(enumTLayerType, out deviceInfoList); if (nRet != MvError.MV_OK) {

ShowErrorMsg("Enumerate devices fail!", nRet); return; }

// ch:在窗体列表中显示设备名 | en:Display device name in the form list for (int i = 0; i < deviceInfoList.Count; i++) {

IDeviceInfo deviceInfo = deviceInfoList[i]; if (deviceInfo.UserDefinedName != "") {

cbDeviceList.Items.Add(deviceInfo.TLayerType.ToString() + ": " + deviceInfo.UserDefinedName + " (" + deviceInfo.SerialNumber + ")"); }

else {

cbDeviceList.Items.Add(deviceInfo.TLayerType.ToString() + ": " + deviceInfo.ManufacturerName + " " + deviceInfo.ModelName + " (" + deviceInfo.SerialNumber + ")"); }

}

// ch:选择第一项 | en:Select the first item if (deviceInfoList.Count != 0) {

cbDeviceList.SelectedIndex = 0; }

}

private void bnEnum_Click(object sender, RoutedEventArgs e) {

RefreshDeviceList(); }

private void bnOpen_Click(object sender, RoutedEventArgs e) {

if (deviceInfoList.Count == 0 || cbDeviceList.SelectedIndex == -1) {

ShowErrorMsg("No device, please select", 0); return; }

// ch:获取选择的设备信息 | en:Get selected device information IDeviceInfo deviceInfo = deviceInfoList[cbDeviceList.SelectedIndex];

try {

// ch:打开设备 | en:Open device device = DeviceFactory.CreateDevice(deviceInfo); }

catch (Exception ex) {

MessageBox.Show("Create Device fail!" + ex.Message); return; }

int result = device.Open(); if (result != MvError.MV_OK) {

ShowErrorMsg("Open Device fail!", result); return; }

//ch: 判断是否为gige设备 | en: Determine whether it is a GigE device if (device is IGigEDevice) {

//ch: 转换为gigE设备 | en: Convert to Gige device IGigEDevice gigEDevice = device as IGigEDevice;

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) int optionPacketSize; result = gigEDevice.GetOptimalPacketSize(out optionPacketSize); if (result != MvError.MV_OK) {

ShowErrorMsg("Warning: Get Packet Size failed!", result); }

else {

result = device.Parameters.SetIntValue("GevSCPSPacketSize", (long)optionPacketSize); if (result != MvError.MV_OK) {

ShowErrorMsg("Warning: Set Packet Size failed!", result); }

}

}

// ch:设置采集连续模式 | en:Set Continues Aquisition Mode device.Parameters.SetEnumValueByString("AcquisitionMode", "Continuous"); device.Parameters.SetEnumValueByString("TriggerMode", "Off");

// ch:控件操作 | en:Control operation SetCtrlWhenOpen();

// ch:获取参数 | en:Get parameters bnGetParam_Click(null, null); }

private void SetCtrlWhenOpen() {

bnOpen.IsEnabled = false; bnClose.IsEnabled = true;

bnStartGrab.IsEnabled = true; bnStopGrab.IsEnabled = false; bnContinuesMode.IsEnabled = true; bnContinuesMode.IsChecked = true; bnTriggerMode.IsEnabled = true; cbSoftTrigger.IsEnabled = false; bnTriggerExec.IsEnabled = false;

tbExposure.IsEnabled = true; tbGain.IsEnabled = true; tbFrameRate.IsEnabled = true; bnGetParam.IsEnabled = true; bnSetParam.IsEnabled = true; }

private void bnClose_Click(object sender, RoutedEventArgs e) {

// ch:取流标志位清零 | en:Reset flow flag bit if (isGrabbing == true) {

bnStopGrab_Click(sender, e); }

// ch:关闭设备 | en:Close Device if (device != null) {

device.Close(); device.Dispose();

}

// ch:控件操作 | en:Control Operation SetCtrlWhenClose(); }

private void SetCtrlWhenClose() {

bnOpen.IsEnabled = true;

bnClose.IsEnabled = false; bnStartGrab.IsEnabled = false; bnStopGrab.IsEnabled = false; bnContinuesMode.IsEnabled = false; bnTriggerMode.IsEnabled = false; cbSoftTrigger.IsEnabled = false; bnTriggerExec.IsEnabled = false;

tbExposure.IsEnabled = false; tbGain.IsEnabled = false; tbFrameRate.IsEnabled = false; bnGetParam.IsEnabled = false; bnSetParam.IsEnabled = false; }

private void bnContinuesMode_Checked(object sender, RoutedEventArgs e) {

device.Parameters.SetEnumValueByString("TriggerMode", "Off"); cbSoftTrigger.IsEnabled = false; bnTriggerExec.IsEnabled = false; }

private void bnTriggerMode_Checked(object sender, RoutedEventArgs e) {

// ch:打开触发模式 | en:Open Trigger Mode device.Parameters.SetEnumValueByString("TriggerMode", "On");

// ch:触发源选择:0 - Line0; | en:Trigger source select:0 - Line0; // 1 - Line1; // 2 - Line2; // 3 - Line3; // 4 - Counter; // 7 - Software; if ((bool)cbSoftTrigger.IsChecked) {

device.Parameters.SetEnumValueByString("TriggerSource", "Software"); if (isGrabbing) {

bnTriggerExec.IsEnabled = true; }

}

else {

device.Parameters.SetEnumValueByString("TriggerSource", "Line0"); }

cbSoftTrigger.IsEnabled = true; cbSoftTrigger.IsChecked = true; }

public void ReceiveThreadProcess() {

IFrameOut frameOut = null; int result = MvError.MV_OK;

IntPtr hWnd = IntPtr.Zero; Dispatcher.Invoke(new Action(() => {

hWnd = displayArea.Handle; }));

while (isGrabbing) {

result = device.StreamGrabber.GetImageBuffer(1000, out frameOut); if (result == MvError.MV_OK) {

device.ImageRender.DisplayOneFrame(hWnd, frameOut.Image);

device.StreamGrabber.FreeImageBuffer(frameOut); }

}

}

private void bnStartGrab_Click(object sender, RoutedEventArgs e) {

try {

// ch:标志位置位true | en:Set position bit true isGrabbing = true;

receiveThread = new Thread(ReceiveThreadProcess); receiveThread.Start(); }

catch (Exception ex) {

MessageBox.Show("Start thread failed!, " + ex.Message); throw; }

// ch:开始采集 | en:Start Grabbing int result = device.StreamGrabber.StartGrabbing(); if (result != MvError.MV_OK) {

isGrabbing = false; receiveThread.Join(); ShowErrorMsg("Start Grabbing Fail!", result); return; }

// ch:控件操作 | en:Control Operation SetCtrlWhenStartGrab(); }

private void SetCtrlWhenStartGrab() {

bnStartGrab.IsEnabled = false; bnStopGrab.IsEnabled = true;

if ((bool)bnTriggerMode.IsChecked) {

cbSoftTrigger.IsEnabled = true; if ((bool)cbSoftTrigger.IsChecked) {

bnTriggerExec.IsEnabled = true; }

}

}

private void bnStopGrab_Click(object sender, RoutedEventArgs e) {

// ch:标志位设为false | en:Set flag bit false isGrabbing = false; receiveThread.Join();

// ch:停止采集 | en:Stop Grabbing int result = device.StreamGrabber.StopGrabbing(); if (result != MvError.MV_OK) {

ShowErrorMsg("Stop Grabbing Fail!", result); }

// ch:控件操作 | en:Control Operation SetCtrlWhenStopGrab(); }

// ch:控件操作 | en:Control Operation private void SetCtrlWhenStopGrab() {

bnStartGrab.IsEnabled = true; bnStopGrab.IsEnabled = false;

cbSoftTrigger.IsEnabled = false; bnTriggerExec.IsEnabled = false; }

private void bnTriggerExec_Click(object sender, RoutedEventArgs e) {

// ch:触发命令 | en:Trigger command int result = device.Parameters.SetCommandValue("TriggerSoftware"); if (result != MvError.MV_OK) {

ShowErrorMsg("Trigger Software Fail!", result); }

}

private void cbSoftTrigger_Checked(object sender, RoutedEventArgs e) {

// ch:触发源设为软触发 | en:Set trigger source as Software device.Parameters.SetEnumValueByString("TriggerSource", "Software"); if (isGrabbing) {

bnTriggerExec.IsEnabled = true; }

}

private void cbSoftTrigger_Unchecked(object sender, RoutedEventArgs e) {

device.Parameters.SetEnumValueByString("TriggerSource", "Line0"); bnTriggerExec.IsEnabled = false; }

private void GetTriggerMode() {

IEnumValue enumValue; int result = device.Parameters.GetEnumValue("TriggerMode", out enumValue); if (result == MvError.MV_OK) {

if (enumValue.CurEnumEntry.Symbolic == "On") {

bnTriggerMode.IsChecked = true; bnContinuesMode.IsChecked = false;

result = device.Parameters.GetEnumValue("TriggerSource", out enumValue); if (result == MvError.MV_OK) {

if (enumValue.CurEnumEntry.Symbolic == "TriggerSoftware") {

cbSoftTrigger.IsEnabled = true; cbSoftTrigger.IsChecked = true; if (isGrabbing) {

bnTriggerExec.IsEnabled = true; }

}

}

}

else {

bnContinuesMode.IsChecked = true; bnTriggerMode.IsChecked = false; }

}

}

private void bnGetParam_Click(object sender, RoutedEventArgs e) {

GetTriggerMode();

IFloatValue floatValue; int result = device.Parameters.GetFloatValue("ExposureTime", out floatValue); if (result == MvError.MV_OK) {

tbExposure.Text = floatValue.CurValue.ToString("F1"); }

result = device.Parameters.GetFloatValue("Gain", out floatValue); if (result == MvError.MV_OK) {

tbGain.Text = floatValue.CurValue.ToString("F1"); }

result = device.Parameters.GetFloatValue("ResultingFrameRate", out floatValue); if (result == MvError.MV_OK) {

tbFrameRate.Text = floatValue.CurValue.ToString("F1"); }

IEnumValue enumValue; result = device.Parameters.GetEnumValue("PixelFormat", out enumValue); if (result == MvError.MV_OK) {

tbPixelFormat.Text = enumValue.CurEnumEntry.Symbolic; }

}

private void bnSetParam_Click(object sender, RoutedEventArgs e) {

try {

float.Parse(tbExposure.Text); float.Parse(tbGain.Text); float.Parse(tbFrameRate.Text); }

catch {

ShowErrorMsg("Please enter correct type!", 0); return; }

device.Parameters.SetEnumValue("ExposureAuto", 0); int result = device.Parameters.SetFloatValue("ExposureTime", float.Parse(tbExposure.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set Exposure Time Fail!", result); }

device.Parameters.SetEnumValue("GainAuto", 0); result = device.Parameters.SetFloatValue("Gain", float.Parse(tbGain.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set Gain Fail!", result); }

result = device.Parameters.SetFloatValue("AcquisitionFrameRate", float.Parse(tbFrameRate.Text)); if (result != MvError.MV_OK) {

ShowErrorMsg("Set Frame Rate Fail!", result); }

}

private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e) {

bnClose_Click(null, null);

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize(); }

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

配置线阵相机IO（ParameterCamera_LineScanIOSettings.cs）

该示例演示如何配置线阵相机帧触发和行触发相关节点IO。回调方式下，SDK内部开启取流线程，通过event方式回调给上层。 using MvCameraControl; using System; using System.Collections.Generic;

namespace Grab_Callback {

class ParameterCamera_LineScanIOSettings {

const DeviceTLayerType devLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLXoFDevice;

void FrameGrabedEventHandler(object sender, FrameGrabbedEventArgs e) {

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , FrameNum[{2}]", e.FrameOut.Image.Width, e.FrameOut.Image.Height, e.FrameOut.FrameNum); }

public void Run() {

IDevice device = null;

try {

List<IDeviceInfo> devInfoList;

// ch:枚举设备 | en:Enum device int ret = DeviceEnumerator.EnumDevices(devLayerType, out devInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("Enum device failed:{0:x8}", ret); return; }

Console.WriteLine("Enum device count : {0}", devInfoList.Count);

if (0 == devInfoList.Count) {

return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in devInfoList) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine();

devIndex++;

}

Console.Write("Please input index(0-{0:d}):", devInfoList.Count - 1);

// ch:选择设备 | en:Select a device devIndex = Convert.ToInt32(Console.ReadLine());

if (devIndex > devInfoList.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

// ch:创建设备 | en:Create device device = DeviceFactory.CreateDevice(devInfoList[devIndex]);

// ch:打开设备 | en:Open device ret = device.Open(); if (ret != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", ret); return; }

Console.WriteLine("Open device success");

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) if (device is IGigEDevice) {

int packetSize; ret = (device as IGigEDevice).GetOptimalPacketSize(out packetSize); if (packetSize > 0) {

ret = device.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (ret != MvError.MV_OK) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", ret); }

else {

Console.WriteLine("Set PacketSize to {0}", packetSize); }

}

else {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", ret); }

}

Console.WriteLine(""); Console.WriteLine("Please Input trigger selector index: 0-FrameBurstStart, 1-LineStart\n"); uint triggerSelector = Convert.ToUInt32(Console.ReadLine());

switch (triggerSelector) {

case 0: {

// ch:设置触发选项为FrameBurstStart | en:Set trigger selector as FrameBurstStart ret = device.Parameters.SetEnumValue("TriggerSelector", 6); if (ret != MvError.MV_OK) {

Console.WriteLine("Set Trigger Selector fail! nRet {0}\n", ret.ToString("X")); break; }

Console.WriteLine("Set Trigger Selector to FrameBurstStart");

// ch:设置触发模式为on | en:Set trigger mode as On ret = device.Parameters.SetEnumValue("TriggerMode", 1); if (ret != MvError.MV_OK) {

Console.WriteLine("Set Trigger Mode fail! nRet {0}\n", ret.ToString("X")); break; }

Console.WriteLine("Set Trigger Mode to On");

// ch:设置触发源为Line0 | en:Set trigger source as Line0

ret = device.Parameters.SetEnumValue("TriggerSource", 0); if (ret != MvError.MV_OK) {

Console.WriteLine("Set Trigger Source fail! nRet {0}\n", ret.ToString("X")); break; }

Console.WriteLine("Set Trigger Source to Line0"); }

break; case 1: {

// ch:设置触发选项为LineStart | en:Set trigger selector as LineStart ret = device.Parameters.SetEnumValue("TriggerSelector", 9); if (ret != MvError.MV_OK) {

Console.WriteLine("Set Trigger Selector fail! nRet {0}\n", ret.ToString("X")); break; }

Console.WriteLine("Set Trigger Selector to LineStart");

// ch:设置触发模式为on | en:Set trigger mode as On ret = device.Parameters.SetEnumValue("TriggerMode", 1); if (ret != MvError.MV_OK) {

Console.WriteLine("Set Trigger Mode fail! nRet {0}\n", ret.ToString("X")); break; }

Console.WriteLine("Set Trigger Mode to On");

// ch:设置触发源为EncoderModuleOut | en:Set trigger source as EncoderModuleOut ret = device.Parameters.SetEnumValue("TriggerSource", 6); if (ret != MvError.MV_OK) {

Console.WriteLine("Set Trigger Source fail! nRet {0}\n", ret.ToString("X")); break; }

Console.WriteLine("Set Trigger Source to EncoderModuleOut");

// ch:设置编码器选项为Encoder0 | en:Set encoder selector as Encoder0

ret = device.Parameters.SetEnumValue("EncoderSelector", 0); if (ret != MvError.MV_OK) {

Console.WriteLine("Set Encoder Selector fail! nRet {0}\n", ret.ToString("X")); break; }

Console.WriteLine("Set Encoder Selector to Encoder0");

// ch:设置编码器数据源A为Line1 | en:Set encoder source A as Line1

ret = device.Parameters.SetEnumValue("EncoderSourceA", 1); if (ret != MvError.MV_OK) {

Console.WriteLine("Set encoder sourceA fail! nRet {0}\n", ret.ToString("X")); break; }

Console.WriteLine("Set EncoderSourceA to Line1");

// ch:设置编码器数据源B为Line3 | en:Set encoder source B as Line3

ret = device.Parameters.SetEnumValue("EncoderSourceB", 1); if (ret != MvError.MV_OK) {

Console.WriteLine("Set encoder sourceB fail! nRet {0}\n", ret.ToString("X")); break; }

Console.WriteLine("Set EncoderSourceB to Line3"); }

break; default: Console.WriteLine("Input error!"); break; }

//ch: 设置合适的缓存节点数量 | en: Setting the appropriate number of image nodes device.StreamGrabber.SetImageNodeNum(5);

// ch:注册回调函数 | en:Register image callback device.StreamGrabber.FrameGrabedEvent += FrameGrabedEventHandler; // ch:开启抓图 || en: start grab image ret = device.StreamGrabber.StartGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); return; }

Console.WriteLine("Press enter to Stop Grabbing"); Console.ReadLine();

// ch:停止抓图 | en:Stop grabbing ret = device.StreamGrabber.StopGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Stop grabbing failed:{0:x8}", ret); return; }

// ch:关闭设备 | en:Close device ret = device.Close(); if (ret != MvError.MV_OK) {

Console.WriteLine("Close device failed:{0:x8}", ret); return; }

// ch:销毁设备 | en:Destroy device device.Dispose();

device = null; }

catch (Exception e) {

Console.Write("Exception: " + e.Message); }

finally {

// ch:销毁设备 | en:Destroy device if (device != null) {

device.Dispose();

device = null; }

}

}

static void Main(string[] args) {

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize();

ParameterCamera_LineScanIOSettings program = new ParameterCamera_LineScanIOSettings(); program.Run();

Console.WriteLine("Press enter to exit"); Console.ReadKey();

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize(); }

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

通过IP地址连接网口相机（GigE_ConnectCameraByIP.cs）

该示例演示如何基于GigE Vision相机IP地址实现将该类相机连接至您的程序。 using MvCameraControl; using System;

namespace GigE_ConnectCameraByIP

{

class GigE_ConnectCameraByIP

{

static void Main(string[] args) {

int result = MvError.MV_OK; IDevice device = null; int packetSize;

try {

//ch: 初始化SDK | en: Initialize SDK

SDKSystem.Initialize();

// ch:需要连接的相机ip(根据实际填充) //en:The camera IP that needs to be connected (based on actual padding) Console.Write("Please input Device Ip : "); string deviceIp = Convert.ToString(Console.ReadLine());

// ch:相机对应的网卡ip(根据实际填充) // en:The pc IP that needs to be connected (based on actual padding) Console.Write("Please input Net Export Ip : "); string netExport = Convert.ToString(Console.ReadLine());

//ch: 创建设备 | en: Create device device = DeviceFactory.CreateDeviceByIp(deviceIp, netExport); if(null == device) {

Console.WriteLine("Create device failed!"); return; }

//ch: 打开设备 | en:Open device result = device.Open(); if (MvError.MV_OK != result) {

Console.WriteLine("Open device failed:{0:x8}", result); return; }

//ch: 判断是否为gige设备 | en: Determine whether it is a GigE device if (device is IGigEDevice) {

//ch: 转换为gigE设备 | en: Convert to Gige device IGigEDevice gigEDevice = (IGigEDevice)device;

// ch:探测网络最佳包大小(只对GigE相机有效) // en:Detection network optimal package size(It only works for the GigE camera) result = gigEDevice.GetOptimalPacketSize(out packetSize); if (MvError.MV_OK != result) {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", result); }

else {

result = gigEDevice.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (MvError.MV_OK != result) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", result); }

}

}

else {

Console.WriteLine(" Device is not gigEDevice!"); return; }

// ch:设置触发模式为off || en:set trigger mode as off result = device.Parameters.SetEnumValue("TriggerMode", 0); if (MvError.MV_OK != result) {

Console.WriteLine("Set TriggerMode failed:{0:x8}", result); return; }

// ch:开启抓图 || en: start grab image result = device.StreamGrabber.StartGrabbing(); if (MvError.MV_OK != result) {

Console.WriteLine("Start grabbing failed:{0:x8}", result); return; }

int count = 0; IFrameOut frameOut; while(count++ != 10) {

// ch:获取一帧图像 | en:Get one image result = device.StreamGrabber.GetImageBuffer(1000, out frameOut); if (MvError.MV_OK == result) {

Console.WriteLine("Get Image Buffer: Width[{0}] , Height[{1}] , FrameNum[{2}]"

, frameOut.Image.Width, frameOut.Image.Height, frameOut.FrameNum);

ImageFormatInfo info = new ImageFormatInfo(); info.FormatType = ImageFormatType.Jpeg; info.JpegQuality = 80;

string filePath = "Image" + "_w_" + frameOut.Image.Width + "_h" + frameOut.Image.Height + "_p" + frameOut.Image.PixelType.ToString() + "_" + frameOut.FrameNum; filePath += "." + info.FormatType;

//ch: 保持图像到文件 | en: Save image to file result = device.ImageSaver.SaveImageToFile(filePath, frameOut.Image, info, CFAMethod.Fast); if (MvError.MV_OK != result) {

Console.WriteLine("Save Image failed:{0:x8}", result); }

//ch: 释放图像缓存 | en: Release image buffer device.StreamGrabber.FreeImageBuffer(frameOut); }

else {

Console.WriteLine("Get Image failed:{0:x8}", result); }

}

// ch:停止抓图 | en:Stop grabbing result = device.StreamGrabber.StopGrabbing(); if (MvError.MV_OK != result) {

Console.WriteLine("Stop grabbing failed:{0:x8}", result); return; }

// ch:关闭设备 | en:Close device result = device.Close(); if (MvError.MV_OK != result) {

Console.WriteLine("Close device failed:{0:x8}", result); return; }

// ch:销毁设备 | en:Destroy device device.Dispose();

}

catch (Exception e) {

Console.WriteLine("Exception: " + e.Message); }

finally {

if (MvError.MV_OK != result) {

// ch:销毁设备 | en:Destroy device device.Dispose();

}

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize();

Console.WriteLine("Press enter to exit"); Console.ReadKey();

}

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

重连相机（Reconnect.cs）

该示例演示如何在相机异常断开连接时，重新连接相机。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; using MvCameraControl;

namespace Reconnect {

class Reconnect {

const DeviceTLayerType devLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLXoFDevice;

static bool _bExit = false; static bool _bConnect = false; static IDevice _device = null; static string _serialNumber;

static void FrameGrabThread(object obj) {

IStreamGrabber streamGrabber = (IStreamGrabber)obj;

while (true) {

if (!_bConnect) {

break; }

IFrameOut frame;

//ch：获取一帧图像 | en: Get one frame int ret = streamGrabber.GetImageBuffer(1000, out frame); if (ret != MvError.MV_OK) {

Console.WriteLine("Get Image failed:{0:x8}", ret); continue; }

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , FrameNum[{2}]", frame.Image.Width, frame.Image.Height, frame.FrameNum);

//ch: 释放图像缓存 | en: Release the image buffer streamGrabber.FreeImageBuffer(frame); }

}

static void ExceptionEventHandler(object sender, DeviceExceptionArgs e) {

if (e.MsgType == DeviceExceptionType.DisConnect) {

Console.WriteLine("Device disconnect!"); _bConnect = false; }

}

public static void ReconnectProcess() {

int ret = MvError.MV_OK;

while (true) {

if (_bConnect) {

Thread.Sleep(1); continue; }

if (_bExit) {

break; }

if (_device != null) {

_device.StreamGrabber.StopGrabbing(); _device.Close(); _device.Dispose(); _device = null; }

Console.WriteLine("connecting, please wait..."); List<IDeviceInfo> devInfoList; // ch:枚举设备 | en:Enum device ret = DeviceEnumerator.EnumDevices(devLayerType, out devInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("Enum device failed:{0:x8}", ret); continue; }

if (0 == devInfoList.Count) {

continue; }

//ch:根据序列号选择相机 | en: Select camera by serial number int devIndex = 0; bool findDevice = false; foreach (var devInfo in devInfoList) {

if (_serialNumber == devInfo.SerialNumber) {

findDevice = true; break; }

devIndex++;

}

if (!findDevice) {

continue; }

// ch:创建设备 | en:Create device _device = DeviceFactory.CreateDevice(devInfoList[devIndex]);

// ch:打开设备 | en:Open device ret = _device.Open(); if (ret != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", ret); return; }

_bConnect = true;

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) if (_device is IGigEDevice) {

int packetSize; ret = (_device as IGigEDevice).GetOptimalPacketSize(out packetSize); if (packetSize > 0) {

ret = _device.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (ret != MvError.MV_OK) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", ret); }

else {

Console.WriteLine("Set PacketSize to {0}", packetSize); }

}

else {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", ret); }

}

_device.DeviceExceptionEvent += ExceptionEventHandler;

Console.WriteLine("connect succeed!");

// ch:开启抓图 | en: start grab image ret = _device.StreamGrabber.StartGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); continue; }

// ch:开启抓图线程 | en: Start the grabbing thread Thread GrabThread = new Thread(FrameGrabThread); GrabThread.Start(_device.StreamGrabber); }

}

static void Main(string[] args) {

int ret = MvError.MV_OK;

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize();

try {

List<IDeviceInfo> devInfoList;

// ch:枚举设备 | en:Enum device ret = DeviceEnumerator.EnumDevices(devLayerType, out devInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("Enum device failed:{0:x8}", ret); return; }

Console.WriteLine("Enum device count : {0}", devInfoList.Count);

if (0 == devInfoList.Count) {

return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in devInfoList) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine(); devIndex++;

}

Console.Write("Please input index(0-{0:d}):", devInfoList.Count - 1);

devIndex = Convert.ToInt32(Console.ReadLine()); Console.WriteLine(); if (devIndex > devInfoList.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

_serialNumber = devInfoList[devIndex].SerialNumber;

Thread reconnectThread = new Thread(ReconnectProcess); reconnectThread.Start();

Console.WriteLine("Press enter to exit"); Console.ReadKey();

_bConnect = false; _bExit = true; reconnectThread.Join();

// ch:关闭设备 | en:Close device ret = _device.Close(); if (ret != MvError.MV_OK) {

Console.WriteLine("Close device failed:{0:x8}", ret); return; }

// ch:销毁设备 | en:Destroy device _device.Dispose(); _device = null;

}

catch (Exception e) {

Console.Write("Exception: " + e.Message); }

finally {

// ch:销毁设备 | en:Destroy device if (_device != null || ret != MvError.MV_OK) {

_device.Dispose(); _device = null; }

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize();

Console.WriteLine("Press enter to exit"); Console.ReadKey(); }

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

接收相机事件（Events_Camera.cs）

该示例演示如何实现相机事件接收。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using MvCameraControl;

namespace Events_Camera {

class Events_Camera {

const DeviceTLayerType devLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLXoFDevice;

static void DeviceEventGrabedHandler(object sender, DeviceEventArgs e) {

Console.WriteLine("EventName[{0}], EventID[{1}]", e.EventInfo.EventName, e.EventInfo.EventID); }

static void Main(string[] args) {

int ret = MvError.MV_OK; IDevice device = null;

SDKSystem.Initialize();

try {

List<IDeviceInfo> devInfoList;

// ch:枚举设备 | en:Enum device ret = DeviceEnumerator.EnumDevices(devLayerType, out devInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("Enum device failed:{0:x8}", ret); return; }

Console.WriteLine("Enum device count : {0}", devInfoList.Count);

if (0 == devInfoList.Count) {

return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in devInfoList) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine(); devIndex++;

}

Console.Write("Please input index(0-{0:d}):", devInfoList.Count - 1);

devIndex = Convert.ToInt32(Console.ReadLine());

if (devIndex > devInfoList.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

// ch:创建设备 | en:Create device device = DeviceFactory.CreateDevice(devInfoList[devIndex]);

// ch:打开设备 | en:Open device ret = device.Open(); if (ret != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", ret); return; }

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) if (device is IGigEDevice) {

int packetSize; ret = (device as IGigEDevice).GetOptimalPacketSize(out packetSize); if (packetSize > 0) {

ret = device.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (ret != MvError.MV_OK) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", ret); }

else {

Console.WriteLine("Set PacketSize to {0}", packetSize); }

}

else {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", ret); }

}

// ch:设置触发模式为off | en:set trigger mode as off ret = device.Parameters.SetEnumValue("TriggerMode", 0); if (ret != MvError.MV_OK) {

Console.WriteLine("Set TriggerMode failed:{0:x8}", ret); return; }

// ch:开启设备指定事件Event | en:Set Event of ExposureEnd On ret = device.EventNotificationOn("ExposureEnd"); if (ret != MvError.MV_OK) {

Console.WriteLine("EventNotificationOn failed!:{0:x8}", ret); return; }

// ch:注册回调函数 | en:Register Event callback device.EventGrabber.DeviceEvent += DeviceEventGrabedHandler; device.EventGrabber.SubscribeEvent("ExposureEnd");

// ch:开启抓图 || en: start grab image ret = device.StreamGrabber.StartGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); return; }

Console.WriteLine("Press enter to exit"); Console.ReadLine();

// ch:停止抓图 | en:Stop grabbing ret = device.StreamGrabber.StopGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Stop grabbing failed:{0:x8}", ret); return; }

// ch:关闭设备 | en:Close device ret = device.Close(); if (ret != MvError.MV_OK) {

Console.WriteLine("Close device failed:{0:x8}", ret); return; }

// ch:销毁设备 | en:Destroy device device.Dispose();

device = null; }

catch (Exception e) {

Console.Write("Exception: " + e.Message); }

finally {

// ch:销毁设备 | en:Destroy device if (device != null) {

device.Dispose();

device = null; }

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize();

Console.WriteLine("Press enter to exit"); Console.ReadKey(); }

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

接收采集卡事件（Events_Interface.cs）

该示例演示如何实现采集卡事件接收。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using MvCameraControl;

namespace Events_Interface {

class Events_Interface {

private const InterfaceTLayerType IFLayerType = InterfaceTLayerType.MvGigEInterface | InterfaceTLayerType.MvCameraLinkInterface | InterfaceTLayerType.MvCXPInterface | InterfaceTLayerType.MvXoFInterface;

static void DeviceEventGrabedHandler(object sender, DeviceEventArgs e) {

Console.WriteLine("EventName[{0}], EventID[{1}]", e.EventInfo.EventName, e.EventInfo.EventID); }

static void FrameGrabedEventHandler(object sender, FrameGrabbedEventArgs e) {

//Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , FrameNum[{2}]", e.FrameOut.Image.Width, e.FrameOut.Image.Height, e.FrameOut.FrameNum); }

static void Main(string[] args) {

int ret = MvError.MV_OK; IInterface ifInstance = null; IDevice devInstance = null;

SDKSystem.Initialize();

try {

List<IInterfaceInfo> IFInfoList; ret = InterfaceEnumerator.EnumInterfaces(IFLayerType, out IFInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("Enum interface failed:{0:x8}", ret); return; }

if (0 == IFInfoList.Count) {

Console.WriteLine("No interface found"); return; }

// ch:显示采集卡信息 | en:Show interface info int IFIndex = 0; foreach (var ifInfo in IFInfoList) {

Console.WriteLine("[Interface {0}]: ", IFIndex); Console.WriteLine("TLayerType: " + ifInfo.TLayerType.ToString()); Console.WriteLine("DisplayName: " + ifInfo.DisplayName); Console.WriteLine("InterfaceID: " + ifInfo.InterfaceID); Console.WriteLine("SerialNumber: " + ifInfo.SerialNumber); IFIndex++;

}

// ch:选择采集卡 | en:Select interface Console.Write("Please input index(0-{0:d}):", IFInfoList.Count - 1); try {

IFIndex = Convert.ToInt32(Console.ReadLine()); }

catch {

Console.WriteLine("Invalid Index!"); return; }

if (IFIndex < 0 || IFIndex >= IFInfoList.Count) {

Console.WriteLine("Error Index!"); return; }

ifInstance = InterfaceFactory.CreateInterface(IFInfoList[IFIndex]);

// ch:打开采集卡 | en:Open interface ret = ifInstance.Open(); if (ret != MvError.MV_OK) {

Console.WriteLine("Open Interface failed:{0:x8}", ret); return; }

//ch：开启采集卡指定事件 | en: Turn on the specific event of interface ret = ifInstance.EventNotificationOn("ReceiveImageFrameStart0"); if (ret != MvError.MV_OK) {

Console.WriteLine("EventNotificationOn failed:{0:x8}", ret); return; }

// ch:注册回调函数并订阅事件 | en:Register Event callback ifInstance.EventGrabber.DeviceEvent += DeviceEventGrabedHandler; ifInstance.EventGrabber.SubscribeEvent("ReceiveImageFrameStart0");

// ch：枚举相机 | en:Enumerate devices List<IDeviceInfo> devInfoList; ret = ifInstance.EnumDevices(out devInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("EnumDevices failed:{0:x8}", ret); return; }

if (devInfoList.Count == 0) {

Console.WriteLine("No device!"); return; }

//ch: 创建第一个相机的实例 | en: Create device instance(first device) devInstance = DeviceFactory.CreateDevice(devInfoList[0]);

//ch: 打开相机 | en: Open the device ret = devInstance.Open(); if (ret != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", ret); return; }

Console.WriteLine("Open device success!");

//ch：开启取流 | en: Start grabbing devInstance.StreamGrabber.FrameGrabedEvent += FrameGrabedEventHandler; ret = devInstance.StreamGrabber.StartGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("StartGrabbing failed:{0:x8}", ret); return; }

Console.WriteLine("Start grabbing success!");

Console.WriteLine("Press enter to exit"); Console.ReadLine();

devInstance.StreamGrabber.StopGrabbing(); Console.WriteLine("Stop grabbing!");

devInstance.Close(); Console.WriteLine("Close device!");

ifInstance.Close(); Console.WriteLine("Close interface!"); }

catch (Exception e) {

Console.WriteLine("Exception: " + e.Message); }

finally {

//ch： 释放设备资源 | en: Release the resources of device if (devInstance != null) {

devInstance.Dispose(); devInstance = null; }

//ch： 释放采集卡资源 | en: Release the resources of interface if (ifInstance != null) {

ifInstance.Dispose(); ifInstance = null; }

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize();

Console.WriteLine("Press enter to exit"); Console.ReadKey();

}

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

通过回调取图（Grab_Callback.cs）

演示如何通过回调方式取图（ FrameGrabedEvent ）。回调方式下，SDK内部开启取流线程，并通过event方式将相机采集的图像回调给您的程序。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using MvCameraControl;

namespace Grab_Callback {

class Grab_Callback {

const DeviceTLayerType devLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLXoFDevice;

static void FrameGrabedEventHandler(object sender, FrameGrabbedEventArgs e) {

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , ImageSize[{2}], FrameNum[{3}]", e.FrameOut.Image.Width, e.FrameOut.Image.Height, e.FrameOut.Image.ImageSize, e.FrameOut.FrameNum); }

static void Main(string[] args) {

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize();

IDevice device = null;

try {

List<IDeviceInfo> devInfoList;

// ch:枚举设备 | en:Enum device int ret = DeviceEnumerator.EnumDevices(devLayerType, out devInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("Enum device failed:{0:x8}", ret); return; }

Console.WriteLine("Enum device count : {0}", devInfoList.Count);

if (0 == devInfoList.Count) {

return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in devInfoList) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine(); devIndex++; }

Console.Write("Please input index(0-{0:d}):", devInfoList.Count - 1);

devIndex = Convert.ToInt32(Console.ReadLine());

if (devIndex > devInfoList.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

// ch:创建设备 | en:Create device device = DeviceFactory.CreateDevice(devInfoList[devIndex]);

ret = device.Open(); if (ret != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", ret); return; }

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) if (device is IGigEDevice) {

int packetSize; ret = (device as IGigEDevice).GetOptimalPacketSize(out packetSize); if (packetSize > 0) {

ret = device.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (ret != MvError.MV_OK) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", ret); }

else {

Console.WriteLine("Set PacketSize to {0}", packetSize); }

}

else {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", ret); }

}

// ch:设置触发模式为off || en:set trigger mode as off ret = device.Parameters.SetEnumValue("TriggerMode", 0); if (ret != MvError.MV_OK) {

Console.WriteLine("Set TriggerMode failed:{0:x8}", ret); return; }

//ch: 设置合适的缓存节点数量 | en: Setting the appropriate number of image nodes device.StreamGrabber.SetImageNodeNum(5);

// ch:注册回调函数 | en:Register image callback device.StreamGrabber.FrameGrabedEvent += FrameGrabedEventHandler; // ch:开启抓图 || en: start grab image ret = device.StreamGrabber.StartGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); return; }

Console.WriteLine("Press enter to exit"); Console.ReadLine();

// ch:停止抓图 | en:Stop grabbing ret = device.StreamGrabber.StopGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Stop grabbing failed:{0:x8}", ret); return; }

// ch:关闭设备 | en:Close device ret = device.Close(); if (ret != MvError.MV_OK) {

Console.WriteLine("Close device failed:{0:x8}", ret); return; }

// ch:销毁设备 | en:Destroy device device.Dispose(); device = null; }

catch(Exception e) {

Console.Write("Exception: " + e.Message); }

finally {

// ch:销毁设备 | en:Destroy device if (device != null) {

device.Dispose(); device = null; }

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize();

Console.WriteLine("Press enter to exit"); Console.ReadKey(); }

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

轮询取图（Grab_GetImageBuffer.cs）

演示如何创建取图线程，并轮询调用 IStreamGrabber.GetImageBuffer() / IStreamGrabber.FreeImageBuffer() 获取和释放相机所采集的图像。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using MvCameraControl; using System.Threading;

namespace Grab_GetImageBuffer {

class Grab_GetImageBuffer {

const DeviceTLayerType devLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLXoFDevice;

static volatile bool _grabThreadExit = false; static void FrameGrabThread(object obj) {

IStreamGrabber streamGrabber = (IStreamGrabber)obj;

while(!_grabThreadExit) {

IFrameOut frame;

//ch：获取一帧图像 | en: Get one frame int ret = streamGrabber.GetImageBuffer(1000, out frame); if (ret != MvError.MV_OK) {

Console.WriteLine("Get Image failed:{0:x8}", ret); continue; }

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , ImageSize[{2}], FrameNum[{3}]", frame.Image.Width, frame.Image.Height, frame.Image.ImageSize, frame.FrameNum); //Do some thing

//ch: 释放图像缓存 | en: Release the image buffer streamGrabber.FreeImageBuffer(frame); }

}

static void Main(string[] args) {

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize();

IDevice device = null;

try {

List<IDeviceInfo> devInfoList;

// ch:枚举设备 | en:Enum device int ret = DeviceEnumerator.EnumDevices(devLayerType, out devInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("Enum device failed:{0:x8}", ret); return; }

Console.WriteLine("Enum device count : {0}", devInfoList.Count);

if (0 == devInfoList.Count) {

return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in devInfoList) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine(); devIndex++;

}

Console.Write("Please input index(0-{0:d}):", devInfoList.Count - 1);

devIndex = Convert.ToInt32(Console.ReadLine());

if (devIndex > devInfoList.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

// ch:创建设备 | en:Create device device = DeviceFactory.CreateDevice(devInfoList[devIndex]);

ret = device.Open(); if (ret != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", ret); return; }

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) if (device is IGigEDevice) {

int packetSize; ret = (device as IGigEDevice).GetOptimalPacketSize(out packetSize); if (packetSize > 0) {

ret = device.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (ret != MvError.MV_OK) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", ret); }

else {

Console.WriteLine("Set PacketSize to {0}", packetSize); }

}

else {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", ret); }

}

// ch:设置触发模式为off | en:set trigger mode as off ret = device.Parameters.SetEnumValue("TriggerMode", 0); if (ret != MvError.MV_OK) {

Console.WriteLine("Set TriggerMode failed:{0:x8}", ret); return; }

//ch: 设置合适的缓存节点数量 | en: Setting the appropriate number of image nodes device.StreamGrabber.SetImageNodeNum(5);

// ch:开启抓图 | en: start grab image ret = device.StreamGrabber.StartGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); return; }

// ch:开启抓图线程 | en: Start the grabbing thread Thread GrabThread = new Thread(FrameGrabThread); GrabThread.Start(device.StreamGrabber);

Console.WriteLine("Press enter to exit"); Console.ReadLine();

//ch: 通知线程退出 | en: Notify the grab thread to exit _grabThreadExit = true; GrabThread.Join();

// ch:停止抓图 | en:Stop grabbing ret = device.StreamGrabber.StopGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Stop grabbing failed:{0:x8}", ret); return; }

// ch:关闭设备 | en:Close device ret = device.Close(); if (ret != MvError.MV_OK) {

Console.WriteLine("Close device failed:{0:x8}", ret); return; }

// ch:销毁设备 | en:Destroy device device.Dispose(); device = null; }

catch (Exception e) {

Console.Write("Exception: " + e.Message);

}

finally {

// ch:销毁设备 | en:Destroy device if (device != null) {

device.Dispose(); device = null; }

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize();

Console.WriteLine("Press enter to exit"); Console.ReadKey(); }

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

通过ActionCommand触发取图（Grab_ActionCommand.cs）

该示例演示如何在您的程序上实现“通过GigE Vision相机的ActionCommand属性触发该相机取图”。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading; using System.Threading.Tasks; using MvCameraControl; namespace Grab_ActionCommand {

class Grab_ActionCommand {

static bool _bExit = false; static uint _deviceKey = 1; static uint _groupKey = 1; static uint _groupMask = 1;

public static void ActionCommandWorkThread() {

int ret = MvError.MV_OK; ActionCmdInfo actionCmdInfo = new ActionCmdInfo(); List<ActionCmdResult> actionCmdResults;

actionCmdInfo.DeviceKey = _deviceKey; actionCmdInfo.GroupKey = _groupKey; actionCmdInfo.GroupMask = _groupMask; actionCmdInfo.BroadcastAddress = "255.255.255.255"; actionCmdInfo.TimeOut = 100; actionCmdInfo.ActionTimeEnable = 0;

while(!_bExit) {

ret = DeviceEnumerator.GigEIssueActionCommand(actionCmdInfo, out actionCmdResults); if (ret != MvError.MV_OK) {

Console.WriteLine("Issue Action Command failed! nRet {0:x8}", ret); continue; }

if (actionCmdResults != null) {

for (int i = 0; i < actionCmdResults.Count; i++) {

Console.WriteLine("Ip == {0}, Status == {1}", actionCmdResults[i].DeviceAddress, actionCmdResults[i].Status); }

}

}

}

public static void ReceiveImageWorkThread(object obj) {

IStreamGrabber streamGrabber = (IStreamGrabber)obj;

while (true) {

IFrameOut frame;

//ch：获取一帧图像 | en: Get one frame int ret = streamGrabber.GetImageBuffer(1000, out frame); if (ret == MvError.MV_OK) {

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , FrameNum[{2}]", frame.Image.Width, frame.Image.Height, frame.FrameNum);

//ch: 释放图像缓存 | en: Release the image buffer streamGrabber.FreeImageBuffer(frame); }

else {

Console.WriteLine("Get Image failed:{0:x8}", ret); }

if (_bExit) {

break; }

}

}

static void Main(string[] args) {

int ret = MvError.MV_OK;

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize(); IDevice device = null;

try {

List<IDeviceInfo> devInfoList;

// ch:枚举设备 | en:Enum device ret = DeviceEnumerator.EnumDevices(DeviceTLayerType.MvGigEDevice, out devInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("Enum device failed:{0:x8}", ret); return; }

Console.WriteLine("Enum device count : {0}", devInfoList.Count);

if (0 == devInfoList.Count) {

return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in devInfoList) {

if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("[Device {0}]:", devIndex); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); Console.WriteLine("ModelName: {0}\n",devInfo.ModelName); }

else {

Console.Write("Not Support!\n"); break; }

devIndex++;

}

Console.Write("Please input index(0-{0:d}):", devInfoList.Count - 1);

devIndex = Convert.ToInt32(Console.ReadLine());

if (devIndex > devInfoList.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

// ch:创建设备 | en:Create device device = DeviceFactory.CreateDevice(devInfoList[devIndex]);

// ch:打开设备 | en:Open device ret = device.Open(); if (ret != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", ret); return; }

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) if (device is IGigEDevice) {

int packetSize; ret = (device as IGigEDevice).GetOptimalPacketSize(out packetSize); if (packetSize > 0) {

ret = device.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (ret != MvError.MV_OK) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", ret); }

else {

Console.WriteLine("Set PacketSize to {0}", packetSize); }

}

else {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", ret); }

}

// ch:设置触发模式为off || en:set trigger mode as off ret = device.Parameters.SetEnumValue("TriggerMode", 1); if (ret != MvError.MV_OK) {

Console.WriteLine("Set TriggerMode failed:{0:x8}", ret); return; }

// ch:设置触发源为Action1 | en:Set trigger source as Action1

ret = device.Parameters.SetEnumValueByString("TriggerSource", "Action1"); if (ret != MvError.MV_OK) {

Console.WriteLine("Set Trigger Source failed! {0:x8}", ret); return; }

// ch:设置Action Device Key | en:Set Action Device Key ret = device.Parameters.SetIntValue("ActionDeviceKey", _deviceKey); if (ret != MvError.MV_OK) {

Console.WriteLine("Set Action Device Key failed! {0:x8}", ret); return; }

// ch:设置Action Group Key | en:Set Action Group Key ret = device.Parameters.SetIntValue("ActionGroupKey", _groupKey); if (ret != MvError.MV_OK) {

Console.WriteLine("Set Action Group Key failed! {0:x8}", ret); return; }

// ch:设置Action Group Mask | en:Set Action Group Mask ret = device.Parameters.SetIntValue("ActionGroupMask", _groupMask); if (ret != MvError.MV_OK) {

Console.WriteLine("Set Action Group Mask fail! {0:x8}", ret); return; }

// ch:开启抓图 || en: start grab image ret = device.StreamGrabber.StartGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); return; }

Thread hActionCommandThreadHandle = new Thread(ActionCommandWorkThread); hActionCommandThreadHandle.Start();

Thread hReceiveImageThreadHandle = new Thread(ReceiveImageWorkThread); hReceiveImageThreadHandle.Start(device.StreamGrabber);

Console.WriteLine("Press enter to exit"); Console.ReadKey();

_bExit = true; hActionCommandThreadHandle.Join(); hReceiveImageThreadHandle.Join();

// ch:停止抓图 | en:Stop grabbing ret = device.StreamGrabber.StopGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Stop grabbing failed:{0:x8}", ret); return; }

// ch:关闭设备 | en:Close device ret = device.Close(); if (ret != MvError.MV_OK) {

Console.WriteLine("Close device failed:{0:x8}", ret); return; }

// ch:销毁设备 | en:Destroy device device.Dispose();

device = null; }

catch (Exception e) {

Console.Write("Exception: " + e.Message); }

finally {

// ch:销毁设备 | en:Destroy device if (device != null || ret != MvError.MV_OK) {

device.Dispose();

device = null; }

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize();

Console.WriteLine("Press enter to exit"); Console.ReadKey();

}

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

组播（Grab_GigEMultiCast.cs）

该示例演示如何在您的程序实现GigE Vision相机的组播功能。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading; using System.Threading.Tasks; using MvCameraControl;

namespace Grab_GigEMultiCast {

class Grab_GigEMultiCast {

const DeviceTLayerType devLayerType = DeviceTLayerType.MvGigEDevice; public static bool _bExit = false;

static void WorkThread(object obj) {

IStreamGrabber streamGrabber = (IStreamGrabber)obj; while (true) {

IFrameOut frame;

//ch：获取一帧图像 | en: Get one frame int ret = streamGrabber.GetImageBuffer(1000, out frame); if (ret == MvError.MV_OK) {

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , FrameNum[{2}]", frame.Image.Width, frame.Image.Height, frame.FrameNum);

//ch: 释放图像缓存 | en: Release the image buffer streamGrabber.FreeImageBuffer(frame); }

else {

Console.WriteLine("Get Image failed:{0:x8}", ret); }

if (_bExit) {

break; }

}

}

static void Main(string[] args) {

int ret = MvError.MV_OK; IDevice device = null;

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize();

try {

List<IDeviceInfo> devInfoList;

// ch:枚举设备 | en:Enum device ret = DeviceEnumerator.EnumDevices(devLayerType, out devInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("Enum device failed:{0:x8}", ret); return; }

Console.WriteLine("Enum device count : {0}", devInfoList.Count);

if (0 == devInfoList.Count) {

return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in devInfoList) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine(); devIndex++;

}

Console.Write("Please input index(0-{0:d}):", devInfoList.Count - 1);

devIndex = Convert.ToInt32(Console.ReadLine());

if (devIndex > devInfoList.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

// ch:创建设备 | en:Create device device = DeviceFactory.CreateDevice(devInfoList[devIndex]);

// ch:查询用户使用的模式

// Query the user for the mode to use.

bool monitorMode = false; {

string key = "";

// Ask the user to launch the multicast controlling application or the multicast monitoring application.

Console.WriteLine("Start multicast sample in (c)ontrol or in (m)onitor mode? (c/m)"); do {

key = Convert.ToString(Console.ReadLine()); }

while ((key != "c") && (key != "m") && (key != "C") && (key != "M")); monitorMode = (key == "m") || (key == "M"); }

// ch:打开设备 | en:Open device if (monitorMode) {

ret = device.Open(DeviceAccessMode.AccessMonitor, 0); if (ret != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", ret); return; }

}

else {

ret = device.Open(DeviceAccessMode.AccessControl, 0); if (ret != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", ret); return; }

}

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) if (device is IGigEDevice) {

int packetSize; ret = (device as IGigEDevice).GetOptimalPacketSize(out packetSize); if (packetSize > 0) {

ret = device.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (ret != MvError.MV_OK) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", ret); }

else {

Console.WriteLine("Set PacketSize to {0}", packetSize); }

}

else {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", ret); }

}

// ch:指定组播ip | en:The specified multicast IP

string strIp = "239.192.1.1"; var parts = strIp.Split('.'); int nDestIp1 = Convert.ToInt32(parts[0]); int nDestIp2 = Convert.ToInt32(parts[1]); int nDestIp3 = Convert.ToInt32(parts[2]); int nDestIp4 = Convert.ToInt32(parts[3]); int nDestIp = (nDestIp1 << 24) | (nDestIp2 << 16) | (nDestIp3 << 8) | nDestIp4;

ret = (device as IGigEDevice).SetTransmissionType(TransmissionType.Multicast, (uint)nDestIp, 1024); if (ret != MvError.MV_OK) {

Console.WriteLine("Set transmission type failed:{0:x8}", ret); return; }

// ch:开启抓图 | en: start grab image ret = device.StreamGrabber.StartGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); return; }

Thread thr = new Thread(WorkThread); thr.Start(device.StreamGrabber);

Console.WriteLine("Press enter to exit"); Console.ReadLine();

_bExit = true; thr.Join();

// ch:停止抓图 | en:Stop grabbing ret = device.StreamGrabber.StopGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Stop grabbing failed:{0:x8}", ret); return; }

// ch:关闭设备 | en:Close device ret = device.Close(); if (ret != MvError.MV_OK) {

Console.WriteLine("Close device failed:{0:x8}", ret); return; }

// ch:销毁设备 | en:Destroy device device.Dispose(); device = null; }

catch (Exception e) {

Console.Write("Exception: " + e.Message); }

finally {

// ch:销毁设备 | en:Destroy device if (device != null || ret != MvError.MV_OK) {

device.Dispose(); device = null; }

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize();

Console.WriteLine("Press enter to exit"); Console.ReadKey(); }

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

配置取图策略（Grab_Strategy.cs）

该示例演示如何实现取图策略功能。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using MvCameraControl; using System.Threading;

namespace Grab_Strategy {

class Grab_Strategy {

//Only the GigE and USB device support the grab strategy now!

const DeviceTLayerType devLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice;

static volatile bool _grabThreadExit = false; static void FrameGrabThread(object obj) {

IStreamGrabber streamGrabber = (IStreamGrabber)obj;

while (!_grabThreadExit) {

IFrameOut frame;

//ch：获取一帧图像 | en: Get one frame int ret = streamGrabber.GetImageBuffer(1000, out frame); if (ret != MvError.MV_OK) {

Console.WriteLine("Get Image failed:{0:x8}", ret); continue; }

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , FrameNum[{2}]", frame.Image.Width, frame.Image.Height, frame.FrameNum);

//Do something

//ch: 释放图像缓存 | en: Release the image buffer streamGrabber.FreeImageBuffer(frame); }

}

static void StrategyOneByOne(IDevice device) {

int ret = MvError.MV_OK;

// ch:开启抓图 | en: start grab image ret = device.StreamGrabber.StartGrabbing(StreamGrabStrategy.OneByOne); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); return; }

// ch:软触发5次 | en: 5 software triggers for (UInt32 i = 0; i < 5; i++) {

//ch: 软触发 | en: Software trigger ret = device.Parameters.SetCommandValue("TriggerSoftware"); if (ret != MvError.MV_OK) {

Console.WriteLine("Send Trigger Software command fail:{0:x8}", ret); }

else {

Console.WriteLine("Send Trigger Software command:{0}", i); }

Thread.Sleep(500);//如果帧率过小或TriggerDelay很大，可能会出现软触发命令没有全部起效而导致取不到数据的情况

}

//ch: 获取到连续的5帧图像 | en: Obtain a continuous sequence of 5 frames while (true) {

IFrameOut frame; ret = device.StreamGrabber.GetImageBuffer(10, out frame); if (ret == MvError.MV_OK) {

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , FrameNum[{2}]", frame.Image.Width, frame.Image.Height, frame.FrameNum);

//Do something

//ch: 释放图像缓存 | en: Release the image buffer device.StreamGrabber.FreeImageBuffer(frame); }

else {

Console.WriteLine("Get Image failed:{0:x8}", ret); break; }

}

// ch:停止抓图 | en:Stop grabbing ret = device.StreamGrabber.StopGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Stop grabbing failed:{0:x8}", ret); return; }

}

static void StrategyLastImageOnly(IDevice device) {

int ret = MvError.MV_OK;

// ch:开启抓图 | en: start grab image ret = device.StreamGrabber.StartGrabbing(StreamGrabStrategy.LatestImageOnly); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); return; }

// ch:软触发5次 | en: 5 software triggers for (UInt32 i = 0; i < 5; i++) {

//ch: 软触发 | en: Software trigger ret = device.Parameters.SetCommandValue("TriggerSoftware"); if (ret != MvError.MV_OK) {

Console.WriteLine("Send Trigger Software command fail:{0:x8}", ret); }

else {

Console.WriteLine("Send Trigger Software command:{0}", i); }

Thread.Sleep(500);//如果帧率过小或TriggerDelay很大，可能会出现软触发命令没有全部起效而导致取不到数据的情况

}

//ch：获取到最新一帧图像 | en：Obtain the latest frame while (true) {

IFrameOut frame; ret = device.StreamGrabber.GetImageBuffer(10, out frame); if (ret == MvError.MV_OK) {

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , FrameNum[{2}]", frame.Image.Width, frame.Image.Height, frame.FrameNum);

//Do something

//ch: 释放图像缓存 | en: Release the image buffer device.StreamGrabber.FreeImageBuffer(frame); }

else {

Console.WriteLine("Get Image failed:{0:x8}", ret); break; }

}

// ch:停止抓图 | en:Stop grabbing ret = device.StreamGrabber.StopGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Stop grabbing failed:{0:x8}", ret); return; }

}

static void StrategyLastImages(IDevice device) {

int ret = MvError.MV_OK;

//ch: 设置输出2帧图像 | Set out put queue to 2

ret = device.StreamGrabber.SetOutputQueueSize(2);

// ch:开启抓图 | en: start grab image ret = device.StreamGrabber.StartGrabbing(StreamGrabStrategy.LatestImages); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); return; }

// ch:软触发5次 | en: 5 software triggers for (UInt32 i = 0; i < 5; i++) {

//ch: 软触发 | en: Software trigger ret = device.Parameters.SetCommandValue("TriggerSoftware"); if (ret != MvError.MV_OK) {

Console.WriteLine("Send Trigger Software command fail:{0:x8}", ret); }

else {

Console.WriteLine("Send Trigger Software command:{0}", i); }

Thread.Sleep(500);//如果帧率过小或TriggerDelay很大，可能会出现软触发命令没有全部起效而导致取不到数据的情况

}

//ch：获取到最新2帧图像 | en：Obtain the latest two frames while (true) {

IFrameOut frame; ret = device.StreamGrabber.GetImageBuffer(10, out frame); if (ret == MvError.MV_OK) {

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , FrameNum[{2}]", frame.Image.Width, frame.Image.Height, frame.FrameNum);

//Do something

//ch: 释放图像缓存 | en: Release the image buffer device.StreamGrabber.FreeImageBuffer(frame); }

else {

Console.WriteLine("Get Image failed:{0:x8}", ret); break; }

}

// ch:停止抓图 | en:Stop grabbing ret = device.StreamGrabber.StopGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Stop grabbing failed:{0:x8}", ret); return; }

}

static void StrategyUpcomingImage(IDevice device) {

int ret = MvError.MV_OK;

// ch:开启抓图 | en: start grab image ret = device.StreamGrabber.StartGrabbing(StreamGrabStrategy.UpcomingImage); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); return; }

// ch:软触发5次 | en: 5 software triggers for (UInt32 i = 0; i < 5; i++) {

//ch: 软触发 | en: Software trigger ret = device.Parameters.SetCommandValue("TriggerSoftware"); if (ret != MvError.MV_OK) {

Console.WriteLine("Send Trigger Software command fail:{0:x8}", ret); }

else {

Console.WriteLine("Send Trigger Software command:{0}", i); }

Thread.Sleep(500);//如果帧率过小或TriggerDelay很大，可能会出现软触发命令没有全部起效而导致取不到数据的情况

}

Thread triggerThread = new Thread(() => {

// ch: 3秒后触发一次 | en: trigger after 3s Thread.Sleep(3000);

device.Parameters.SetCommandValue("TriggerSoftware"); Console.WriteLine("TriggerThread：Send Trigger Software command"); });

triggerThread.Start();

//ch：获取到3秒后触发的那一帧 | en: Retrieve the frame triggered 3 seconds later while (true) {

IFrameOut frame; ret = device.StreamGrabber.GetImageBuffer(5000, out frame); if (ret == MvError.MV_OK) {

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , FrameNum[{2}]", frame.Image.Width, frame.Image.Height, frame.FrameNum);

//Do something

//ch: 释放图像缓存 | en: Release the image buffer device.StreamGrabber.FreeImageBuffer(frame);

break; }

else {

Console.WriteLine("Get Image failed:{0:x8}", ret); }

}

// ch:停止抓图 | en:Stop grabbing ret = device.StreamGrabber.StopGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Stop grabbing failed:{0:x8}", ret); return; }

}

static void Main(string[] args) {

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize();

IDevice device = null;

try {

List<IDeviceInfo> devInfoList;

// ch:枚举设备 | en:Enum device int ret = DeviceEnumerator.EnumDevices(devLayerType, out devInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("Enum device failed:{0:x8}", ret); return; }

Console.WriteLine("Enum device count : {0}", devInfoList.Count);

if (0 == devInfoList.Count) {

return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in devInfoList) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine();

devIndex++;

}

Console.Write("Please input index(0-{0:d}):", devInfoList.Count - 1);

devIndex = Convert.ToInt32(Console.ReadLine());

if (devIndex > devInfoList.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

// ch:创建设备 | en:Create device device = DeviceFactory.CreateDevice(devInfoList[devIndex]);

ret = device.Open(); if (ret != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", ret); return; }

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) if (device is IGigEDevice) {

int packetSize; ret = (device as IGigEDevice).GetOptimalPacketSize(out packetSize); if (packetSize > 0) {

ret = device.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (ret != MvError.MV_OK) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", ret); }

else {

Console.WriteLine("Set PacketSize to {0}", packetSize); }

}

else {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", ret); }

}

// ch:设置为软触发模式 | en:Set Trigger Mode and Set Trigger Source ret = device.Parameters.SetEnumValueByString("TriggerMode", "On"); if (ret != MvError.MV_OK) {

Console.WriteLine("Set TriggerMode failed:{0:x8}", ret); return; }

ret = device.Parameters.SetEnumValueByString("TriggerSource", "Software"); if (ret != MvError.MV_OK) {

Console.WriteLine("Set Trigger Source failed:{0:x8}", ret); return; }

//ch: 设置合适的缓存节点数量 | en: Setting the appropriate number of image nodes device.StreamGrabber.SetImageNodeNum(10);

Console.WriteLine("\n**************************************************************************"); Console.WriteLine("* 0.GrabStrategy_OneByOne; 1.GrabStrategy_LatestImagesOnly; *"); Console.WriteLine("* 2.GrabStrategy_LatestImages; 3.GrabStrategy_UpcomingImage; *"); Console.WriteLine("**************************************************************************");

Console.Write("Please Input Grab Strategy:"); Int32 nGrabStrategy = 0; try {

nGrabStrategy = (Int32)Convert.ToInt32(Console.ReadLine()); }

catch {

Console.Write("Invalid Input!"); return; }

// ch:U3V相机不支持MV_GrabStrategy_UpcomingImage | en:U3V device not support UpcomingImage if (nGrabStrategy == (Int32)StreamGrabStrategy.UpcomingImage && device is IUSBDevice) {

Console.Write("U3V device not support UpcomingImage"); return; }

if (nGrabStrategy == (Int32)StreamGrabStrategy.OneByOne) {

StrategyOneByOne(device); }

else if (nGrabStrategy == (Int32)StreamGrabStrategy.LatestImageOnly) {

StrategyLastImageOnly(device); }

else if (nGrabStrategy == (Int32)StreamGrabStrategy.LatestImages) {

StrategyLastImages(device); }

else if (nGrabStrategy == (Int32)StreamGrabStrategy.UpcomingImage) {

StrategyUpcomingImage(device); }

// ch:关闭设备 | en:Close device ret = device.Close(); if (ret != MvError.MV_OK) {

Console.WriteLine("Close device failed:{0:x8}", ret); return; }

// ch:销毁设备 | en:Destroy device device.Dispose();

}

catch (Exception e) {

Console.Write("Exception: " + e.Message); }

finally {

// ch:销毁设备 | en:Destroy device if (device != null) {

device.Dispose();

device = null; }

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize();

Console.WriteLine("Press enter to exit"); Console.ReadKey();

}

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

分时频闪（MultiLightCtrl.cs）

该示例演示如何实现从支持分时频闪或多重曝光功能的相机中获取图像和重建图像。 using MvCameraControl; using System; using System.Collections.Generic; using System.Threading; using System.Windows.Forms;

namespace MultiLightCtrl {

public partial class MultiLightCtrl : Form {

const DeviceTLayerType devLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLXoFDevice; IDevice _device = null; List<IDeviceInfo> _devInfoList = null; bool _bGrabbing = false; Thread _hReceiveThread = null; // 取流线程

UInt32 _exposureNum = 0; // 曝光个数

IntPtr[] hWnd = new IntPtr[4]; // 图像显示窗口句柄

List<uint> _userInputExposureNums = new List<uint> {1, 2, 4 }; // 允许用户输入的曝光个数

public MultiLightCtrl() {

InitializeComponent();

this.Load += new EventHandler(this.MultiLightCtrl_Load); btnEnumDevice.Enabled = true; cmbMultiLight.Enabled = false; }

private void MultiLightCtrl_Load(object sender, EventArgs e) {

hWnd[0] = pictureBox1.Handle; hWnd[1] = pictureBox2.Handle; hWnd[2] = pictureBox3.Handle; hWnd[3] = pictureBox4.Handle; // ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize(); }

// ch:显示错误信息 | en:Show error message private void ShowErrorMsg(string csMessage, int nErrorNum) {

string errorMsg; if (nErrorNum == 0) {

errorMsg = csMessage; }

else {

errorMsg = csMessage + ": Error =" + String.Format("{0:X}", nErrorNum); }

switch (nErrorNum) {

case MvError.MV_E_HANDLE: errorMsg += " Error or invalid handle "; break; case MvError.MV_E_SUPPORT: errorMsg += " Not supported function "; break; case MvError.MV_E_BUFOVER: errorMsg += " Cache is full "; break; case MvError.MV_E_CALLORDER: errorMsg += " Function calling order error "; break; case MvError.MV_E_PARAMETER: errorMsg += " Incorrect parameter "; break; case MvError.MV_E_RESOURCE: errorMsg += " Applying resource failed "; break; case MvError.MV_E_NODATA: errorMsg += " No data "; break; case MvError.MV_E_PRECONDITION: errorMsg += " Precondition error, or running environment changed "; break; case MvError.MV_E_VERSION: errorMsg += " Version mismatches "; break; case MvError.MV_E_NOENOUGH_BUF: errorMsg += " Insufficient memory "; break; case MvError.MV_E_UNKNOW: errorMsg += " Unknown error "; break; case MvError.MV_E_GC_GENERIC: errorMsg += " General error "; break; case MvError.MV_E_GC_ACCESS: errorMsg += " Node accessing condition error "; break; case MvError.MV_E_ACCESS_DENIED: errorMsg += " No permission "; break; case MvError.MV_E_BUSY: errorMsg += " Device is busy, or network disconnected "; break; case MvError.MV_E_NETER: errorMsg += " Network error "; break; }

MessageBox.Show(errorMsg, "PROMPT"); }

private void DeviceListAcq() {

int result = 0;

// ch:创建设备列表 | en:Create Device List cmbDeviceList.Items.Clear(); result = DeviceEnumerator.EnumDevices(devLayerType, out _devInfoList); if (MvError.MV_OK != result) {

ShowErrorMsg("DeviceList Acquire Failed!", result); return; }

// ch:在窗体列表中显示设备名 | en:Display device name in the form list for (int i = 0; i < _devInfoList.Count; i++) {

IDeviceInfo deviceInfo = _devInfoList[i]; if (deviceInfo.UserDefinedName != "") {

cmbDeviceList.Items.Add(deviceInfo.TLayerType.ToString() + ": " + deviceInfo.UserDefinedName + " (" + deviceInfo.SerialNumber + ")"); }

else {

cmbDeviceList.Items.Add(deviceInfo.TLayerType.ToString() + ": " + deviceInfo.ManufacturerName + " " + deviceInfo.ModelName + " (" + deviceInfo.SerialNumber + ")"); }

}

// ch:选择第一项 | en:Select the first item if (_devInfoList.Count > 0) {

cmbDeviceList.SelectedIndex = 0; }

}

private void SetCtrlWhenOpen() {

btnEnumDevice.Enabled = true; bnOpen.Enabled = false;

bnClose.Enabled = true; bnStartGrab.Enabled = true; bnStopGrab.Enabled = false; bnContinuesMode.Enabled = true; bnContinuesMode.Checked = true; bnTriggerMode.Enabled = true; cbSoftTrigger.Enabled = false; bnTriggerExec.Enabled = false; cmbMultiLight.Enabled = true; }

private void btnEnumDevice_Click(object sender, EventArgs e) {

DeviceListAcq();

bnOpen.Enabled = true; }

private void bnOpen_Click(object sender, EventArgs e) {

if (_devInfoList.Count == 0 || cmbDeviceList.SelectedIndex == -1) {

ShowErrorMsg("No device, please select", 0); return; }

int ret = MvError.MV_OK;

try {

// ch:创建设备 | en:Create device _device = DeviceFactory.CreateDevice(_devInfoList[cmbDeviceList.SelectedIndex]);

// ch:打开设备 | en:Open device ret = _device.Open(); if (ret != MvError.MV_OK) {

ShowErrorMsg("Device open fail!", ret); return; }

cmbMultiLight.Items.Clear(); IEnumValue multiLightControl; ret = _device.Parameters.GetEnumValue("MultiLightControl", out multiLightControl); if (ret != MvError.MV_OK) {

foreach (var item in _userInputExposureNums) {

cmbMultiLight.Items.Add(item); }

cmbMultiLight.SelectedIndex = 0; _exposureNum = uint.Parse(cmbMultiLight.Text);

radioButtonMultiControlFromUser.Enabled = true; radioButtonMultiControlFromUser.Select(); radioButtonMultiControlFromDevice.Enabled = false;

ret = MvError.MV_OK; }

else {

foreach (IEnumEntry item in multiLightControl.SupportEnumEntries) {

cmbMultiLight.Items.Add(item.Symbolic); if (item.Symbolic == multiLightControl.CurEnumEntry.Symbolic) {

cmbMultiLight.SelectedIndex = Array.IndexOf(multiLightControl.SupportEnumEntries, item); }

}

_exposureNum = multiLightControl.CurEnumEntry.Value & 0xF; radioButtonMultiControlFromUser.Enabled = false; radioButtonMultiControlFromDevice.Enabled = true; radioButtonMultiControlFromDevice.Select(); }

// ch:设置采集连续模式 | en:Set Continues Aquisition Mode _device.Parameters.SetEnumValue("AcquisitionMode", 2); _device.Parameters.SetEnumValue("TriggerMode", 0);

// ch:控件操作 | en:Control operation SetCtrlWhenOpen(); }

catch (Exception ex) {

Console.Write("Exception: " + ex.Message); }

finally {

// ch:打开相机失败 | en:Open device failed if (ret != MvError.MV_OK) {

// ch:销毁设备 | en:Destroy device if (_device != null) {

_device.Dispose(); _device = null; }

}

}

}

private void SetCtrlWhenClose() {

btnEnumDevice.Enabled = true;

bnOpen.Enabled = true;

bnClose.Enabled = false; bnStartGrab.Enabled = false; bnStopGrab.Enabled = false; bnContinuesMode.Enabled = false; bnTriggerMode.Enabled = false; cbSoftTrigger.Enabled = false; bnTriggerExec.Enabled = false; cmbMultiLight.Enabled = false; }

private void bnClose_Click(object sender, EventArgs e) {

// ch:取流标志位清零 | en:Reset flow flag bit if (_bGrabbing == true) {

_bGrabbing = false; _hReceiveThread.Join(); }

// ch:关闭设备 | en:Close Device if (_device != null) {

_device.Close(); _device.Dispose(); _device = null; }

// ch:控件操作 | en:Control Operation SetCtrlWhenClose(); }

private void cmbMultiLight_SelectedIndexChanged(object sender, EventArgs e) {

if (_device == null) {

return; }

// 从相机中获取曝光个数

if (radioButtonMultiControlFromDevice.Checked) {

int nRet = _device.Parameters.SetEnumValueByString("MultiLightControl", cmbMultiLight.Items[cmbMultiLight.SelectedIndex].ToString()); if (MvError.MV_OK != nRet) {

ShowErrorMsg("Set MultiLightControl failed", nRet); }

IEnumValue enumValue; nRet = _device.Parameters.GetEnumValue("MultiLightControl", out enumValue); if (MvError.MV_OK == nRet) {

_exposureNum = enumValue.CurEnumEntry.Value & 0xF; }

}

else {

// 用户输入曝光个数

_exposureNum = uint.Parse(cmbMultiLight.Text); }

}

private void bnContinuesMode_CheckedChanged(object sender, EventArgs e) {

if (_device == null) {

return; }

if (bnContinuesMode.Checked) {

_device.Parameters.SetEnumValue("TriggerMode", 0); cbSoftTrigger.Enabled = false; bnTriggerExec.Enabled = false; }

}

private void bnTriggerMode_CheckedChanged(object sender, EventArgs e) {

if (_device == null) {

return; }

// ch:打开触发模式 | en:Open Trigger Mode if (bnTriggerMode.Checked) {

_device.Parameters.SetEnumValue("TriggerMode", 1); }

// ch:触发源选择:0 - Line0; | en:Trigger source select:0 - Line0; // 1 - Line1; // 2 - Line2; // 3 - Line3; // 4 - Counter; // 7 - Software; if (cbSoftTrigger.Checked) {

_device.Parameters.SetEnumValue("TriggerSource", 7); if (_bGrabbing) {

bnTriggerExec.Enabled = true; }

}

else {

_device.Parameters.SetEnumValue("TriggerSource", 0); }

cbSoftTrigger.Enabled = true; }

private void SetCtrlWhenStartGrab() {

bnStartGrab.Enabled = false; cmbMultiLight.Enabled = false; bnStopGrab.Enabled = true;

if (bnTriggerMode.Checked && cbSoftTrigger.Checked) {

bnTriggerExec.Enabled = true; }

}

public void ReceiveThreadProcess() {

while(_bGrabbing) {

IFrameOut frame;

//ch：获取一帧图像 | en: Get one frame int ret = _device.StreamGrabber.GetImageBuffer(1000, out frame); if (ret != MvError.MV_OK) {

if (bnTriggerMode.Checked) {

Thread.Sleep(5); }

continue; }

// HB格式的图像需要先解码

IFrameOut frameOut = frame; if (frame.Image.PixelType.ToString().Contains("HB")) {

ret = _device.ImageDecoder.HBDecode(frame, out frameOut); if (MvError.MV_OK != ret) {

Console.WriteLine("Decode image failed, {0}", ret.ToString("X")); continue; }

}

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , FrameNum[{2}]", frameOut.Image.Width, frameOut.Image.Height, frameOut.FrameNum);

if (_exposureNum > 1) {

List<IImage> outImages;

ret = _device.ImageProcess.ReconstructImage(frameOut.Image, _exposureNum, ImageReconstructionMethod.SplitByLine, out outImages); if (ret != MvError.MV_OK) {

Console.WriteLine("Reconstruct image failed, {0}", ret.ToString("X")); continue; }

for (int i = 0; i < _exposureNum && i < outImages.Count; i++) {

_device.ImageRender.DisplayOneFrame(hWnd[i], outImages[i]); }

//ch: 图像使用完及时释放，防止内存快速上涨导致频繁GC | en：Release image promptly to prevent rapid memory increase leading to frequent GC.

foreach (var image in outImages) {

image.Dispose(); }

}

else {

_device.ImageRender.DisplayOneFrame(hWnd[0], frameOut.Image); }

//ch: 图像使用完及时释放，防止内存快速上涨导致频繁GC | en：Release image promptly to prevent rapid memory increase leading to frequent GC.

if (frameOut != frame) {

frameOut.Image.Dispose(); }

//ch: 释放图像缓存 | en: Release the image buffer _device.StreamGrabber.FreeImageBuffer(frame); }

}

private void bnStartGrab_Click(object sender, EventArgs e) {

if (_device == null) {

return; }

pictureBox1.Refresh(); pictureBox2.Refresh(); pictureBox3.Refresh(); pictureBox4.Refresh(); // ch:标志位置位true | en:Set position bit true _bGrabbing = true;

_hReceiveThread = new Thread(ReceiveThreadProcess); _hReceiveThread.Start();

// ch:开始采集 | en:Start Grabbing int ret = _device.StreamGrabber.StartGrabbing(); if (MvError.MV_OK != ret) {

_bGrabbing = false; _hReceiveThread.Join(); ShowErrorMsg("Start Grabbing Fail!", ret); return; }

// ch:控件操作 | en:Control Operation SetCtrlWhenStartGrab(); }

private void SetCtrlWhenStopGrab() {

bnStartGrab.Enabled = true; cmbMultiLight.Enabled = true; bnStopGrab.Enabled = false;

bnTriggerExec.Enabled = false; }

private void bnStopGrab_Click(object sender, EventArgs e) {

if (_device == null) {

return; }

// ch:标志位设为false | en:Set flag bit false _bGrabbing = false; _hReceiveThread.Join();

// ch:停止采集 | en:Stop Grabbing int ret = _device.StreamGrabber.StopGrabbing(); if (ret != MvError.MV_OK) {

ShowErrorMsg("Stop Grabbing Fail!", ret); }

// ch:控件操作 | en:Control Operation SetCtrlWhenStopGrab(); }

private void cbSoftTrigger_CheckedChanged(object sender, EventArgs e) {

if (_device == null) {

return; }

if (cbSoftTrigger.Checked) {

// ch:触发源设为软触发 | en:Set trigger source as Software _device.Parameters.SetEnumValue("TriggerSource", 7); if (_bGrabbing) {

bnTriggerExec.Enabled = true; }

}

else {

_device.Parameters.SetEnumValue("TriggerSource", 0); bnTriggerExec.Enabled = false; }

}

private void bnTriggerExec_Click(object sender, EventArgs e) {

if (_device == null) {

return; }

// ch:触发命令 | en:Trigger command int nRet = _device.Parameters.SetCommandValue("TriggerSoftware"); if (MvError.MV_OK != nRet) {

ShowErrorMsg("Trigger Software Fail!", nRet); }

}

private void MultiLightCtrl_FormClosing(object sender, FormClosingEventArgs e) {

bnClose_Click(sender, e);

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize(); }

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

线阵相机分时曝光（MultiLightCtrl_ImageStitching.cs）

该示例示例演示如何设置线阵相机采用2组分时曝光参数（需要相机支持分时曝光功能），先拆图再自上而下拼图，并将拼好的裸图以bmp格式保存至本地。 using MvCameraControl; using System; using System.Collections.Generic;

namespace Image_Contrast {

class MultiLightCtrl_ImageStitching {

const DeviceTLayerType enumTLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice| DeviceTLayerType.MvGenTLGigEDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLXoFDevice;

public void Run() {

int result = MvError.MV_OK; IDevice device = null; List<IDeviceInfo> deviceInfos;

const uint exposureNum = 2; // 分时频闪的灯数, 默认曝光个数为2

try {

result = DeviceEnumerator.EnumDevices(enumTLayerType, out deviceInfos); if (result != MvError.MV_OK) {

Console.WriteLine("Enumerate device failed, result: {0:x8}", result); return; }

if (deviceInfos.Count == 0) {

Console.WriteLine("No device"); return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in deviceInfos) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine(); devIndex++;

}

// ch:需要连接的相机索引 || en:Select a device that want to connect Console.Write("Please input index(0-{0:d}):", deviceInfos.Count - 1);

devIndex = Convert.ToInt32(Console.ReadLine());

if (devIndex > deviceInfos.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

//ch: 创建设备 | en: Create device device = DeviceFactory.CreateDevice(deviceInfos[devIndex]); if (device == null) {

Console.WriteLine("Create device failed!"); return; }

//ch: 打开设备 | en:Open device result = device.Open(); if (result != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", result); return; }

//ch: 判断是否为gige设备 | en: Determine whether it is a GigE device if (device is IGigEDevice) {

//ch: 转换为gigE设备 | en: Convert to Gige device IGigEDevice gigEDevice = (IGigEDevice)device; int packetSize = 0;

// ch:探测网络最佳包大小(只对GigE相机有效) // en:Detection network optimal package size(It only works for the GigE camera) result = gigEDevice.GetOptimalPacketSize(out packetSize); if (MvError.MV_OK != result) {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", result); }

else {

result = gigEDevice.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (MvError.MV_OK != result) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", result); }

}

}

// ch:设置曝光组数为2 || en:set trigger mode as off result = device.Parameters.SetEnumValue("MultiLightControl", exposureNum); if (MvError.MV_OK != result) {

Console.WriteLine("Set MultiLightControl failed:{0:x8}", result); }

else {

Console.WriteLine("Set MultiLightControl to {0}", exposureNum); }

// ch:设置触发模式为off || en:set trigger mode as off result = device.Parameters.SetEnumValue("TriggerMode", 0); if (MvError.MV_OK != result) {

Console.WriteLine("Set TriggerMode failed:{0:x8}", result); return; }

// ch:开启抓图 || en: start grab image result = device.StreamGrabber.StartGrabbing(); if (MvError.MV_OK != result) {

Console.WriteLine("Start grabbing failed:{0:x8}", result); return; }

IFrameOut frameOut; // ch:获取一帧图像 | en:Get one image result = device.StreamGrabber.GetImageBuffer(20000, out frameOut); if (MvError.MV_OK == result) {

Console.WriteLine("Get Image Buffer: Width[{0}] , Height[{1}] , FrameNum[{2}]"

, frameOut.Image.Width, frameOut.Image.Height, frameOut.FrameNum);

// ch:如果图像是HB格式，需要先解码 | en:If the image is HB format, should to be decoded first IFrameOut frameRaw = frameOut; if (frameOut.Image.PixelType.ToString().Contains("HB")) {

result = device.ImageDecoder.HBDecode(frameOut, out frameRaw); if (MvError.MV_OK != result) {

Console.WriteLine("HB Decode failed:{0:x8}", result); return; }

}

ImageReconstructionMethod imageReconstructionMethod = ImageReconstructionMethod.SplitByLine;

// ch:图像重构并拼接 | en:Image Reconstruct and Stitching IImage outImage; result = device.ImageProcess.ReconstructImage(frameOut.Image, exposureNum, imageReconstructionMethod, ImageStitchingMethod.Vertical, out outImage); if (result != MvError.MV_OK) {

Console.WriteLine("Reconstruct Image failed:{0:x8}", result); return; }

Console.WriteLine("Reconstruct Image success!");

string resultImageFilePath = "result.bmp"; ImageFormatInfo imageFormatInfo = new ImageFormatInfo(); imageFormatInfo.FormatType = ImageFormatType.Bmp; result = device.ImageSaver.SaveImageToFile(resultImageFilePath, outImage, imageFormatInfo, CFAMethod.Equilibrated); if (result != MvError.MV_OK) {

Console.WriteLine("Save Image failed:{0:x8}", result); return; }

Console.WriteLine("Save Image success! {0}", resultImageFilePath);

//ch: 图像使用完及时释放，防止内存快速上涨导致频繁GC | en：Release image promptly to prevent rapid memory increase leading to frequent GC.

if (frameRaw != frameOut) {

frameRaw.Image.Dispose(); }

outImage.Dispose();

//ch: 释放图像缓存 | en: Release image buffer device.StreamGrabber.FreeImageBuffer(frameOut); }

else {

Console.WriteLine("Get Image failed:{0:x8}", result); }

// ch:停止抓图 | en:Stop grabbing result = device.StreamGrabber.StopGrabbing(); if (MvError.MV_OK != result) {

Console.WriteLine("Stop grabbing failed:{0:x8}", result); return; }

// ch:关闭设备 | en:Close device result = device.Close(); if (MvError.MV_OK != result) {

Console.WriteLine("Close device failed:{0:x8}", result); return; }

// ch:销毁设备 | en:Destroy device device.Dispose();

device = null;

}

catch (Exception e) {

Console.WriteLine(e.Message); }

finally {

if (device != null) {

// ch:销毁设备 | en:Destroy device device.Dispose();

device = null; }

}

}

static void Main(string[] args) {

//ch: 初始化SDK | en: Initialize SDK

SDKSystem.Initialize();

MultiLightCtrl_ImageStitching program = new MultiLightCtrl_ImageStitching(); program.Run();

Console.WriteLine("Press enter to exit"); Console.ReadKey();

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize(); }

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

深拷贝（Grab_ImageClone.cs）

演示如何实现在取图时深拷贝图像，并将图像放入队列，进行异步处理。 注意

深拷贝仅GigE相机和USB相机支持。

using System; using System.Collections.Generic; using System.Linq; using System.Text; using MvCameraControl; using System.Threading;

namespace Grab_ImageClone {

class Grab_ImageClone {

private const DeviceTLayerType devLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLXoFDevice;

private Queue<IFrameOut> _frameQueue = null; private Thread _asyncProcessThread = null; private Semaphore _frameGrabSem = null; private volatile bool _processThreadExit = false;

public Grab_ImageClone() {

_frameQueue = new Queue<IFrameOut>(); _frameGrabSem = new Semaphore(0, Int32.MaxValue); }

public void Run() {

IDevice device = null;

try {

List<IDeviceInfo> devInfoList;

// ch:枚举设备 | en:Enum device int ret = DeviceEnumerator.EnumDevices(devLayerType, out devInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("Enum device failed:{0:x8}", ret); return; }

Console.WriteLine("Enum device count : {0}", devInfoList.Count);

if (0 == devInfoList.Count) {

return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in devInfoList) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine(); devIndex++;

}

Console.Write("Please input index(0-{0:d}):", devInfoList.Count - 1);

devIndex = Convert.ToInt32(Console.ReadLine());

if (devIndex > devInfoList.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

// ch:创建设备 | en:Create device device = DeviceFactory.CreateDevice(devInfoList[devIndex]);

ret = device.Open(); if (ret != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", ret); return; }

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) if (device is IGigEDevice) {

int packetSize; ret = (device as IGigEDevice).GetOptimalPacketSize(out packetSize); if (packetSize > 0) {

ret = device.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (ret != MvError.MV_OK) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", ret); }

else {

Console.WriteLine("Set PacketSize to {0}", packetSize); }

}

else {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", ret); }

}

// ch:设置触发模式为off || en:set trigger mode as off ret = device.Parameters.SetEnumValue("TriggerMode", 0); if (ret != MvError.MV_OK) {

Console.WriteLine("Set TriggerMode failed:{0:x8}", ret); return; }

//ch: 设置合适的缓存节点数量 | en: Setting the appropriate number of image nodes device.StreamGrabber.SetImageNodeNum(5);

//ch：创建异步处理线程 | en: Create an asynchronous processing thread _processThreadExit = false; _asyncProcessThread = new Thread(AsyncProcessThread); _asyncProcessThread.Start();

// ch:注册回调函数 | en:Register image callback device.StreamGrabber.FrameGrabedEvent += FrameGrabedEventHandler; // ch:开启抓图 || en: start grab image ret = device.StreamGrabber.StartGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); return; }

Console.WriteLine("Press enter to stop grabbing"); Console.ReadLine();

//ch: 通知异步处理线程退出 | en: Notify the thread to exit _processThreadExit = true; _asyncProcessThread.Join();

// ch:停止抓图 | en:Stop grabbing ret = device.StreamGrabber.StopGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Stop grabbing failed:{0:x8}", ret); return; }

// ch:关闭设备 | en:Close device ret = device.Close(); if (ret != MvError.MV_OK) {

Console.WriteLine("Close device failed:{0:x8}", ret); return; }

// ch:销毁设备 | en:Destroy device device.Dispose();

}

catch (Exception e) {

Console.Write("Exception: " + e.Message); }

finally {

// ch:销毁设备 | en:Destroy device if (device != null) {

device.Dispose();

device = null; }

}

}

void AsyncProcessThread() {

try {

while (!_processThreadExit) {

if (_frameGrabSem.WaitOne(100)) {

IFrameOut frame = _frameQueue.Dequeue(); Console.WriteLine("AsyncProcessThread: process one frame, Width[{0}] , Height[{1}] , FrameNum[{2}]", frame.Image.Width, frame.Image.Height, frame.FrameNum); //do something }

}

}

catch (Exception e) {

Console.WriteLine("AsyncProcessThread exception: " + e.Message); }

}

void FrameGrabedEventHandler(object sender, FrameGrabbedEventArgs e) {

Console.WriteLine("FrameGrabedEventHandler: Get one frame, Width[{0}] , Height[{1}] , FrameNum[{2}]", e.FrameOut.Image.Width, e.FrameOut.Image.Height, e.FrameOut.FrameNum);

// ch: 克隆图像数据（深拷贝） | en :Clone frame data using deep copy IFrameOut frameCopy = (IFrameOut)e.FrameOut.Clone();

try {

//ch: 添加到队列并通知处理线程 | en: Add the frame to the queue and notify the processing thread lock (this) {

_frameQueue.Enqueue(frameCopy); _frameGrabSem.Release(); }

}

catch (Exception exception) {

Console.WriteLine("FrameGrabedEventHandler exception: " + exception.Message); }

}

static void Main(string[] args) {

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize();

Grab_ImageClone program = new Grab_ImageClone(); program.Run();

Console.WriteLine("Press enter to exit"); Console.ReadKey();

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize(); }

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

保存图像数据（Image_Save.cs）

该示例演示如何保存图像数据。 using MvCameraControl; using System; using System.Collections.Generic; using System.IO; using System.Runtime.InteropServices;

namespace Image_Contrast {

class Image_Save {

const DeviceTLayerType enumTLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLGigEDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLXoFDevice; public void Run() {

IDevice device = null; List<IDeviceInfo> deviceInfos;

try {

int result = DeviceEnumerator.EnumDevices(enumTLayerType, out deviceInfos); if (result != MvError.MV_OK) {

Console.WriteLine("Enumerate device failed, result: {0:x8}", result); return; }

if (deviceInfos.Count == 0) {

Console.WriteLine("No device"); return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in deviceInfos) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine(); devIndex++;

}

// ch:需要连接的相机索引 || en:Select a device that want to connect Console.Write("Please input index(0-{0:d}):", deviceInfos.Count - 1); devIndex = Convert.ToInt32(Console.ReadLine()); if (devIndex > deviceInfos.Count - 1 || devIndex < 0) {

Console.WriteLine("Input Error!\n"); return; }

// ch:选择要保存的文件类型 | en: Select the file type for image save Console.WriteLine("Please select the file type to save:"); Console.WriteLine("0: Raw"); Console.WriteLine("1: " + ImageFormatType.Bmp); Console.WriteLine("2: " + ImageFormatType.Jpeg); Console.WriteLine("3: " + ImageFormatType.Png); Console.WriteLine("4: " + ImageFormatType.Tiff); int imageFormatType = Convert.ToInt32(Console.ReadLine()); if (imageFormatType < 0 || imageFormatType > 4) {

Console.WriteLine("Input Error!\n"); return; }

//ch: 创建设备 | en: Create device device = DeviceFactory.CreateDevice(deviceInfos[devIndex]); if (device == null) {

Console.WriteLine("Create device failed!"); return; }

//ch: 打开设备 | en:Open device result = device.Open(); if (result != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", result); return; }

//ch: 判断是否为gige设备 | en: Determine whether it is a GigE device if (device is IGigEDevice) {

//ch: 转换为gigE设备 | en: Convert to Gige device IGigEDevice gigEDevice = (IGigEDevice)device;

// ch:探测网络最佳包大小(只对GigE相机有效) // en:Detection network optimal package size(It only works for the GigE camera) int packetSize; result = gigEDevice.GetOptimalPacketSize(out packetSize); if (MvError.MV_OK != result) {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", result); }

else {

result = gigEDevice.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (MvError.MV_OK != result) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", result); }

}

}

// ch:设置触发模式为off || en:set trigger mode as off result = device.Parameters.SetEnumValue("TriggerMode", 0); if (MvError.MV_OK != result) {

Console.WriteLine("Set TriggerMode failed:{0:x8}", result); return; }

// ch:开启抓图 || en: start grab image result = device.StreamGrabber.StartGrabbing(); if (MvError.MV_OK != result) {

Console.WriteLine("Start grabbing failed:{0:x8}", result); return; }

IFrameOut frameOut; // ch:获取一帧图像 | en:Get one image result = device.StreamGrabber.GetImageBuffer(1000, out frameOut); if (MvError.MV_OK == result) {

Console.WriteLine("Get Image Buffer: Width[{0}] , Height[{1}] , FrameNum[{2}]"

, frameOut.Image.Width, frameOut.Image.Height, frameOut.FrameNum);

// ch:如果图像是HB格式，需要先解码 | en:If the image is HB format, should to be decoded first IFrameOut frameForSave = frameOut; if (frameOut.Image.PixelType.ToString().Contains("HB")) {

result = device.ImageDecoder.HBDecode(frameOut, out frameForSave); if (result != MvError.MV_OK) {

Console.WriteLine("HB Decode failed:{0:x8}", result); return; }

}

// ch:保存图像 | en:Save image string fileName = string.Format("Image_w{0}_h{1}_p{2}", frameForSave.Image.Width, frameForSave.Image.Height, frameForSave.Image.PixelType); switch(imageFormatType) {

case 0: {

// ch:保存raw数据 | en:Save raw data fileName += ".raw"; using (FileStream fs = new FileStream(fileName, FileMode.Create)) {

// ch:图像超过int.MaxValue时, 分段保存 | en:The save image in segments When byte array is large than int.MaxValue UInt64 intMaxValue = (UInt64)int.MaxValue; if (frameForSave.Image.ImageSize > intMaxValue) {

int blockLen = 1024 * 1024; byte[] newData = new byte[blockLen];

UInt64 remain = frameForSave.Image.ImageSize;

IntPtr ptrSourceTemp = frameForSave.Image.PixelDataPtr; for (UInt64 i = 0; i < remain; i++) {

int writeLen = (int)(remain > (UInt64)blockLen ? (UInt64)blockLen : remain); Marshal.Copy(ptrSourceTemp, newData, 0, writeLen); fs.Write(newData, 0, writeLen);

remain -= (UInt64)writeLen; ptrSourceTemp = new IntPtr(ptrSourceTemp.ToInt64() + writeLen); }

}

else {

fs.Write(frameForSave.Image.PixelData, 0, (int)frameForSave.Image.ImageSize); }

}

Console.WriteLine("Save image success! " + fileName); }

break; case 1: case 2: case 3: case 4: {

ImageFormatInfo imageFormatInfo = new ImageFormatInfo(); imageFormatInfo.FormatType = (ImageFormatType)imageFormatType;

// ch:JPEG格式需要配置图像质量 | en:Set JpegQuality for JPEG file if (imageFormatInfo.FormatType == ImageFormatType.Jpeg) {

imageFormatInfo.JpegQuality = 80; }

// ch:图像保存的文件名 | en:Save image to file fileName += "." + imageFormatInfo.FormatType.ToString();

// ch:保存图像 | en:Save image to file result = device.ImageSaver.SaveImageToFile(fileName, frameForSave.Image, imageFormatInfo, CFAMethod.Equilibrated); if (result != MvError.MV_OK) {

Console.WriteLine("SaveImageToFile failed:{0:x8}", result); return; }

Console.WriteLine("Save image success! " + fileName); }

break; default: Console.WriteLine("Input file type error"); return; }

//ch: 图像使用完及时释放，防止内存快速上涨导致频繁GC | en：Release image promptly to prevent rapid memory increase leading to frequent GC.

if (frameForSave != frameOut) {

frameForSave.Image.Dispose(); }

}

//ch: 释放图像缓存 | en: Release image buffer device.StreamGrabber.FreeImageBuffer(frameOut);

// ch:停止抓图 | en:Stop grabbing result = device.StreamGrabber.StopGrabbing(); if (MvError.MV_OK != result) {

Console.WriteLine("Stop grabbing failed:{0:x8}", result); return; }

// ch:关闭设备 | en:Close device result = device.Close(); if (MvError.MV_OK != result) {

Console.WriteLine("Close device failed:{0:x8}", result); return; }

// ch:销毁设备 | en:Destroy device device.Dispose();

device = null;

}

catch (Exception e) {

Console.WriteLine(e.Message); }

finally {

if (device != null) {

// ch:销毁设备 | en:Destroy device device.Dispose();

device = null; }

}

}

static void Main(string[] args) {

//ch: 初始化SDK | en: Initialize SDK

SDKSystem.Initialize();

Image_Save program = new Image_Save(); program.Run();

Console.WriteLine("Press enter to exit"); Console.ReadKey();

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize(); }

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

调节图像对比度（Image_Contrast.cs）

该示例演示如何在您的程序实现图像对比度调节功能。 using MvCameraControl; using System; using System.Collections.Generic;

namespace Image_Contrast {

class Image_Contrast {

static void Main(string[] args) {

DeviceTLayerType enumTLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLGigEDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLXoFDevice;

int result = MvError.MV_OK; IDevice device = null; List<IDeviceInfo> deviceInfos; int packetSize;

try {

//ch: 初始化SDK | en: Initialize SDK

SDKSystem.Initialize();

result = DeviceEnumerator.EnumDevices(enumTLayerType, out deviceInfos); if (result != MvError.MV_OK) {

Console.WriteLine("Enumerate device failed, result: {0:x8}", result); return; }

if (deviceInfos.Count == 0) {

Console.WriteLine("No device"); return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in deviceInfos) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine(); devIndex++;

}

// ch:需要连接的相机索引 || en:Select a device that want to connect Console.Write("Please input index(0-{0:d}):", deviceInfos.Count - 1);

devIndex = Convert.ToInt32(Console.ReadLine());

if (devIndex > deviceInfos.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

//ch: 创建设备 | en: Create device device = DeviceFactory.CreateDevice(deviceInfos[devIndex]); if (device == null) {

Console.WriteLine("Create device failed!"); return; }

//ch: 打开设备 | en:Open device result = device.Open(); if (result != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", result); return; }

//ch: 判断是否为gige设备 | en: Determine whether it is a GigE device if (device is IGigEDevice) {

//ch: 转换为gigE设备 | en: Convert to Gige device IGigEDevice gigEDevice = (IGigEDevice)device;

// ch:探测网络最佳包大小(只对GigE相机有效) // en:Detection network optimal package size(It only works for the GigE camera) result = gigEDevice.GetOptimalPacketSize(out packetSize); if (MvError.MV_OK != result) {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", result); }

else {

result = gigEDevice.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (MvError.MV_OK != result) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", result); }

}

}

// ch:设置触发模式为off || en:set trigger mode as off result = device.Parameters.SetEnumValue("TriggerMode", 0); if (MvError.MV_OK != result) {

Console.WriteLine("Set TriggerMode failed:{0:x8}", result); return; }

// ch:开启抓图 || en: start grab image result = device.StreamGrabber.StartGrabbing(); if (MvError.MV_OK != result) {

Console.WriteLine("Start grabbing failed:{0:x8}", result); return; }

IFrameOut frameOut; // ch:获取一帧图像 | en:Get one image result = device.StreamGrabber.GetImageBuffer(1000, out frameOut); if (MvError.MV_OK == result) {

Console.WriteLine("Get Image Buffer: Width[{0}] , Height[{1}] , FrameNum[{2}]"

, frameOut.Image.Width, frameOut.Image.Height, frameOut.FrameNum);

IImage inputImage = frameOut.Image; IImage outImage;

// ch:对比度值，[1, 10000] | en:Image Contrast Factor[1, 10000]

uint contrastFactor = 300;

// ch:对比度调节 | en:Image Contrast Process result = device.ImageProcess.ImageContrast(inputImage, out outImage, contrastFactor); if (result != MvError.MV_OK) {

Console.WriteLine("Image Contrast failed:{0:x8}", result); return; }

Console.WriteLine("Image Contrast success!");

ImageFormatInfo info = new ImageFormatInfo(); info.FormatType = ImageFormatType.Bmp;

string inputFilePath = string.Format("InputImage.{0}", info.FormatType); string outputFilePath = string.Format("OutputImage_ContrastFactor{0}.{1}", contrastFactor, info.FormatType);

//ch: 保持图像到文件 | en: Save image to file device.ImageSaver.SaveImageToFile(inputFilePath, frameOut.Image, info, CFAMethod.Equilibrated); Console.WriteLine("Save inputImage: {0}!", inputFilePath);

device.ImageSaver.SaveImageToFile(outputFilePath, outImage, info, CFAMethod.Equilibrated); Console.WriteLine("Save OutputImage: {0}!", outputFilePath);

//ch: 图像使用完及时释放，防止内存快速上涨导致频繁GC |en：Release image promptly to prevent rapid memory increase leading to frequent GC.

outImage.Dispose();

//ch: 释放图像缓存 | en: Release image buffer device.StreamGrabber.FreeImageBuffer(frameOut); }

else {

Console.WriteLine("Get Image failed:{0:x8}", result); }

// ch:停止抓图 | en:Stop grabbing result = device.StreamGrabber.StopGrabbing(); if (MvError.MV_OK != result) {

Console.WriteLine("Stop grabbing failed:{0:x8}", result); return; }

// ch:关闭设备 | en:Close device result = device.Close(); if (MvError.MV_OK != result) {

Console.WriteLine("Close device failed:{0:x8}", result); return; }

// ch:销毁设备 | en:Destroy device device.Dispose();

device = null;

}

catch (Exception e) {

Console.WriteLine(e.Message); }

finally {

if (device != null) {

// ch:销毁设备 | en:Destroy device device.Dispose();

device = null; }

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize();

Console.WriteLine("Press enter to exit"); Console.ReadKey(); }

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

转换图像格式（Image_ConvertPixelType.cs）

该示例演示如何在您的程序实现图像格式转换功能。 using MvCameraControl; using System; using System.Collections.Generic; using System.IO;

namespace Image_ConvertPixelType {

class Image_ConvertPixelType {

static bool IsMonoPixelFormat(MvGvspPixelType enType) {

switch (enType) {

case MvGvspPixelType.PixelType_Gvsp_Mono10: case MvGvspPixelType.PixelType_Gvsp_Mono10_Packed: case MvGvspPixelType.PixelType_Gvsp_Mono12: case MvGvspPixelType.PixelType_Gvsp_Mono12_Packed: return true; default: return false; }

}

static bool IsColorPixelFormat(MvGvspPixelType enType) {

switch (enType) {

case MvGvspPixelType.PixelType_Gvsp_BGR8_Packed: case MvGvspPixelType.PixelType_Gvsp_YUV422_Packed: case MvGvspPixelType.PixelType_Gvsp_YUV422_YUYV_Packed: case MvGvspPixelType.PixelType_Gvsp_BayerGR8: case MvGvspPixelType.PixelType_Gvsp_BayerRG8: case MvGvspPixelType.PixelType_Gvsp_BayerGB8: case MvGvspPixelType.PixelType_Gvsp_BayerBG8: case MvGvspPixelType.PixelType_Gvsp_BayerGB10: case MvGvspPixelType.PixelType_Gvsp_BayerGB10_Packed: case MvGvspPixelType.PixelType_Gvsp_BayerBG10: case MvGvspPixelType.PixelType_Gvsp_BayerBG10_Packed: case MvGvspPixelType.PixelType_Gvsp_BayerRG10: case MvGvspPixelType.PixelType_Gvsp_BayerRG10_Packed: case MvGvspPixelType.PixelType_Gvsp_BayerGR10: case MvGvspPixelType.PixelType_Gvsp_BayerGR10_Packed: case MvGvspPixelType.PixelType_Gvsp_BayerGB12: case MvGvspPixelType.PixelType_Gvsp_BayerGB12_Packed: case MvGvspPixelType.PixelType_Gvsp_BayerBG12: case MvGvspPixelType.PixelType_Gvsp_BayerBG12_Packed: case MvGvspPixelType.PixelType_Gvsp_BayerRG12: case MvGvspPixelType.PixelType_Gvsp_BayerRG12_Packed: case MvGvspPixelType.PixelType_Gvsp_BayerGR12: case MvGvspPixelType.PixelType_Gvsp_BayerGR12_Packed: return true; default: return false; }

}

static void Main(string[] args) {

DeviceTLayerType enumTLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLGigEDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLXoFDevice;

int result = MvError.MV_OK; IDevice device = null; List<IDeviceInfo> deviceInfos; int packetSize;

try {

//ch: 初始化SDK | en: Initialize SDK

SDKSystem.Initialize();

result = DeviceEnumerator.EnumDevices(enumTLayerType, out deviceInfos); if (result != MvError.MV_OK) {

Console.WriteLine("Enumerate device failed, result: {0:x8}", result); return; }

if (deviceInfos.Count == 0) {

Console.WriteLine("No device"); return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in deviceInfos) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine(); devIndex++;

}

// ch:需要连接的相机索引 || en:Select a device that want to connect Console.Write("Please input index(0-{0:d}):", deviceInfos.Count - 1);

devIndex = Convert.ToInt32(Console.ReadLine());

if (devIndex > deviceInfos.Count - 1 || devIndex < 0) {

Console.WriteLine("Input Error!\n"); return; }

//ch: 创建设备 | en: Create device device = DeviceFactory.CreateDevice(deviceInfos[devIndex]); if (device == null) {

Console.WriteLine("Create device failed!"); return; }

//ch: 打开设备 | en:Open device result = device.Open(); if (result != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", result); return; }

//ch: 判断是否为gige设备 | en: Determine whether it is a GigE device if (device is IGigEDevice) {

//ch: 转换为gigE设备 | en: Convert to Gige device IGigEDevice gigEDevice = (IGigEDevice)device;

// ch:探测网络最佳包大小(只对GigE相机有效) // en:Detection network optimal package size(It only works for the GigE camera) result = gigEDevice.GetOptimalPacketSize(out packetSize); if (MvError.MV_OK != result) {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", result); }

else {

result = gigEDevice.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (MvError.MV_OK != result) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", result); }

}

}

// ch:设置触发模式为off || en:set trigger mode as off result = device.Parameters.SetEnumValue("TriggerMode", 0); if (MvError.MV_OK != result) {

Console.WriteLine("Set TriggerMode failed:{0:x8}", result); return; }

// ch:开启抓图 || en: start grab image result = device.StreamGrabber.StartGrabbing(); if (MvError.MV_OK != result) {

Console.WriteLine("Start grabbing failed:{0:x8}", result); return; }

IFrameOut frameOut; // ch:获取一帧图像 | en:Get one image result = device.StreamGrabber.GetImageBuffer(1000, out frameOut); if (MvError.MV_OK == result) {

Console.WriteLine("Get Image Buffer: Width[{0}] , Height[{1}] , FrameNum[{2}]"

, frameOut.Image.Width, frameOut.Image.Height, frameOut.FrameNum);

IImage inputImage = frameOut.Image; IImage outImage; MvGvspPixelType dstPixelType = MvGvspPixelType.PixelType_Gvsp_Undefined;

if (IsColorPixelFormat(frameOut.Image.PixelType)) {

dstPixelType = MvGvspPixelType.PixelType_Gvsp_RGB8_Packed; }

else if (IsMonoPixelFormat(frameOut.Image.PixelType)) {

dstPixelType = MvGvspPixelType.PixelType_Gvsp_Mono8; }

else {

Console.WriteLine("Don't need to convert!"); }

if (dstPixelType != MvGvspPixelType.PixelType_Gvsp_Undefined) {

// ch:像素格式转换 | en:Pixel type convert result = device.PixelTypeConverter.ConvertPixelType(inputImage, out outImage, dstPixelType); if (result != MvError.MV_OK) {

Console.WriteLine("Image Convert failed:{0:x8}", result); return; }

Console.WriteLine("Image Convert success!");

string inputFilePath = string.Format("InputImage_w{0}_h{1}_{2}.raw", inputImage.Width, inputImage.Height, inputImage.PixelType); string outputFilePath = string.Format("OutputImage_w{0}_h{1}_{2}.raw", outImage.Width, outImage.Height, outImage.PixelType);

//ch: 保持图像到文件 | en: Save image to file using (FileStream fs = new FileStream(inputFilePath, FileMode.Create)) {

fs.Write(inputImage.PixelData, 0, inputImage.PixelData.Length); }

Console.WriteLine("Save inputImage: {0}!", inputFilePath);

using (FileStream fs = new FileStream(outputFilePath, FileMode.Create)) {

fs.Write(outImage.PixelData, 0, outImage.PixelData.Length); }

Console.WriteLine("Save OutputImage: {0}!", outputFilePath);

//ch: 图像使用完及时释放，防止内存快速上涨导致频繁GC |en：Release image promptly to prevent rapid memory increase leading to frequent GC.

outImage.Dispose(); }

//ch: 释放图像缓存 | en: Release image buffer device.StreamGrabber.FreeImageBuffer(frameOut); }

else {

Console.WriteLine("Get Image failed:{0:x8}", result); }

// ch:停止抓图 | en:Stop grabbing result = device.StreamGrabber.StopGrabbing(); if (MvError.MV_OK != result) {

Console.WriteLine("Stop grabbing failed:{0:x8}", result); return; }

// ch:关闭设备 | en:Close device result = device.Close(); if (MvError.MV_OK != result) {

Console.WriteLine("Close device failed:{0:x8}", result); return; }

// ch:销毁设备 | en:Destroy device device.Dispose();

}

catch (Exception e) {

Console.WriteLine(e.Message); }

finally {

if (MvError.MV_OK != result) {

// ch:销毁设备 | en:Destroy device device.Dispose();

}

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize();

Console.WriteLine("Press enter to exit"); Console.ReadKey(); }

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

无损解码（Image_HBDecode.cs）

该示例演示如何在您的程序实现无损解码功能。 using MvCameraControl; using System; using System.Collections.Generic; using System.IO;

namespace Image_HBDecode {

class Image_HBDecode {

static void Main(string[] args) {

DeviceTLayerType enumTLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLGigEDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLXoFDevice;

int result = MvError.MV_OK; IDevice device = null; List<IDeviceInfo> deviceInfos; int packetSize;

try {

//ch: 初始化SDK | en: Initialize SDK

SDKSystem.Initialize();

result = DeviceEnumerator.EnumDevices(enumTLayerType, out deviceInfos); if (result != MvError.MV_OK) {

Console.Write("Enumerate device failed, result: {0:x8}", result); return; }

if (deviceInfos.Count == 0) {

Console.WriteLine("No device"); return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in deviceInfos) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine(); devIndex++;

}

// ch:需要连接的相机索引 || en:Select a device that want to connect Console.Write("Please input index(0-{0:d}):", deviceInfos.Count - 1);

devIndex = Convert.ToInt32(Console.ReadLine());

if (devIndex > deviceInfos.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

//ch: 创建设备 | en: Create device device = DeviceFactory.CreateDevice(deviceInfos[devIndex]); if (device == null) {

Console.WriteLine("Create device failed!"); return; }

//ch: 打开设备 | en:Open device result = device.Open(); if (result != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", result); return; }

//ch: 判断是否为gige设备 | en: Determine whether it is a GigE device if (device is IGigEDevice) {

//ch: 转换为gigE设备 | en: Convert to Gige device IGigEDevice gigEDevice = (IGigEDevice)device;

// ch:探测网络最佳包大小(只对GigE相机有效) // en:Detection network optimal package size(It only works for the GigE camera) result = gigEDevice.GetOptimalPacketSize(out packetSize); if (MvError.MV_OK != result) {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", result); }

else {

result = gigEDevice.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (MvError.MV_OK != result) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", result); }

}

}

// ch:设置触发模式为off || en:set trigger mode as off result = device.Parameters.SetEnumValue("TriggerMode", 0); if (MvError.MV_OK != result) {

Console.WriteLine("Set TriggerMode failed:{0:x8}", result); return; }

// ch:开启抓图 || en: start grab image result = device.StreamGrabber.StartGrabbing(); if (MvError.MV_OK != result) {

Console.WriteLine("Start grabbing failed:{0:x8}", result); return; }

IFrameOut frameOut; // ch:获取一帧图像 | en:Get one image result = device.StreamGrabber.GetImageBuffer(1000, out frameOut); if (MvError.MV_OK == result) {

Console.WriteLine("Get Image Buffer: Width[{0}] , Height[{1}] , FrameNum[{2}]"

, frameOut.Image.Width, frameOut.Image.Height, frameOut.FrameNum);

IFrameOut frameDecode;

// ch:图像解码 | en:Image Decode Process result = device.ImageDecoder.HBDecode(frameOut, out frameDecode); if (result != MvError.MV_OK) {

Console.WriteLine("Image HBDecode failed:{0:x8}", result); return; }

Console.WriteLine("Image HBDecode success!");

//ch: 保持图像到文件 | en: Save image to file string outputFilePath = string.Format("HBDecode_w{0}_h{1}_{2}.bmp", frameDecode.Image.Width, frameDecode.Image.Height, frameDecode.Image.PixelType); ImageFormatInfo imageFormatInfo = new ImageFormatInfo(); imageFormatInfo.FormatType = ImageFormatType.Bmp; result = device.ImageSaver.SaveImageToFile(outputFilePath, frameDecode.Image, imageFormatInfo, CFAMethod.Equilibrated); if (result != MvError.MV_OK) {

Console.WriteLine("Image Save failed:{0:x8}", result); return; }

Console.WriteLine("Save image success, {0}!", outputFilePath);

//ch: 图像使用完及时释放，防止内存快速上涨导致频繁GC | en：Release image promptly to prevent rapid memory increase leading to frequent GC.

frameDecode.Dispose();

//ch: 释放图像缓存 | en: Release image buffer device.StreamGrabber.FreeImageBuffer(frameOut); }

else {

Console.WriteLine("Get Image failed:{0:x8}", result); }

// ch:停止抓图 | en:Stop grabbing result = device.StreamGrabber.StopGrabbing(); if (MvError.MV_OK != result) {

Console.WriteLine("Stop grabbing failed:{0:x8}", result); return; }

// ch:关闭设备 | en:Close device result = device.Close(); if (MvError.MV_OK != result) {

Console.WriteLine("Close device failed:{0:x8}", result); return; }

// ch:销毁设备 | en:Destroy device device.Dispose();

device = null; }

catch (Exception e) {

Console.WriteLine(e.Message); }

finally {

if (device != null) {

// ch:销毁设备 | en:Destroy device device.Dispose();

device = null; }

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize();

Console.WriteLine("Press enter to exit"); Console.ReadKey(); }

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

录像（Image_Recording.cs）

该示例演示如何在您的程序实现录像功能。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using MvCameraControl; using System.Threading;

namespace Grab_GetImageBuffer {

class Program {

const DeviceTLayerType devLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLXoFDevice;

static volatile bool _grabThreadExit = false; static void FrameGrabThread(object obj) {

int ret = MvError.MV_OK;

IDevice device = obj as IDevice; IVideoRecorder recorder = device.VideoRecorder; IStreamGrabber streamGrabber = device.StreamGrabber;

while (!_grabThreadExit) {

IFrameOut frame;

//ch：获取一帧图像 | en: Get one frame ret = streamGrabber.GetImageBuffer(1000, out frame); if (ret != MvError.MV_OK) {

Console.WriteLine("Get Image failed:{0:x8}", ret); continue; }

Console.WriteLine("Get one frame: Width[{0}] , Height[{1}] , FrameNum[{2}]", frame.Image.Width, frame.Image.Height, frame.FrameNum);

//ch：图像添加到录像文件 | en: Record the frame ret = recorder.InputOneFrame(frame.Image); if (ret != MvError.MV_OK) {

Console.WriteLine("Input one frame failed:{0:x8}", ret); }

//ch: 释放图像缓存 | en: Release the image buffer streamGrabber.FreeImageBuffer(frame); }

}

static void Main(string[] args) {

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize();

IDevice device = null;

try {

List<IDeviceInfo> devInfoList;

// ch:枚举设备 | en:Enum device int ret = DeviceEnumerator.EnumDevices(devLayerType, out devInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("Enum device failed:{0:x8}", ret); return; }

Console.WriteLine("Enum device count : {0}", devInfoList.Count);

if (0 == devInfoList.Count) {

return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in devInfoList) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine(); devIndex++;

}

Console.Write("Please input index(0-{0:d}):", devInfoList.Count - 1);

devIndex = Convert.ToInt32(Console.ReadLine());

if (devIndex > devInfoList.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

// ch:创建设备 | en:Create device device = DeviceFactory.CreateDevice(devInfoList[devIndex]);

ret = device.Open(); if (ret != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", ret); return; }

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) if (device is IGigEDevice) {

int packetSize; ret = (device as IGigEDevice).GetOptimalPacketSize(out packetSize); if (packetSize > 0) {

ret = device.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (ret != MvError.MV_OK) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", ret); }

else {

Console.WriteLine("Set PacketSize to {0}", packetSize); }

}

else {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", ret); }

}

// ch:设置触发模式为off | en:set trigger mode as off ret = device.Parameters.SetEnumValue("TriggerMode", 0); if (ret != MvError.MV_OK) {

Console.WriteLine("Set TriggerMode failed:{0:x8}", ret); return; }

//ch: 设置合适的缓存节点数量 | en: Setting the appropriate number of image nodes device.StreamGrabber.SetImageNodeNum(5);

// ch:开启抓图 | en: start grab image ret = device.StreamGrabber.StartGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Start grabbing failed:{0:x8}", ret); return; }

// ch:获取录像所需的参数 | en: Get record parameters IIntValue widthValue; IIntValue heightValue; IEnumValue pixelTypeValue; IFloatValue frameRateValue; device.Parameters.GetIntValue("Width", out widthValue); device.Parameters.GetIntValue("Height", out heightValue); device.Parameters.GetEnumValue("PixelFormat", out pixelTypeValue); device.Parameters.GetFloatValue("ResultingFrameRate", out frameRateValue);

// ch:开启录像 | en: start record RecordParam recordParam = new RecordParam(); recordParam.Width = (uint)widthValue.CurValue; recordParam.Height = (uint)heightValue.CurValue; recordParam.PixelType = (MvGvspPixelType)pixelTypeValue.CurEnumEntry.Value;

// ch:帧率(大于1/16)fps | en:Frame Rate (>1/16)fps recordParam.FrameRate = frameRateValue.CurValue; // ch:码率kbps(128kbps-16Mbps) | en:Bitrate kbps(128kbps-16Mbps) recordParam.BitRate = 1000; // ch:录像格式(仅支持AVI) | en:Record Format(AVI is only supported) recordParam.FormatType = VideoFormatType.AVI;

ret = device.VideoRecorder.StartRecord("./Recording.avi", recordParam); if (ret != MvError.MV_OK) {

Console.WriteLine("Start record failed:{0:x8}", ret); return; }

// ch:开启抓图线程 | en: Start the grabbing thread Thread GrabThread = new Thread(FrameGrabThread); GrabThread.Start(device);

Console.WriteLine("Press enter to exit"); Console.ReadLine();

//ch: 通知线程退出 | en: Notify the grab thread to exit _grabThreadExit = true; GrabThread.Join();

// ch:停止录像 | en:Stop record ret = device.VideoRecorder.StopRecord(); if (ret != MvError.MV_OK) {

Console.WriteLine("Stop record failed:{0:x8}", ret); }

// ch:停止抓图 | en:Stop grabbing ret = device.StreamGrabber.StopGrabbing(); if (ret != MvError.MV_OK) {

Console.WriteLine("Stop grabbing failed:{0:x8}", ret); return; }

// ch:关闭设备 | en:Close device ret = device.Close(); if (ret != MvError.MV_OK) {

Console.WriteLine("Close device failed:{0:x8}", ret); return; }

// ch:销毁设备 | en:Destroy device device.Dispose();

}

catch (Exception e) {

Console.Write("Exception: " + e.Message); }

finally {

// ch:销毁设备 | en:Destroy device if (device != null) {

device.Dispose();

device = null; }

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize();

Console.WriteLine("Press enter to exit"); Console.ReadKey(); }

}

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

获取相机配置文件（ParameterCamera_FileAccess.cs）

该示例演示如何在您的程序实现“相机配置文件获取”功能。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using MvCameraControl; using System.Threading;

namespace ParameterCamera_FileAccess {

class ParameterCamera_FileAccess {

private const DeviceTLayerType devLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLXoFDevice;

public void Run() {

IDevice device = null;

try {

List<IDeviceInfo> devInfoList;

// ch:枚举设备 | en:Enum device int ret = DeviceEnumerator.EnumDevices(devLayerType, out devInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("Enum device failed:{0:x8}", ret); return; }

Console.WriteLine("Enum device count : {0}", devInfoList.Count);

if (0 == devInfoList.Count) {

return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in devInfoList) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine(); devIndex++;

}

Console.Write("Please input index(0-{0:d}):", devInfoList.Count - 1);

devIndex = Convert.ToInt32(Console.ReadLine());

if (devIndex > devInfoList.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

// ch:创建设备 | en:Create device device = DeviceFactory.CreateDevice(devInfoList[devIndex]);

ret = device.Open(); if (ret != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", ret); return; }

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) if (device is IGigEDevice) {

int packetSize; ret = (device as IGigEDevice).GetOptimalPacketSize(out packetSize); if (packetSize > 0) {

ret = device.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (ret != MvError.MV_OK) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", ret); }

else {

Console.WriteLine("Set PacketSize to {0}", packetSize); }

}

else {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", ret); }

}

//Ch: 读设备文件 | Read device file Thread readThread = new Thread(() => {

int readRet = device.Parameters.FileAccessRead("UserSet1", "UserSet1.bin"); if (readRet != MvError.MV_OK) {

Console.WriteLine("FileAccessRead failed {0:x8}", readRet); }

else {

Console.WriteLine("FileAccessRead success"); }

});

//ch:获取文件存取进度 |en:Get progress of file access Thread readProgressThread = new Thread(() => {

while (true) {

Int64 completed; Int64 total;

int progressRet = device.Parameters.GetFileAccessProgress(out completed, out total); if (progressRet != MvError.MV_OK) {

Console.WriteLine("GetFileAccessProgress failed {0:x8}", progressRet); break; }

else {

Console.WriteLine("GetFileAccessProgress: Completed = {0}, Totoal = {1}", completed, total);

if (completed == total && total != 0) {

break; }

}

Thread.Sleep(50); }

});

readThread.Start(); readProgressThread.Start(); readThread.Join(); readProgressThread.Join();

Console.WriteLine("");

//Ch: 写设备文件 | Write file to device Thread writeThread = new Thread(() => {

int readRet = device.Parameters.FileAccessWrite("UserSet1", "UserSet1.bin"); if (readRet != MvError.MV_OK) {

Console.WriteLine("FileAccessWrite failed {0:x8}", readRet); }

else {

Console.WriteLine("FileAccessWrite success"); }

});

//ch:获取文件存取进度 |en:Get progress of file access Thread writeProgressThread = new Thread(() => {

while (true) {

Int64 completed; Int64 total;

int progressRet = device.Parameters.GetFileAccessProgress(out completed, out total); if (progressRet != MvError.MV_OK) {

Console.WriteLine("GetFileAccessProgress failed {0:x8}", progressRet); break; }

else {

Console.WriteLine("GetFileAccessProgress: Completed = {0}, Totoal = {1}", completed, total);

if (completed == total && total != 0) {

break; }

}

Thread.Sleep(50); }

});

writeThread.Start(); writeProgressThread.Start(); writeThread.Join(); writeProgressThread.Join();

// ch:关闭设备 | en:Close device ret = device.Close(); if (ret != MvError.MV_OK) {

Console.WriteLine("Close device failed:{0:x8}", ret); return; }

// ch:销毁设备 | en:Destroy device device.Dispose(); }

catch (Exception e) {

Console.Write("Exception: " + e.Message); }

finally {

// ch:销毁设备 | en:Destroy device if (device != null) {

device.Dispose(); device = null; }

}

}

static void Main(string[] args) {

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize();

ParameterCamera_FileAccess program = new ParameterCamera_FileAccess(); program.Run();

Console.WriteLine("Press enter to exit"); Console.ReadKey();

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize(); }

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

导入/导出相机配置文件（ParameterCamera_LoadAndSave.cs）

该示例演示如何在您的程序实现“相机配置文件导入/导出”功能。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using MvCameraControl;

namespace ParameterCamera_LoadAndSave {

class ParameterCamera_LoadAndSave {

private const DeviceTLayerType devLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLXoFDevice;

public void Run() {

IDevice device = null;

try {

List<IDeviceInfo> devInfoList;

// ch:枚举设备 | en:Enum device int ret = DeviceEnumerator.EnumDevices(devLayerType, out devInfoList); if (ret != MvError.MV_OK) {

Console.WriteLine("Enum device failed:{0:x8}", ret); return; }

Console.WriteLine("Enum device count : {0}", devInfoList.Count);

if (0 == devInfoList.Count) {

return; }

// ch:打印设备信息 en:Print device info int devIndex = 0; foreach (var devInfo in devInfoList) {

Console.WriteLine("[Device {0}]:", devIndex); if (devInfo.TLayerType == DeviceTLayerType.MvGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvVirGigEDevice || devInfo.TLayerType == DeviceTLayerType.MvGenTLGigEDevice) {

IGigEDeviceInfo gigeDevInfo = devInfo as IGigEDeviceInfo; uint nIp1 = ((gigeDevInfo.CurrentIp & 0xff000000) >> 24); uint nIp2 = ((gigeDevInfo.CurrentIp & 0x00ff0000) >> 16); uint nIp3 = ((gigeDevInfo.CurrentIp & 0x0000ff00) >> 8); uint nIp4 = (gigeDevInfo.CurrentIp & 0x000000ff); Console.WriteLine("DevIP: {0}.{1}.{2}.{3}", nIp1, nIp2, nIp3, nIp4); }

Console.WriteLine("ModelName:" + devInfo.ModelName); Console.WriteLine("SerialNumber:" + devInfo.SerialNumber); Console.WriteLine(); devIndex++;

}

Console.Write("Please input index(0-{0:d}):", devInfoList.Count - 1);

devIndex = Convert.ToInt32(Console.ReadLine());

if (devIndex > devInfoList.Count - 1 || devIndex < 0) {

Console.Write("Input Error!\n"); return; }

// ch:创建设备 | en:Create device device = DeviceFactory.CreateDevice(devInfoList[devIndex]);

ret = device.Open(); if (ret != MvError.MV_OK) {

Console.WriteLine("Open device failed:{0:x8}", ret); return; }

// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera) if (device is IGigEDevice) {

int packetSize; ret = (device as IGigEDevice).GetOptimalPacketSize(out packetSize); if (packetSize > 0) {

ret = device.Parameters.SetIntValue("GevSCPSPacketSize", packetSize); if (ret != MvError.MV_OK) {

Console.WriteLine("Warning: Set Packet Size failed {0:x8}", ret); }

else {

Console.WriteLine("Set PacketSize to {0}", packetSize); }

}

else {

Console.WriteLine("Warning: Get Packet Size failed {0:x8}", ret); }

}

Console.WriteLine("Start export the camera properties to the file"); Console.WriteLine("Wait......"); // ch:将相机属性导出到文件中

// en:Export the camera properties to the file ret = device.Parameters.FeatureSave("CameraFile"); if (ret != MvError.MV_OK) {

Console.WriteLine("FeatureSave failed!"); return; }

Console.WriteLine("Finish export the camera properties to the file\n");

Console.WriteLine("Start import the camera properties from the file"); Console.WriteLine("Wait......"); // ch:从文件中导入相机属性

// en:Import the camera properties from the file ret = device.Parameters.FeatureLoad("CameraFile"); if (ret != MvError.MV_OK) {

Console.WriteLine("FeatureLoad failed!"); return; }

Console.WriteLine("Finish import the camera properties from the file");

// ch:关闭设备 | en:Close device ret = device.Close(); if (ret != MvError.MV_OK) {

Console.WriteLine("Close device failed:{0:x8}", ret); return; }

// ch:销毁设备 | en:Destroy device device.Dispose(); }

catch (Exception e) {

Console.Write("Exception: " + e.Message); }

finally {

// ch:销毁设备 | en:Destroy device if (device != null) {

device.Dispose(); device = null; }

}

}

static void Main(string[] args) {

// ch: 初始化 SDK | en: Initialize SDK

SDKSystem.Initialize();

ParameterCamera_LoadAndSave program = new ParameterCamera_LoadAndSave(); program.Run();

Console.WriteLine("Press enter to exit"); Console.ReadKey();

// ch: 反初始化SDK | en: Finalize SDK

SDKSystem.Finalize(); }

}

}

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

法律声明

在法律允许的最大范围内，本文档是“按照现状”提供，可能存在瑕疵或错误。本公司不对本文档提供任何形式的明示或默示保证，包括但不限于适销性、质量满意度、适合特定目的、不侵犯第三方权利等保证；亦不对使用或是分发本文档导致的任何特殊、附带、偶然或间接的损害进行赔偿，包括但不限于商业利润损失、系统故障、数据或文档丢失产生的损失。

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

SDKSystem 成员列表

成员的完整列表，这些成员属于 SDKSystem,包括所有继承而来的类成员

Finalize() SDKSystem static

GetSDKVersion() SDKSystem static

Initialize() SDKSystem static

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

NetTransInfo 成员列表

成员的完整列表，这些成员属于 NetTransInfo,包括所有继承而来的类成员

LostFrameCount NetTransInfo

LostPacketCount NetTransInfo

NetRecvFrameCount NetTransInfo

ReceiveDataSize NetTransInfo

RequestResendPacketCount NetTransInfo

ResendPacketCount NetTransInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

USBTransInfo 成员列表

成员的完整列表，这些成员属于 USBTransInfo,包括所有继承而来的类成员

ErrorFrameCount USBTransInfo

ReceiveDataSize USBTransInfo

ReceivedFrameCount USBTransInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

DeviceExceptionArgs 成员列表

成员的完整列表，这些成员属于 DeviceExceptionArgs,包括所有继承而来的类成员

MsgType DeviceExceptionArgs

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IDevice 成员列表

成员的完整列表，这些成员属于 IDevice,包括所有继承而来的类成员

Close() IDevice

DeviceExceptionEvent IDevice

DeviceInfo IDevice

EventGrabber IDevice

EventNotificationOff(String eventName) IDevice

EventNotificationOn(String eventName) IDevice

GetUpgradeProcess(out UInt32 process) IDevice

ImageDecoder IDevice

ImageProcess IDevice

ImageRender IDevice

ImageSaver IDevice

IsConnected IDevice

LocalUpgrade(String filePath) IDevice

Open() IDevice

Open(DeviceAccessMode AccessMode, UInt32 switchoverKey) IDevice

Parameters IDevice

PixelTypeConverter IDevice

StreamGrabber IDevice

VideoRecorder IDevice

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IGigEDevice 成员列表

成员的完整列表，这些成员属于 IGigEDevice,包括所有继承而来的类成员

Close() IDevice

DeviceExceptionEvent IDevice

DeviceInfo IDevice

EventGrabber IDevice

EventNotificationOff(String eventName) IDevice

EventNotificationOn(String eventName) IDevice

ForceIp(UInt32 ip, UInt32 subnetMask, UInt32 defaultGateway) IGigEDevice

GetGvcpTimeout(out UInt32 timeoutInMS) IGigEDevice

GetGvspTimeout(out UInt32 timeoutInMS) IGigEDevice

GetNetTransInfo(out NetTransInfo info) IGigEDevice

GetOptimalPacketSize(out Int32 optimalPacketSize) IGigEDevice

GetResendMaxRetryTimes(out UInt32 retryTimes) IGigEDevice

GetResendTimeInterval(out UInt32 timeInMS) IGigEDevice

GetRetryGvcpTimes(out UInt32 retryGvcpTimes) IGigEDevice

GetUpgradeProcess(out UInt32 process) IDevice

ImageDecoder IDevice

ImageProcess IDevice

ImageRender IDevice

ImageSaver IDevice

IsConnected IDevice

LocalUpgrade(String filePath) IDevice

Open() IDevice

Open(DeviceAccessMode AccessMode, UInt32 switchoverKey) IDevice

Parameters IDevice

PixelTypeConverter IDevice

SetGvcpTimeout(UInt32 timeoutInMS) IGigEDevice

SetGvspTimeout(UInt32 timeoutInMS) IGigEDevice

SetIpConfig(IpConfigType type) IGigEDevice

SetNetTransMode(NetTransMode mode) IGigEDevice

SetResend(bool enable, UInt32 maxResendPercent, UInt32 resendTimeout) IGigEDevice

SetResendMaxRetryTimes(UInt32 retryTimes) IGigEDevice

SetResendTimeInterval(UInt32 timeInMS) IGigEDevice

SetRetryGvcpTimes(UInt32 retryGvcpTimes) IGigEDevice

SetTransmissionType(TransmissionType type, UInt32 multicastIP, UInt32 multicastPort) IGigEDevice

StreamGrabber IDevice

VideoRecorder IDevice

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IUSBDevice 成员列表

成员的完整列表，这些成员属于 IUSBDevice,包括所有继承而来的类成员

Close() IDevice

DeviceExceptionEvent IDevice

DeviceInfo IDevice

EventGrabber IDevice

EventNotificationOff(String eventName) IDevice

EventNotificationOn(String eventName) IDevice

GetSyncTimeOut(out UInt32 timeoutInMS) IUSBDevice

GetTransferSize(out UInt32 transferSize) IUSBDevice

GetTransferWays(out UInt32 transferWays) IUSBDevice

GetUpgradeProcess(out UInt32 process) IDevice

GetUSBTransInfo(out USBTransInfo usbTransInfo) IUSBDevice

ImageDecoder IDevice

ImageProcess IDevice

ImageRender IDevice

ImageSaver IDevice

IsConnected IDevice

LocalUpgrade(String filePath) IDevice

Open() IDevice

Open(DeviceAccessMode AccessMode, UInt32 switchoverKey) IDevice

Parameters IDevice

PixelTypeConverter IDevice

SetEventNodeNum(UInt32 eventNodeNum) IUSBDevice

SetSyncTimeOut(UInt32 timeoutInMS) IUSBDevice

SetTransferSize(UInt32 transferSize) IUSBDevice

SetTransferWays(UInt32 transferWays) IUSBDevice

StreamGrabber IDevice

VideoRecorder IDevice

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

ICamlDevice 成员列表

成员的完整列表，这些成员属于 ICamlDevice,包括所有继承而来的类成员

Close() IDevice

DeviceExceptionEvent IDevice

DeviceInfo IDevice

EventGrabber IDevice

EventNotificationOff(String eventName) IDevice

EventNotificationOn(String eventName) IDevice

GetDeviceBaudrate(out CameraLinkBaudrate baudrate) ICamlDevice

GetSupportBaudrates(out UInt32 baudrateAbility) ICamlDevice

GetUpgradeProcess(out UInt32 process) IDevice

ImageDecoder IDevice

ImageProcess IDevice

ImageRender IDevice

ImageSaver IDevice

IsConnected IDevice

LocalUpgrade(String filePath) IDevice

Open() IDevice

Open(DeviceAccessMode AccessMode, UInt32 switchoverKey) IDevice

Parameters IDevice

PixelTypeConverter IDevice

SetDeviceBaudrate(CameraLinkBaudrate baudrate) ICamlDevice

SetGenCPTimeOut(UInt32 timeoutInMS) ICamlDevice

StreamGrabber IDevice

VideoRecorder IDevice

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

ActionCmdInfo 成员列表

成员的完整列表，这些成员属于 ActionCmdInfo,包括所有继承而来的类成员

ActionTime ActionCmdInfo

ActionTimeEnable ActionCmdInfo

BroadcastAddress ActionCmdInfo

DeviceKey ActionCmdInfo

GroupKey ActionCmdInfo

GroupMask ActionCmdInfo

SpecialNetEnable ActionCmdInfo

SpecialNetIP ActionCmdInfo

TimeOut ActionCmdInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

ActionCmdResult 成员列表

成员的完整列表，这些成员属于 ActionCmdResult,包括所有继承而来的类成员

DeviceAddress ActionCmdResult

Status ActionCmdResult

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

DeviceEnumerator 成员列表

成员的完整列表，这些成员属于 DeviceEnumerator,包括所有继承而来的类成员

EnumDevices(DeviceTLayerType TLayerType, out List< IDeviceInfo > devInfoList) DeviceEnumerator static

EnumDevicesEx(DeviceTLayerType TLayerType, String manufacturerName, out List< IDeviceInfo > devInfoList) DeviceEnumerator static

EnumDevicesEx2(DeviceTLayerType TLayerType, SortMethod sortMethod, String manufacturerName, out List< IDeviceInfo > devInfoList) DeviceEnumerator static

GetGigEMulticastStatus(IDeviceInfo deviceInfo, out Boolean status) DeviceEnumerator static

GetSerialPortList(out List< String > serialPortList) DeviceEnumerator static

GigEIssueActionCommand(ActionCmdInfo actionCmdInfo, out List< ActionCmdResult > actionCmdResults) DeviceEnumerator static

IsDeviceAccessible(IDeviceInfo deviceInfo, DeviceAccessMode accessMode) DeviceEnumerator static

SetEnumSerialPorts(List< String > serialPortList) DeviceEnumerator static

SetGigEDeviceDiscoryMode(UInt32 mode) DeviceEnumerator static

SetGigEDeviceEnumTimeout(UInt32 timeoutInMS) DeviceEnumerator static

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

DeviceFactory 成员列表

成员的完整列表，这些成员属于 DeviceFactory,包括所有继承而来的类成员

CreateDevice(IDeviceInfo deviceInfo) DeviceFactory static

CreateDeviceByGenTL(IGenTLDevInfo devInfo) DeviceFactory static

CreateDeviceByIp(String deviceIp, String netExportIp) DeviceFactory static

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IDeviceInfo 成员列表

成员的完整列表，这些成员属于 IDeviceInfo,包括所有继承而来的类成员

DeviceVersion IDeviceInfo

DevTypeInfo IDeviceInfo

ManufacturerName IDeviceInfo

ModelName IDeviceInfo

SerialNumber IDeviceInfo

TLayerType IDeviceInfo

UserDefinedName IDeviceInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IGigEDeviceInfo 成员列表

成员的完整列表，这些成员属于 IGigEDeviceInfo,包括所有继承而来的类成员

CurrentIp IGigEDeviceInfo

CurrentSubNetMask IGigEDeviceInfo

DefultGateWay IGigEDeviceInfo

DeviceVersion IDeviceInfo

DevTypeInfo IDeviceInfo

GenTLDevice IGigEDeviceInfo

IpCfgCurrent IGigEDeviceInfo

IpCfgOption IGigEDeviceInfo

MacAddrHigh IGigEDeviceInfo

MacAddrLow IGigEDeviceInfo

MajorVer IGigEDeviceInfo

ManufacturerName IDeviceInfo

MinorVer IGigEDeviceInfo

ModelName IDeviceInfo

NetExport IGigEDeviceInfo

SerialNumber IDeviceInfo

TLayerType IDeviceInfo

UserDefinedName IDeviceInfo

VirtualDevice IGigEDeviceInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IUSBDeviceInfo 成员列表

成员的完整列表，这些成员属于 IUSBDeviceInfo,包括所有继承而来的类成员

CrtlInEndPoint IUSBDeviceInfo

CrtlOutEndPoint IUSBDeviceInfo

DeviceAddress IUSBDeviceInfo

DeviceGUID IUSBDeviceInfo

DeviceNumber IUSBDeviceInfo

DeviceVersion IDeviceInfo

DevTypeInfo IDeviceInfo

EventEndPoint IUSBDeviceInfo

FamilyName IUSBDeviceInfo

ManufacturerName IDeviceInfo

ModelName IDeviceInfo

nbcdUSB IUSBDeviceInfo

ProductID IUSBDeviceInfo

SerialNumber IDeviceInfo

StreamEndPoint IUSBDeviceInfo

TLayerType IDeviceInfo

UserDefinedName IDeviceInfo

VendorID IUSBDeviceInfo

VirtualDevice IUSBDeviceInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

ICamlDeviceInfo 成员列表

成员的完整列表，这些成员属于 ICamlDeviceInfo,包括所有继承而来的类成员

DeviceVersion IDeviceInfo

DevTypeInfo IDeviceInfo

FamilyName ICamlDeviceInfo

ManufacturerName IDeviceInfo

ModelName IDeviceInfo

PortID ICamlDeviceInfo

SerialNumber IDeviceInfo

TLayerType IDeviceInfo

UserDefinedName IDeviceInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

ICXPDeviceInfo 成员列表

成员的完整列表，这些成员属于 ICXPDeviceInfo,包括所有继承而来的类成员

DeviceID ICXPDeviceInfo

DeviceVersion IDeviceInfo

DevTypeInfo IDeviceInfo

InterfaceID ICXPDeviceInfo

ManufacturerName IDeviceInfo

ModelName IDeviceInfo

SerialNumber IDeviceInfo

TLayerType IDeviceInfo

UserDefinedName IDeviceInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

ICameraLinkDeviceInfo 成员列表

成员的完整列表，这些成员属于 ICameraLinkDeviceInfo,包括所有继承而来的类成员

DeviceID ICameraLinkDeviceInfo

DeviceVersion IDeviceInfo

DevTypeInfo IDeviceInfo

InterfaceID ICameraLinkDeviceInfo

ManufacturerName IDeviceInfo

ModelName IDeviceInfo

SerialNumber IDeviceInfo

TLayerType IDeviceInfo

UserDefinedName IDeviceInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IXoFDeviceInfo 成员列表

成员的完整列表，这些成员属于 IXoFDeviceInfo,包括所有继承而来的类成员

DeviceID IXoFDeviceInfo

DeviceVersion IDeviceInfo

DevTypeInfo IDeviceInfo

InterfaceID IXoFDeviceInfo

ManufacturerName IDeviceInfo

ModelName IDeviceInfo

SerialNumber IDeviceInfo

TLayerType IDeviceInfo

UserDefinedName IDeviceInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IInterface 成员列表

成员的完整列表，这些成员属于 IInterface,包括所有继承而来的类成员

Close() IInterface

EnumDevices(out List< IDeviceInfo > devInfoList) IInterface

EventGrabber IInterface

EventNotificationOff(String eventName) IInterface

EventNotificationOn(String eventName) IInterface

GetUpgradeProcess(out UInt32 process) IInterface

LocalUpgrade(String filePath) IInterface

Open() IInterface

Parameters IInterface

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

InterfaceEnumerator 成员列表

成员的完整列表，这些成员属于 InterfaceEnumerator,包括所有继承而来的类成员

EnumInterfaces(InterfaceTLayerType TLayerType, out List< IInterfaceInfo > interfaceInfoList) InterfaceEnumerator static

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

InterfaceFactory 成员列表

成员的完整列表，这些成员属于 InterfaceFactory,包括所有继承而来的类成员

CreateInterface(IInterfaceInfo interfaceInfo) InterfaceFactory static

CreateInterface(String interfaceID) InterfaceFactory static

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IInterfaceInfo 成员列表

成员的完整列表，这些成员属于 IInterfaceInfo,包括所有继承而来的类成员

DeviceVersion IInterfaceInfo

DisplayName IInterfaceInfo

InterfaceID IInterfaceInfo

Manufacturer IInterfaceInfo

ModelName IInterfaceInfo

PCIEInfo IInterfaceInfo

SerialNumber IInterfaceInfo

TLayerType IInterfaceInfo

UserDefinedName IInterfaceInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IIntValue 成员列表

成员的完整列表，这些成员属于 IIntValue,包括所有继承而来的类成员

CurValue IIntValue

Inc IIntValue

Max IIntValue

Min IIntValue

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IFloatValue 成员列表

成员的完整列表，这些成员属于 IFloatValue,包括所有继承而来的类成员

CurValue IFloatValue

Max IFloatValue

Min IFloatValue

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IStringValue 成员列表

成员的完整列表，这些成员属于 IStringValue,包括所有继承而来的类成员

CurValue IStringValue

MaxLength IStringValue

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IEnumEntry 成员列表

成员的完整列表，这些成员属于 IEnumEntry,包括所有继承而来的类成员

Symbolic IEnumEntry

Value IEnumEntry

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IEnumValue 成员列表

成员的完整列表，这些成员属于 IEnumValue,包括所有继承而来的类成员

CurEnumEntry IEnumValue

SupportedNum IEnumValue

SupportEnumEntries IEnumValue

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

INodeError 成员列表

成员的完整列表，这些成员属于 INodeError,包括所有继承而来的类成员

ErrorType INodeError

NodeName INodeError

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IParameters 成员列表

成员的完整列表，这些成员属于 IParameters,包括所有继承而来的类成员

FeatureLoad(String filePath) IParameters

FeatureLoadEx(String filePath, out List< INodeError > nodeErrors) IParameters

FeatureSave(String filePath) IParameters

FileAccessRead(String deviceFileName, String localFilePath) IParameters

FileAccessRead(String devFileName, out Byte[] buffer) IParameters

FileAccessWrite(String deviceFileName, String localFilePath) IParameters

FileAccessWrite(String devFileName, Byte[] buffer) IParameters

GetBoolValue(String key, out bool value) IParameters

GetEnumValue(String key, out IEnumValue value) IParameters

GetFileAccessProgress(out Int64 completed, out Int64 total) IParameters

GetFloatValue(String key, out IFloatValue value) IParameters

GetGenICamXML(out String xmlData) IParameters

GetIntValue(String key, out IIntValue value) IParameters

GetNodeAccessMode(String name, out XmlAccessMode mode) IParameters

GetNodeInterfaceType(String name, out XmlInterfaceType type) IParameters

GetStringValue(String key, out IStringValue value) IParameters

InvalidateNodes() IParameters

ReadMemory(Int64 address, Int64 length, out Byte[] buffer) IParameters

SetBoolValue(String key, bool value) IParameters

SetCommandValue(String key) IParameters

SetEnumValue(String key, UInt32 value) IParameters

SetEnumValueByString(String key, String value) IParameters

SetFloatValue(String key, float value) IParameters

SetIntValue(String key, Int64 value) IParameters

SetStringValue(String key, String value) IParameters

WriteMemory(Int64 address, Int64 length, Byte[] buffer) IParameters

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

StreamExceptionEventArgs 成员列表

成员的完整列表，这些成员属于 StreamExceptionEventArgs,包括所有继承而来的类成员

StreamException StreamExceptionEventArgs

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IChunkData 成员列表

成员的完整列表，这些成员属于 IChunkData,包括所有继承而来的类成员

ChunkID IChunkData

Data IChunkData

DataPtr IChunkData

Length IChunkData

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IChunkInfo 成员列表

成员的完整列表，这些成员属于 IChunkInfo,包括所有继承而来的类成员

this[UInt32 ChunkID] IChunkInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IImage 成员列表

成员的完整列表，这些成员属于 IImage,包括所有继承而来的类成员

Height IImage

ImageSize IImage

PixelData IImage

PixelDataPtr IImage

PixelType IImage

ToBitmap() IImage

Width IImage

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IFrameOut 成员列表

成员的完整列表，这些成员属于 IFrameOut,包括所有继承而来的类成员

AverageBrightness IFrameOut

Blue IFrameOut

ChunkInfo IFrameOut

CycleCount IFrameOut

CycleOffset IFrameOut

DevTimeStamp IFrameOut

ExposureTime IFrameOut

FrameCount IFrameOut

FrameLen IFrameOut

FrameNum IFrameOut

Gain IFrameOut

Green IFrameOut

HostTimeStamp IFrameOut

Image IFrameOut

Input IFrameOut

LostPacket IFrameOut

OffsetX IFrameOut

OffsetY IFrameOut

Output IFrameOut

Red IFrameOut

SecondCount IFrameOut

TriggerIndex IFrameOut

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

FrameGrabbedEventArgs 成员列表

成员的完整列表，这些成员属于 FrameGrabbedEventArgs,包括所有继承而来的类成员

FrameOut FrameGrabbedEventArgs

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IStreamGrabber 成员列表

成员的完整列表，这些成员属于 IStreamGrabber,包括所有继承而来的类成员

ClearImageBuffer() IStreamGrabber

FrameGrabedEvent IStreamGrabber

FreeImageBuffer(IFrameOut frame) IStreamGrabber

GetImageBuffer(UInt32 timeoutInMS, out IFrameOut frameOut) IStreamGrabber

GetValidImageNum(out UInt32 num) IStreamGrabber

SetImageNodeNum(UInt32 num) IStreamGrabber

SetOutputQueueSize(UInt32 size) IStreamGrabber

StartGrabbing() IStreamGrabber

StartGrabbing(StreamGrabStrategy strategy) IStreamGrabber

StopGrabbing() IStreamGrabber

StreamExceptionEvent IStreamGrabber

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

MvColor 成员列表

成员的完整列表，这些成员属于 MvColor,包括所有继承而来的类成员

Alpha MvColor

B MvColor

G MvColor

MvColor(float r, float g, float b, float alpha) MvColor

R MvColor

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

MvRect 成员列表

成员的完整列表，这些成员属于 MvRect,包括所有继承而来的类成员

Bottom MvRect

Left MvRect

MvRect(float top, float bottom, float left, float right) MvRect

Right MvRect

Top MvRect

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

MvPoint 成员列表

成员的完整列表，这些成员属于 MvPoint,包括所有继承而来的类成员

MvPoint(float x, float y) MvPoint

X MvPoint

Y MvPoint

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

MvCircle 成员列表

成员的完整列表，这些成员属于 MvCircle,包括所有继承而来的类成员

CenterPoint MvCircle

MvCircle(MvPoint centerPoint, float r1, float r2) MvCircle

R1 MvCircle

R2 MvCircle

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

MvLine 成员列表

成员的完整列表，这些成员属于 MvLine,包括所有继承而来的类成员

EndPoint MvLine

StartPoint MvLine

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IImageRender 成员列表

成员的完整列表，这些成员属于 IImageRender,包括所有继承而来的类成员

DisplayOneFrame(IntPtr hWnd, IImage image, RenderMode mode=RenderMode.Default) IImageRender

DisplayOneFrame(IntPtr hWnd, IntPtr imageDataPtr, UInt32 imageLen, UInt32 width, UInt32 height, MvGvspPixelType PixelType, RenderMode mode=RenderMode.Default) IImageRender

DrawCircle(MvCircle circle, MvColor color, UInt32 lineWidth) IImageRender

DrawLine(MvLine line, MvColor color, UInt32 lineWidth) IImageRender

DrawRect(MvRect rect, MvColor color, UInt32 lineWidth) IImageRender

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IImageDecoder 成员列表

成员的完整列表，这些成员属于 IImageDecoder,包括所有继承而来的类成员

HBDecode(IFrameOut inFrameInfo, out IFrameOut outFrameInfo) IImageDecoder

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IImageProcess 成员列表

成员的完整列表，这些成员属于 IImageProcess,包括所有继承而来的类成员

FlipImage(IImage inImage, out IImage outImage, ImageFlipType flipType) IImageProcess

ImageContrast(IImage inImage, out IImage outImage, UInt32 contrastFactor) IImageProcess

ReconstructImage(IImage inImage, UInt32 exposureNum, ImageReconstructionMethod method, ImageStitchingMethod imageStitchingMethod, out IImage outImage) IImageProcess

RotateImage(IImage inImage, out IImage outImage, ImageRotateAngle angle) IImageProcess

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

ImageFormatInfo 成员列表

成员的完整列表，这些成员属于 ImageFormatInfo,包括所有继承而来的类成员

FormatType ImageFormatInfo

JpegQuality ImageFormatInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IImageSaver 成员列表

成员的完整列表，这些成员属于 IImageSaver,包括所有继承而来的类成员

SaveImageToBuffer(Byte[] buffer, out UInt32 dataLen, IImage image, ImageFormatInfo imageFormatInfo, CFAMethod cfaMethod) IImageSaver

SaveImageToFile(String filePath, IImage image, ImageFormatInfo imageFormatInfo, CFAMethod cfaMethod) IImageSaver

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

GammaParam 成员列表

成员的完整列表，这些成员属于 GammaParam,包括所有继承而来的类成员

CurveBuf GammaParam

CurveLen GammaParam

Type GammaParam

Value GammaParam

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

CCMParam 成员列表

成员的完整列表，这些成员属于 CCMParam,包括所有继承而来的类成员

CCMat CCMParam

CCMEnable CCMParam

CCMScale CCMParam

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IPixelTypeConverter 成员列表

成员的完整列表，这些成员属于 IPixelTypeConverter,包括所有继承而来的类成员

ConvertPixelType(IImage inImage, out IImage outImage, MvGvspPixelType dstPixelType) IPixelTypeConverter

ConvertPixelType(IImage inImage, Byte[] outBuffer, out UInt64 outDataLen, MvGvspPixelType dstPixelType) IPixelTypeConverter

GetBufferSizeForConvert(MvGvspPixelType dstPixelType, UInt32 width, UInt32 height) IPixelTypeConverter

SetBayerCCMParam(CCMParam ccmParam) IPixelTypeConverter

SetBayerCvtQuality(CFAMethod method) IPixelTypeConverter

SetBayerFilterEnable(bool enable) IPixelTypeConverter

SetBayerGammaParam(GammaParam gammaParam) IPixelTypeConverter

SetBayerGammaValue(float gammaValue) IPixelTypeConverter

SetGammaValue(MvGvspPixelType pixelType, float gammaValue) IPixelTypeConverter

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

RecordParam 成员列表

成员的完整列表，这些成员属于 RecordParam,包括所有继承而来的类成员

BitRate RecordParam

FormatType RecordParam

FrameRate RecordParam

Height RecordParam

PixelType RecordParam

Width RecordParam

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IVideoRecorder 成员列表

成员的完整列表，这些成员属于 IVideoRecorder,包括所有继承而来的类成员

InputOneFrame(IImage image) IVideoRecorder

StartRecord(String filePath, RecordParam recordParam) IVideoRecorder

StopRecord() IVideoRecorder

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IEventOutInfo 成员列表

成员的完整列表，这些成员属于 IEventOutInfo,包括所有继承而来的类成员

BlockId IEventOutInfo

EventData IEventOutInfo

EventDataSize IEventOutInfo

EventID IEventOutInfo

EventName IEventOutInfo

StreamChannel IEventOutInfo

Timestamp IEventOutInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

DeviceEventArgs 成员列表

成员的完整列表，这些成员属于 DeviceEventArgs,包括所有继承而来的类成员

EventInfo DeviceEventArgs

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IEventGrabber 成员列表

成员的完整列表，这些成员属于 IEventGrabber,包括所有继承而来的类成员

DeviceEvent IEventGrabber

SubscribeAllEvent() IEventGrabber

SubscribeEvent(String eventName) IEventGrabber

UnSubscribeAllEvent() IEventGrabber

UnSubscribeEvent(String eventName) IEventGrabber

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IGenTLIFInfo 成员列表

成员的完整列表，这些成员属于 IGenTLIFInfo,包括所有继承而来的类成员

CtiIndex IGenTLIFInfo

DisplayName IGenTLIFInfo

InterfaceID IGenTLIFInfo

TLType IGenTLIFInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

IGenTLDevInfo 成员列表

成员的完整列表，这些成员属于 IGenTLDevInfo,包括所有继承而来的类成员

CtiIndex IGenTLDevInfo

DeviceID IGenTLDevInfo

DeviceVersion IGenTLDevInfo

DisplayName IGenTLDevInfo

InterfaceID IGenTLDevInfo

ModelName IGenTLDevInfo

SerialNumber IGenTLDevInfo

TLType IGenTLDevInfo

UserDefinedName IGenTLDevInfo

VendorName IGenTLDevInfo

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

GenTLManager 成员列表

成员的完整列表，这些成员属于 GenTLManager,包括所有继承而来的类成员

EnumDevicesByGenTL(IGenTLIFInfo IFInfo, out List< IGenTLDevInfo > devList) GenTLManager static

EnumInterfacesByGenTL(String ctiPath, out List< IGenTLIFInfo > IFList) GenTLManager static

UnloadGenTLLibrary(String ctiPath) GenTLManager static

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

MvError 成员列表

成员的完整列表，这些成员属于 MvError,包括所有继承而来的类成员

MV_ALG_E_ABILITY_ARG MvError

MV_ALG_E_BAD_ARG MvError

MV_ALG_E_BIND_CORE_FAILED MvError

MV_ALG_E_CALL_BACK MvError

MV_ALG_E_CFG_SIZE MvError

MV_ALG_E_CFG_TYPE MvError

MV_ALG_E_CPUID MvError

MV_ALG_E_DATA_SIZE MvError

MV_ALG_E_DENOISE_COLOR_MODE MvError

MV_ALG_E_DENOISE_GAIN_BEYOND_RANGE MvError

MV_ALG_E_DENOISE_GAIN_NOT_EXIST MvError

MV_ALG_E_DENOISE_NE_BIN_NUM MvError

MV_ALG_E_DENOISE_NE_FEATURE_TYPE MvError

MV_ALG_E_DENOISE_NE_GAIN_NUM MvError

MV_ALG_E_DENOISE_NE_GAIN_VAL MvError

MV_ALG_E_DENOISE_NE_IMG_FORMAT MvError

MV_ALG_E_DENOISE_NE_INIT_GAIN MvError

MV_ALG_E_DENOISE_NE_NOT_INIT MvError

MV_ALG_E_DENOISE_NE_PROFILE_NUM MvError

MV_ALG_E_DENOISE_NP_BUF_SIZE MvError

MV_ALG_E_DENOISE_ROI_NUM MvError

MV_ALG_E_DENOISE_ROI_ORI_PT MvError

MV_ALG_E_DENOISE_ROI_SIZE MvError

MV_ALG_E_ENCRYPT MvError

MV_ALG_E_EXPIRE MvError

MV_ALG_E_FILE_NON_EXIST MvError

MV_ALG_E_FILE_OPEN MvError

MV_ALG_E_FILE_READ MvError

MV_ALG_E_FILE_READ_SIZE MvError

MV_ALG_E_FILE_TYPE MvError

MV_ALG_E_FILE_WRITE MvError

MV_ALG_E_FUNC_SIZE MvError

MV_ALG_E_FUNC_TYPE MvError

MV_ALG_E_GPU_MEM_ALLOC MvError

MV_ALG_E_IMAGE_CODEC MvError

MV_ALG_E_IMG_DATA_NULL MvError

MV_ALG_E_IMG_FORMAT MvError

MV_ALG_E_IMG_SIZE MvError

MV_ALG_E_IMG_STEP MvError

MV_ALG_E_LIB_VERSION MvError

MV_ALG_E_MALLOC_MEM MvError

MV_ALG_E_MEM_ADDR_ALIGN MvError

MV_ALG_E_MEM_ALIGN MvError

MV_ALG_E_MEM_LACK MvError

MV_ALG_E_MEM_NULL MvError

MV_ALG_E_MEM_SIZE_ALIGN MvError

MV_ALG_E_MODEL_TYPE MvError

MV_ALG_E_MODEL_VERSION MvError

MV_ALG_E_NONE_STRING MvError

MV_ALG_E_NULL_PTR MvError

MV_ALG_E_OVER_MAX_MEM MvError

MV_ALG_E_PARAM_INDEX MvError

MV_ALG_E_PARAM_NUM MvError

MV_ALG_E_PARAM_VALUE MvError

MV_ALG_E_PRC_SIZE MvError

MV_ALG_E_PRC_TYPE MvError

MV_ALG_E_STEP MvError

MV_ALG_E_TIME_OUT MvError

MV_ALG_ERR MvError

MV_ALG_OK MvError

MV_ALG_WARNING MvError

MV_E_ABNORMAL_IMAGE MvError

MV_E_ACCESS_DENIED MvError

MV_E_BUFOVER MvError

MV_E_BUSY MvError

MV_E_CALLORDER MvError

MV_E_ENCRYPT MvError

MV_E_GC_ACCESS MvError

MV_E_GC_ARGUMENT MvError

MV_E_GC_DYNAMICCAST MvError

MV_E_GC_GENERIC MvError

MV_E_GC_LOGICAL MvError

MV_E_GC_PROPERTY MvError

MV_E_GC_RANGE MvError

MV_E_GC_RUNTIME MvError

MV_E_GC_TIMEOUT MvError

MV_E_GC_UNKNOW MvError

MV_E_HANDLE MvError

MV_E_INVALID_ADDRESS MvError

MV_E_IP_CONFLICT MvError

MV_E_LOAD_LIBRARY MvError

MV_E_NETER MvError

MV_E_NODATA MvError

MV_E_NOENOUGH_BUF MvError

MV_E_NOOUTBUF MvError

MV_E_NOT_IMPLEMENTED MvError

MV_E_PACKET MvError

MV_E_PARAMETER MvError

MV_E_PRECONDITION MvError

MV_E_RESOURCE MvError

MV_E_SUPPORT MvError

MV_E_UNKNOW MvError

MV_E_UPG_CONFLICT MvError

MV_E_UPG_FILE_MISMATCH MvError

MV_E_UPG_INNER_ERR MvError

MV_E_UPG_LANGUSGE_MISMATCH MvError

MV_E_UPG_UNKNOW MvError

MV_E_USB_BANDWIDTH MvError

MV_E_USB_DEVICE MvError

MV_E_USB_DRIVER MvError

MV_E_USB_GENICAM MvError

MV_E_USB_READ MvError

MV_E_USB_UNKNOW MvError

MV_E_USB_WRITE MvError

MV_E_VERSION MvError

MV_E_WRITE_PROTECT MvError

MV_OK MvError

* * *

首页

发版说明

编程引导

API参考

示例程序

法律声明

MvException 成员列表

成员的完整列表，这些成员属于 MvException,包括所有继承而来的类成员

ErrorCode MvException

* * *

